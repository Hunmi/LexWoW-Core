
/*
 * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
 * ArcEmu MMORPG Server
 * Copyright (C) 2008 <http://www.ArcEmu.org/>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/////////////////////////////////////////////////
//  Admin Chat Commands
//

#include "StdAfx.h"
#include "ObjectMgr.h"
#include "Master.h"

bool ChatHandler::HandleWorldPortCommand(const char* args, WorldSession *m_session)
{
	float x, y, z;
	uint32 mapid;
	if(sscanf(args, "%u %f %f %f", (unsigned int*)&mapid, &x, &y, &z) != 4)
		return false;

	if(x >= _maxX || x <= _minX || y <= _minY || y >= _maxY)
		return false;

	LocationVector vec(x, y, z);
	m_session->GetPlayer()->SafeTeleport(mapid, 0, vec);
	return true;
}


bool ChatHandler::HandleClearCooldownsCommand(const char *args, WorldSession *m_session)
{
	uint32 guid = (uint32)m_session->GetPlayer()->GetSelection();
	Player *plr = getSelectedChar(m_session, true);
/*
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() )
		plr = m_session->GetPlayer();
#endif	
		*/
	if(!plr)
	{
		plr = m_session->GetPlayer();
		SystemMessage(m_session, "Auto-targeting self.");
	}
	if(!plr) return false;

	if(plr != m_session->GetPlayer())
	{
		plr->BroadcastMessage( "GM %s cleared your cooldowns", m_session->GetPlayer()->GetName() );
		m_session->GetPlayer()->BroadcastMessage( "You cleared cooldowns of player %s ", plr->GetName() );
		sGMLog.writefromsession(m_session, "Cleared all cooldowns for player %s", plr->GetName());
	}
	else
		plr->BroadcastMessage( "Cooldowns were cleared" );


/*	if(plr->getClass()==WARRIOR)
	{
		plr->ClearCooldownsOnLine(26, guid);
		plr->ClearCooldownsOnLine(256, guid);
		plr->ClearCooldownsOnLine(257 , guid);
		BlueSystemMessage(m_session, "Cleared all Warrior cooldowns.");
		return true;
	}
	if(plr->getClass()==PALADIN)
	{
		plr->ClearCooldownsOnLine(594, guid);
		plr->ClearCooldownsOnLine(267, guid);
		plr->ClearCooldownsOnLine(184, guid);
		BlueSystemMessage(m_session, "Cleared all Paladin cooldowns.");
		return true;
	}
	if(plr->getClass()==HUNTER)
	{
		plr->ClearCooldownsOnLine(50, guid);
		plr->ClearCooldownsOnLine(51, guid);
		plr->ClearCooldownsOnLine(163, guid);
		BlueSystemMessage(m_session, "Cleared all Hunter cooldowns.");
		return true;
	}
	if(plr->getClass()==ROGUE)
	{
		plr->ClearCooldownsOnLine(253, guid);
		plr->ClearCooldownsOnLine(38, guid);
		plr->ClearCooldownsOnLine(39, guid);
		BlueSystemMessage(m_session, "Cleared all Rogue cooldowns.");
		return true;
	}
	if(plr->getClass()==PRIEST)
	{
		plr->ClearCooldownsOnLine(56, guid);
		plr->ClearCooldownsOnLine(78, guid);
		plr->ClearCooldownsOnLine(613, guid);
		BlueSystemMessage(m_session, "Cleared all Priest cooldowns.");
		return true;
	}
	if(plr->getClass()==SHAMAN)
	{
		plr->ClearCooldownsOnLine(373, guid);
		plr->ClearCooldownsOnLine(374, guid);
		plr->ClearCooldownsOnLine(375, guid);
		BlueSystemMessage(m_session, "Cleared all Shaman cooldowns.");
		return true;
	}
	if(plr->getClass()==MAGE)
	{
		plr->ClearCooldownsOnLine(6, guid);
		plr->ClearCooldownsOnLine(8, guid);
		plr->ClearCooldownsOnLine(237, guid);
		BlueSystemMessage(m_session, "Cleared all Mage cooldowns.");
		return true;
	}
	if(plr->getClass()==WARLOCK)
	{
		plr->ClearCooldownsOnLine(355, guid);
		plr->ClearCooldownsOnLine(354, guid);
		plr->ClearCooldownsOnLine(593, guid);
		BlueSystemMessage(m_session, "Cleared all Warlock cooldowns.");
		return true;
	}
	if(plr->getClass()==DRUID)
	{
		plr->ClearCooldownsOnLine(573, guid);
		plr->ClearCooldownsOnLine(574, guid);
		plr->ClearCooldownsOnLine(134, guid);
		BlueSystemMessage(m_session, "Cleared all Druid cooldowns.");
		return true;
	}*/
/*	{
		plr->ResetAllCooldowns();
		BlueSystemMessage(m_session, "Cleared all cooldowns.");
	}/**/
	{
		SpellSet::const_iterator itr;
		for(itr = plr->mSpells.begin(); itr != plr->mSpells.end(); ++itr)
		{
			SpellEntry *sp = dbcSpell.LookupEntryForced( (*itr) );
			if( sp == NULL 
				|| (sp->Attributes & ATTRIBUTES_PASSIVE) 
				|| (sp->c_is_flags2 & SPELL_FLAG2_IS_PROFESSION_SPELL)
				|| sp->spell_skilline[0] == SKILL_MOUNTS
				|| sp->spell_skilline[0] == SKILL_COMPANIONS
				)
				continue;
			plr->ClearCooldownForSpell( (*itr) );
		}
		plr->m_cooldownMap[0].clear();
		plr->m_cooldownMap[1].clear();
		if( plr->GetSummon() )
			plr->GetSummon()->ClearSpellCooldowns();
	}
/*	{
		SpellSet::const_iterator itr = plr->mSpells.begin();
		for(; itr != plr->mSpells.end(); ++itr)
		{
			WorldPacket data(12);
			data.SetOpcode(SMSG_CLEAR_COOLDOWN);
			data << (*itr) << plyr->GetGUID();
			plr->GetSession()->SendPacket(&data);
//			plr->ClearCooldownForSpell( (*itr) );
		}
		plr->m_cooldownMap[0].clear();
		plr->m_cooldownMap[1].clear();
	}/**/
	return true;
}

bool ChatHandler::HandleClearCooldownCommand(const char* args, WorldSession *m_session)
{
	if( args == NULL )
		return false;
	uint32 Spellid;
	if(sscanf(args, "%u", (unsigned int*)&Spellid) != 1)
		return false;

	m_session->GetPlayer()->ClearCooldownForSpell( Spellid );
	return true;
}

bool ChatHandler::HandleAchievementEventCommand(const char* args, WorldSession *m_session)
{
	if (!*args)
		return false;

	Player *plr = getSelectedChar(m_session, true);
	if(!plr)
	{
		plr = m_session->GetPlayer();
		SystemMessage(m_session, "Auto-targeting self.");
	}
	if(!plr) 
		return false;

	uint32 CriteriaType = ACHIEVEMENT_CRITERIA_TYPE_REACH_PERSONAL_RATING, Filter1 = 2, Filter2 = ACHIEVEMENT_UNUSED_FIELD_VALUE, Value = 1, Action = ACHIEVEMENT_EVENT_ACTION_SET_MAX;
	if(sscanf(args, "%u %u %u %u %u", &CriteriaType, &Filter1, &Filter2, &Value, &Action ) != 5)
	{
		m_session->GetPlayer()->BroadcastMessage( "Usage : cmd [CriteriaType] [filter1] [filter2] [value] [action]");
		m_session->GetPlayer()->BroadcastMessage( "Usage ex : achievementevent 95 2 -1 2250 2");
		return false;
	}

	plr->Event_AchiementCriteria_Received( CriteriaType, Filter1, Filter2, Value, Action );

	return true;
}

bool ChatHandler::HandleCastNextSpellCommand(const char* args, WorldSession *m_session)
{
	Player *plr = m_session->GetPlayer();

	int32 Param, ParamCount;
	ParamCount = sscanf(args, "%u", &Param );

	//testing spell visuals
	// import "SpellVisual.dbc.csv" ( + "SpellVisualKit.csv" + "SpellVisualEffectName.dbc.csv" )
	// filter it : select id from dbc_spell where durationindex != 0 and spellvisual_1 in ( select col_0 from SpellVisualdbccsv where col_4!=0 group by col_4 ) group by spellvisual_1 order by id asc;

//	static uint32 CastList[] = { 13,43,89,91,112,116,118,130,131,134,136,139,228,246,324,348,461,465,498,543,546,550,568,586,588,589,606,676,687,702,740,744,768,774,785,835,851,853,974,980,982,1022,1038,1044,1066,1130,1138,1160,1161,1490,1513,1706,1714,1715,1776,1833,1834,1953,2139,2645,2812,2825,2855,2871,3045,3147,3150,3288,3355,3396,3428,3446,3488,3551,3574,3650,3652,3671,3674,4057,4063,4070,4142,4146,4153,4294,4318,4524,4933,4971,4974,4979,5101,5110,5116,5118,5137,5165,5280,5320,5321,5322,5323,5324,5325,5424,5545,5697,5703,5784,5862,5951,6117,6136,6150,6197,6229,6306,6343,6422,6431,6558,6755,6758,6770,6866,6873,6917,6940,6945,6951,6957,7001,7072,7081,7082,7144,7211,7294,7302,7331,7367,7434,7638,7656,7764,7865,8042,8050,8096,8099,8112,8115,8221,8222,8255,8272,8286,8314,8338,8346,8365,8510,8609,8646,8672,8733,8817,8893,8901,9178,9733,9991,10093,10251,10268,10270,10326,10348,10388,10618,10727,10730,11014,11020,11371,11374,11641,11649,11820,11826,12323,12355,12479,12536,12565,12733,12941,13003,13159,13165,13466,13583,13589,13819,13910,14530,14871,14914,15286,15288,15602,16007,16188,16310,16350,16452,16552,16592,16609,16689,16708,16716,17152,17364,17941,18502,18545,18765,18789,18790,18791,18792,19574,19695,19726,19727,19952,20000,20043,20066,20154,20164,20165,20542,20687,20707,20708,21066,21078,21154,21167,22008,22093,22291,22570,22572,22751,22905,23016,23072,23120,23171,23174,23269,23364,23451,23505,23601,23734,24065,24192,24221,24352,24499,24531,24683,24690,24721,24858,24893,25003,25839,25947,26008,26035,26072,26102,26157,26232,26286,26385,26470,26664,26680,26898,27553,27571,27572,27907,28176,28271,28559,28622,28681,29235,29364,29494,29497,29519,29534,29543,29716,29977,30044,30129,30130,30234,30482,30735,30836,30845,30939,30978,30988,31250,31306,31407,31447,31801,31803,31842,31850,31930,32014,32045,32054,32057,32182,32305,32308,32346,32448,32652,32745,32829,32861,32864,32895,33127,33326,33332,33480,33711,33745,33783,33824,33876,33943,34072,34303,34355,34357,34410,34490,34709,34806,34889,35067,35068,35079,35112,35117,35336,35409,35776,35872,35957,36089,36240,36450,36545,36592,36660,36729,36792,36795,36812,37103,37108,37601,37615,37919,38008,38044,38280,38495,38707,38708,38730,38776,39055,39216,39339,39645,39831,39850,39920,39974,39979,39993,40055,40105,40111,40239,40305,40327,40433,40560,40784,40899,40900,40905,40952,41032,41053,41451,41477,41635,41965,42132,42138,42268,42285,42413,42435,42556,42567,42691,42705,42708,42729,42774,43223,43258,43418,43437,43450,43552,43621,43742,43747,43873,43949,44132,44138,44185,44233,44385,44413,44544,44605,44622,44755,44885,44943,45029,45185,45197,45345,45406,45417,45478,45524,45676,45813,45947,45951,46309,46480,46895,47098,47114,47218,47241,47271,47283,47310,47340,47383,47391,47442,47476,47528,47669,47731,47736,47919,47960,47970,48044,48082,48108,48181,48198,48263,48265,48266,48391,48423,48438,48517,48518,48616,48733,48750,48778,48871,49263,49328,49342,49440,49581,49590,49623,49723,49735,49859,50015,50141,50161,50184,50185,50240,50246,50247,50267,50317,50334,50411,50493,50536,50555,50714,50761,50772,50845,50905,50922,50979,50989,51235,51510,51514,51605,51738,51773,51825,51900,51945,52009,52097,52098,52198,52262,52271,52373,52405,52425,52524,52671,52781,52885,52921,52982,53257,53301,53361,53468,53472,53563,53605,53645,53655,53672,53768,54259,54269,54355,54417,54418,54438,54508,54687,54741,54790,55065,55198,55284,55428,55462,55592,55626,55653,55694,55824,55838,55840,55841,55947,55949,56046,56092,56115,56138,56143,56147,56277,56287,56453,56608,56694,57090,57143,57596,57669,57679,57806,57994,58154,58179,58187,58493,58541,58563,58663,58905,59288,59290,59460,59578,60074,60504,60852,60897,61011,61025,61162,61305,61606,61721,61735,61768,61780,61781,61868,61870,61878,61920,62025,62042,62071,62263,62269,62277,62325,62328,62382,62478,62558,62563,62680,62697,62717,62886,62887,62973,63059,63420,63766,63996,64003,64128,64376,64382,64468,64615,64647,64690,64710,64918,64919,65089,65210,65575,65667,65745,65775,65950,66001,66069,66075,66118,66197,66359,66619,66684,66720,66928,66985,67358,67574,68189,68552,68602,68662,68799,68841,69166,69242,69410,69466,69674,69708,69767,69775,69820,69841,69852,70192,70194,70236,70262,70292,70304,70308,70338,70340,70346,70478,70503,70539,70541,70542,70744,70759,70771,70871,70986,71180,71188,71267,71278,71614,71793,71822,71857,71909,71914,71988,72132,72133,72219,72262,72293,72383,72410,72451,72679,72754,72889,73136,73326,73413,73422,73516,73541,73542,73629,73668,73682,73683,73766,73852,73910,73975,74126,74137,74152,74465,74505,74572,74634,74721,74725,74787,74797,74808,74920,74976,75147,75238,75241,75283,75321,75360,75391,75491,75687,75692,75743,75809,75861,75940,76006,76093,76096,76133,76138,76151,76253,76353,76394,76409,76475,76510,76516,76522,76535,76561,76579,76581,76679,76703,76715,76721,76729,76782,76791,76792,76794,76816,76820,76956,77080,77276,77355,77389,77487,77564,77593,77606,77611,77637,77761,77786,77851,77890,77912,77982,78023,78113,78337,78389,78830,78859,78942,78994,79024,79040,79043,79044,79046,79129,79206,79223,79318,79438,79459,79460,79462,79463,79464,79630,79780,80181,80206,80345,80353,80382,80417,80466,80564,80668,81249,81281,81302,81508,81630,82168,82219,82287,82327,82376,82518,82523,82599,82622,82661,82692,82744,82750,82759,82831,82840,82876,82935,82955,83339,83432,83523,83570,83603,83611,83663,83710,83903,83908,84030,84277,84305,84472,84528,84563,84841,84850,84859,84873,84935,84956,84963,84982,85085,85141,85209,85236,85244,85294,85354,85361,85524,85555,85557,85673,85696,85713,85733,85790,86064,86075,86137,86282,86327,86334,86346,86394,86425,86426,86569,86572,86575,86585,86620,86686,86801,86816,86911,86994,87221,87224,87427,87489,87629,87691,87701,87761,87780,87901,87904,87913,87931,88050,88065,88175,88178,88186,88232,88393,88468,88537,88625,88684,88688,88771,88814,88836,88876,88914,88942,88954,89022,89084,89091,89131,89209,89261,89267,89354,89769,89824,89826,89905,90685,90889,90895,90953,90996,91082,91138,91184,91196,91302,91320,91711,91751,91955,92023,92069,92094,92100,92121,92122,92123,92126,92188,92215,92365,92441,92796,92895,93057,93059,93369,93392,93530,93553,93578,93610,93697,93715,93720,93768,93777,93780,93786,93789,93793,93985,94593,95228,95281,95282,95376,95413,95712,95872,95898,96092,96136,96201,96263,96326,96332,96423,96459,96530,96559,96592,96710,96773,96834,96861,96913,97226,97369,97380,97676,97679,97728,97903,97997,98000,98015,98078,98170,98306,98312,98313,98450,98508,98584,98610,98612,98818,98826,98829,98928,98948,99071,99274,99317,99353,99391,99399,99461,99503,99627,99646,99732,99744,99844,99916,99952,99990,99991,100200,100249,100298,100398,100864,101028,101227,101401,101411,101412,101498,101570,101583,101602,101655,101679,101734,101842,101860,101873,102131,102149,102183,102187,102259,102341,102848,102916,103004,103023,103151,103178,103252,103651,103777,103785,103913,103946,103969,104031,104528,104537,104998,105013,105033,105215,105248,105249,105335,105445,105841,105984,106080,106368,106385,106415,106444,106791,107513,107629,107801,107965,107973,108101,108374,108799,109016,109075,109232,109333,109527,109684,109756,109924, 0 };
//	static uint32 CastList[] = { 17,25,43,47,122,126,139,246,269,324,339,433,498,543,586,605,642,676,700,710,745,746,755,804,871,974,1022,1044,1098,1130,1234,1463,1515,1604,1706,1714,1719,1776,1784,1850,2691,2825,2969,3105,3120,3143,3149,3260,3263,3288,3355,3385,3389,3650,3674,3714,4064,4134,4159,4307,4321,4339,4340,4504,4505,4929,4941,5024,5217,5246,5276,5384,5416,5514,5545,5570,5810,6114,6136,6271,6358,6422,6431,6533,6615,6685,6714,6758,6767,6770,6866,6902,6942,6945,6965,6982,7068,7081,7084,7267,7278,7295,7383,7448,7585,7742,7743,7812,7923,8185,8225,8278,8326,8553,8554,8672,8892,8909,8988,9084,9484,9487,9632,9769,9806,9906,9991,10060,10235,10255,10348,10737,10831,11011,11014,11020,11426,11445,11820,11826,12040,12042,12043,12134,12187,12292,12472,12484,12565,13139,13466,13530,13750,13913,14110,14177,14267,14268,14751,14775,15282,15407,15529,15822,16007,16048,16104,16136,16245,16257,16451,16552,16592,16712,16714,16723,17008,17131,17250,17293,17327,17506,17633,17715,17743,17775,18099,18223,18400,18795,18800,18951,19263,19307,19574,20000,20050,20066,20223,20230,20367,20368,20369,20371,20372,20373,20374,20436,20475,20594,20925,21098,21118,21862,21992,22067,22093,22289,22291,22438,22518,22570,22576,22578,22579,22580,22581,22651,22682,22690,22812,22822,22969,22987,22992,23097,23116,23131,23132,23154,23170,23179,23333,23335,23577,23601,23618,23642,23920,24203,24223,24263,24265,24300,24306,24313,24314,24324,24390,24594,24742,24778,24910,24919,24924,24926,24984,25029,25046,25160,25171,25176,25185,25371,25685,25725,25745,25777,25824,25937,26000,26009,26036,26064,26083,26102,26235,26332,26388,26547,26552,26869,27177,27183,27192,27193,27194,27195,27196,27197,27198,27199,27200,27243,27293,27568,27571,27573,27619,27731,27765,27819,28126,28134,28146,28330,28410,28434,28451,28522,28542,28605,28785,28786,28995,29042,29061,29152,29516,29519,29535,29538,29880,29942,29952,29991,30037,30108,30127,30130,30206,30231,30254,30271,30397,30398,30400,30401,30402,30403,30427,30452,30466,30467,30468,30487,30695,30735,30787,30857,30858,30888,30914,30939,30972,30987,31256,31260,31272,31309,31326,31332,31376,31537,31626,31690,31704,31719,31802,31821,31842,31951,31954,32045,32182,32236,32264,32332,32358,32423,32563,32566,32567,32570,32582,32651,32724,32725,32839,32840,32849,32859,32861,32863,32913,32936,32948,32958,33054,33206,33299,33341,33342,33343,33344,33345,33395,33409,33410,33422,33569,33763,33786,33810,33827,33900,33918,33965,34062,34072,34126,34223,34224,34225,34226,34228,34355,34375,34380,34381,34398,34399,34401,34402,34403,34404,34424,34511,34550,34551,34619,34648,34670,34750,34770,34788,34932,34976,35117,35150,35158,35159,35194,35244,35265,35367,35380,35409,35411,35440,35465,35468,35471,35504,35571,35596,35681,35720,35766,35774,35775,35841,35847,35848,35850,35919,35921,35923,35926,35929,35994,35996,35999,36006,36051,36055,36089,36090,36113,36114,36151,36169,36178,36185,36187,36193,36225,36241,36274,36296,36310,36329,36364,36370,36371,36378,36384,36393,36440,36474,36522,36542,36545,36568,36575,36622,36649,36661,36719,36725,36727,36730,36785,36790,36792,36800,36806,36812,36815,36817,36860,36871,36900,36901,36924,36952,36978,37112,37121,37136,37200,37204,37205,37206,37248,37284,37364,37429,37509,37601,37613,37713,37746,37749,37761,37797,37801,37825,37830,37850,37851,38014,38169,38177,38182,38246,38280,38376,38442,38446,38449,38457,38464,38495,38497,38577,38594,38690,38695,38719,38736,38751,38774,38793,38857,38909,39102,39143,39168,39169,39199,39205,39277,39278,39283,39294,39300,39303,39339,39343,39380,39488,39551,39565,39579,39594,39650,39656,39833,39837,39850,39872,39908,39918,39919,39936,39938,39939,39940,39943,39944,39946,39947,39952,39966,39978,39979,40017,40029,40055,40075,40094,40131,40140,40148,40159,40280,40307,40335,40396,40398,40401,40433,40447,40510,40511,40570,40610,40647,40656,40684,40685,40704,40714,40732,40778,40836,40846,40858,40900,40905,40929,40931,40932,40952,40974,41095,41218,41220,41233,41291,41292,41303,41332,41335,41336,41337,41350,41365,41376,41431,41451,41519,41535,41569,41583,41615,41917,42047,42048,42049,42050,42051,42074,42075,42145,42177,42280,42290,42294,42336,42344,42345,42346,42355,42380,42402,42413,42427,42438,42460,42466,42469,42470,42479,42525,42533,42547,42548,42549,42554,42556,42571,42575,42586,42610,42621,42629,42656,42685,42695,42696,42704,42709,42726,42783,42811,42823,42857,42862,42912,42919,42971,42994,43076,43085,43092,43113,43114,43120,43129,43141,43158,43161,43184,43202,43242,43269,43312,43313,43327,43355,43395,43421,43446,43452,43457,43463,43489,43531,43570,43648,43700,43790,43817,43819,43823,43828,43831,43866,43870,43873,43874,43905,43949,43958,43963,44010,44016,44021,44025,44107,44125,44138,44140,44145,44185,44233,44249,44253,44263,44284,44291,44303,44307,44320,44335,44347,44411,44432,44434,44451,44457,44482,44498,44572,44599,44752,44754,44772,44773,44774,44778,44784,44785,44786,44792,44795,44814,44829,44837,44844,44872,44873,44880,44883,44885,44933,44963,44994,45027,45123,45182,45197,45212,45213,45275,45319,45325,45350,45352,45399,45406,45411,45415,45416,45417,45418,45427,45442,45444,45455,45457,45495,45524,45582,45602,45609,45641,45658,45661,45665,45727,45771,45775,45787,45791,45797,45799,45800,45814,45832,45855,45857,45866,45873,45934,45944,45948,45977,45984,45987,45995,45999,46011,46145,46172,46196,46221,46228,46235,46247,46262,46265,46288,46308,46309,46314,46327,46339,46367,46410,46423,46439,46458,46593,46620,46679,46685,46695,46708,46736,46737,46738,46739,46740,46765,46767,46769,46786,46789,46796,46804,46819,46821,46822,46828,46882,46901,46907,46924,46928,46933,46934,46940,46946,46967,47032,47035,47057,47127,47128,47169,47172,47190,47218,47271,47273,47281,47299,47329,47331,47335,47340,47379,47380,47407,47411,47442,47452,47463,47521,47534,47542,47591,47651,47669,47679,47702,47704,47705,47706,47711,47712,47713,47722,47753,47756,47759,47760,47788,47840,47848,47854,47972,47976,48019,48030,48032,48033,48044,48045,48141,48143,48154,48185,48198,48200,48232,48278,48294,48307,48308,48325,48332,48380,48385,48387,48454,48456,48460,48471,48505,48522,48585,48596,48616,48677,48685,48695,48707,48708,48712,48720,48792,48795,48889,48890,48891,48892,48918,48930,49007,49016,49025,49039,49063,49117,49132,49135,49163,49170,49263,49310,49311,49326,49333,49334,49337,49364,49384,49389,49553,49590,49592,49620,49726,49733,49735,49738,49750,49753,49820,49822,49838,49842,49864,49945,49946,49947,50011,50015,50045,50057,50093,50101,50161,50184,50185,50200,50201,50216,50228,50236,50242,50246,50247,50253,50258,50269,50280,50312,50344,50381,50389,50432,50438,50442,50493,50494,50503,50506,50532,50536,50544,50549,50552,50555,50589,50597,50626,50650,50651,50713,50726,50727,50750,50756,50771,50777,50795,50844,50845,50981,50989,50993,51000,51012,51019,51121,51124,51126,51136,51168,51170,51193,51194,51195,51201,51241,51248,51271,51282,51283,51319,51339,51354,51358,51394,51405,51413,51439,51444,51461,51512,51516,51553,51584,51589,51602,51605,51619,51693,51713,51715,51721,51722,51738,51750,51763,51766,51807,51825,51845,51892,51939,51945,51946,51959,52006,52086,52101,52102,52148,52149,52151,52168,52179,52185,52188,52198,52219,52222,52231,52243,52249,52255,52274,52278,52279,52287,52303,52340,52373,52393,52406,52425,52457,52495,52524,52550,52574,52614,52617,52618,52619,52625,52627,52634,52670,52679,52696,52698,52742,52781,52792,52822,52841,52855,52878,52948,52952,52972,53019,53104,53111,53143,53160,53166,53177,53315,53371,53400,53426,53444,53455,53463,53467,53472,53500,53539,53611,53640,53642,53645,53658,53667,53685,53702,53797,54111,54134,54140,54142,54216,54240,54262,54263,54273,54284,54306,54309,54342,54343,54351,54357,54361,54438,54477,54512,54515,54524,54525,54584,54603,54606,54612,54678,54680,54702,54706,54717,54827,54956,54967,54990,55018,55035,55045,55066,55080,55099,55173,55221,55224,55279,55280,55350,55353,55367,55408,55424,55462,55474,55486,55504,55520,55549,55582,55591,55592,55644,55706,55731,55738,55739,55766,55788,55810,55841,55845,55852,55873,55883,55928,55949,55951,55959,55976,55989,56046,56075,56093,56100,56115,56118,56137,56152,56237,56272,56277,56393,56422,56425,56432,56494,56505,56507,56512,56572,56608,56632,56644,56681,56691,56696,56700,56705,56712,56726,56750,56756,56762,56769,56864,56914,57060,57092,57108,57143,57384,57400,57408,57428,57446,57490,57494,57515,57551,57560,57561,57613,57626,57630,57649,57679,57685,57687,57718,57764,57772,57806,57835,57836,57887,57901,57931,57932,57933,57938,58001,58016,58020,58022,58023,58026,58042,58119,58120,58292,58361,58429,58447,58493,58511,58540,58547,58627,58682,58688,58768,58806,58842,58860,58925,59037,59055,59090,59216,59236,59290,59292,59425,59447,59562,59631,59635,59641,59642,59663,59790,59838,59862,59908,59942,60044,60047,60070,60151,60161,60177,60189,60284,60289,60426,60429,60438,60451,60489,60491,60497,60509,60511,60540,60588,60642,60672,60699,60796,60817,60852,60865,60896,60897,60935,60977,61014,61023,61028,61131,61144,61162,61181,61272,61292,61296,61333,61334,61364,61366,61385,61392,61397,61398,61399,61403,61404,61405,61406,61415,61557,61573,61574,61603,61704,61722,61728,61735,61768,61769,61810,61814,61815,61833,61835,61836,61837,61838,61877,61883,61888,61902,61942,61974,62016,62019,62028,62052,62089,62148,62170,62186,62216,62269,62274,62277,62292,62310,62337,62344,62348,62374,62375,62382,62386,62398,62468,62483,62511,62538,62548,62573,62579,62594,62595,62596,62632,62639,62640,62647,62655,62696,62715,62718,62720,62756,62777,62844,62893,62894,62895,62897,62898,62914,62976,62978,62997,63018,63024,63037,63080,63084,63088,63096,63130,63131,63132,63138,63147,63276,63288,63292,63294,63295,63307,63319,63323,63339,63347,63364,63394,63395,63396,63397,63398,63399,63401,63402,63403,63404,63405,63406,63421,63422,63423,63425,63426,63427,63428,63429,63430,63431,63432,63433,63434,63435,63436,63500,63501,63512,63537,63558,63578,63606,63607,63608,63609,63665,63677,63688,63694,63710,63711,63748,63769,63771,63772,63773,63814,63894,63895,63939,63962,64017,64043,64064,64078,64100,64108,64117,64120,64128,64135,64145,64152,64163,64165,64167,64171,64173,64175,64201,64218,64229,64269,64324,64359,64361,64362,64367,64368,64384,64386,64393,64394,64396,64398,64411,64416,64421,64426,64428,64434,64435,64438,64439,64449,64458,64465,64468,64469,64479,64505,64510,64528,64561,64565,64570,64600,64615,64616,64621,64624,64625,64668,64677,64685,64705,64723,64724,64740,64774,64842,64843,64919,64920,64965,64986,65087,65210,65234,65257,65267,65348,65356,65408,65431,65432,65444,65462,65558,65582,65602,65605,65615,65617,65667,65684,65685,65686,65718,65724,65734,65739,65745,65748,65772,65798,65858,65874,65879,65882,65921,65950,65982,66001,66013,66046,66058,66069,66075,66085,66092,66110,66129,66139,66146,66179,66187,66189,66190,66195,66197,66201,66209,66211,66212,66228,66237,66252,66263,66281,66283,66296,66308,66318,66324,66360,66361,66362,66363,66364,66365,66366,66367,66368,66369,66370,66371,66484,66514,66544,66601,66602,66625,66680,66689,66725,66727,66763,66776,66798,66857,66904,66927,66928,66929,66969,66985,66987,67021,67023,67024,67112,67280,67302,67323,67409,67412,67421,67422,67423,67425,67435,67505,67534,67539,67549,67550,67574,67685,67780,67788,67791,67795,67821,67823,67829,67840,67921,67923,67924,67927,68054,68065,68077,68189,68212,68231,68256,68295,68302,68322,68327,68342,68419,68424,68436,68442,68443,68499,68507,68555,68571,68589,68613,68630,68645,68721,68779,68792,68794,68795,68854,68909,68939,68946,68980,68981,69017,69051,69056,69065,69090,69091,69105,69112,69126,69128,69133,69134,69144,69150,69151,69152,69154,69167,69172,69174,69175,69188,69191,69198,69202,69240,69277,69279,69320,69322,69324,69356,69375,69410,69413,69418,69422,69456,69483,69494,69575,69578,69609,69632,69635,69658,69663,69681,69695,69703,69705,69708,69756,69768,69776,69780,69784,69785,69809,69813,69841,69844,69859,69862,69863,69866,69871,69885,69924,70022,70038,70063,70111,70112,70126,70158,70160,70194,70199,70215,70226,70232,70236,70250,70300,70308,70338,70343,70404,70413,70423,70424,70427,70445,70447,70451,70471,70478,70491,70504,70518,70520,70535,70539,70571,70572,70573,70583,70588,70612,70623,70630,70632,70633,70638,70645,70662,70666,70667,70672,70673,70675,70692,70699,70705,70707,70714,70715,70731,70737,70744,70751,70763,70766,70781,70785,70788,70794,70842,70853,70873,70876,70877,70904,70911,70934,70952,70953,70954,70956,70959,70970,71001,71033,71064,71065,71066,71085,71087,71094,71183,71185,71200,71207,71230,71259,71267,71278,71304,71321,71329,71333,71348,71349,71355,71367,71372,71408,71409,71411,71412,71415,71419,71423,71459,71589,71597,71598,71615,71663,71706,71732,71773,71797,71856,71869,71910,71914,71939,71941,71947,71949,71986,71988,71993,71994,72044,72054,72055,72067,72072,72077,72094,72100,72112,72126,72132,72176,72250,72262,72292,72301,72305,72372,72381,72382,72385,72390,72398,72405,72424,72451,72521,72522,72523,72525,72534,72546,72572,72602,72628,72630,72679,72692,72697,72711,72712,72729,72743,72754,72769,72880,72885,72915,72935,72942,72975,72985,72999,73005,73021,73078,73080,73116,73119,73149,73151,73158,73169,73191,73192,73199,73220,73282,73285,73286,73294,73304,73305,73326,73422,73424,73443,73448,73450,73457,73481,73482,73490,73493,73511,73512,73525,73530,73541,73558,73559,73563,73572,73600,73619,73628,73649,73651,73658,73677,73682,73683,73685,73695,73699,73721,73852,73865,73874,73876,73884,73898,73901,73907,73918,73926,73948,73958,73973,73975,74001,74044,74060,74066,74079,74081,74109,74126,74133,74149,74177,74233,74265,74266,74269,74289,74298,74344,74356,74369,74375,74380,74385,74386,74416,74417,74428,74429,74434,74446,74453,74458,74494,74502,74505,74532,74543,74563,74568,74621,74629,74633,74634,74641,74662,74676,74699,74713,74767,74780,74787,74788,74792,74797,74803,74835,74842,74847,74866,74867,74869,74883,74884,74908,74915,74917,74930,74938,74971,74976,75013,75016,75022,75041,75054,75055,75056,75098,75099,75104,75110,75116,75122,75124,75148,75153,75210,75214,75219,75220,75222,75223,75228,75229,75230,75238,75272,75280,75311,75318,75322,75328,75342,75379,75391,75463,75497,75498,75520,75530,75537,75546,75554,75590,75592,75599,75602,75603,75608,75609,75624,75627,75632,75643,75664,75666,75678,75685,75693,75694,75697,75698,75699,75701,75702,75718,75730,75751,75755,75779,75792,75809,75817,75822,75824,75834,75850,75861,75864,75908,75916,75938,75989,75992,76004,76006,76017,76020,76026,76029,76031,76036,76040,76048,76066,76084,76086,76093,76094,76095,76097,76117,76119,76133,76138,76151,76165,76183,76184,76190,76192,76201,76221,76222,76231,76232,76233,76256,76274,76307,76321,76332,76340,76345,76347,76349,76350,76352,76354,76355,76356,76357,76367,76371,76386,76394,76403,76406,76410,76411,76415,76419,76420,76460,76514,76531,76534,76541,76543,76579,76581,76590,76596,76625,76634,76679,76681,76692,76701,76711,76714,76715,76721,76743,76750,76766,76770,76772,76780,76784,76785,76788,76790,76792,76816,76848,76865,76868,76877,76880,76891,76894,76903,76912,76952,76959,76973,76993,76995,77012,77026,77044,77053,77064,77070,77081,77085,77137,77211,77217,77227,77236,77238,77276,77279,77286,77311,77317,77321,77333,77348,77350,77362,77367,77368,77375,77383,77388,77392,77409,77455,77457,77458,77463,77487,77490,77497,77502,77517,77523,77559,77564,77578,77579,77586,77587,77589,77637,77642,77643,77653,77674,77676,77677,77678,77699,77707,77709,77712,77717,77742,77758,77760,77770,77775,77786,77807,77809,77814,77816,77831,77840,77850,77851,77854,77855,77884,77885,77904,77907,77909,77910,77911,77912,77929,77940,77970,77989,78012,78017,78018,78019,78023,78037,78047,78087,78090,78095,78120,78122,78125,78193,78199,78201,78205,78211,78216,78221,78224,78225,78274,78276,78337,78343,78344,78349,78351,78357,78389,78403,78466,78515,78541,78552,78604,78619,78666,78677,78681,78686,78691,78697,78698,78699,78700,78701,78715,78726,78729,78732,78768,78774,78779,78783,78843,78844,78850,78851,78853,78855,78860,78865,78874,78895,78896,78897,78900,78905,78911,78913,78935,78939,78941,78942,78969,78973,78986,79002,79009,79036,79050,79109,79116,79129,79130,79139,79140,79143,79155,79157,79158,79161,79163,79167,79192,79202,79206,79212,79228,79235,79236,79244,79245,79252,79253,79318,79325,79330,79331,79344,79351,79359,79366,79367,79371,79372,79373,79391,79396,79428,79430,79438,79447,79451,79459,79460,79462,79463,79464,79501,79520,79532,79536,79537,79553,79582,79587,79628,79676,79678,79690,79702,79720,79725,79729,79735,79750,79752,79754,79756,79764,79769,79770,79796,79827,79832,79835,79836,79837,79900,79919,80011,80095,80101,80108,80109,80126,80132,80145,80147,80151,80158,80160,80162,80172,80175,80198,80209,80210,80218,80266,80274,80325,80326,80334,80336,80338,80341,80352,80353,80381,80394,80406,80409,80417,80523,80524,80545,80569,80584,80599,80611,80612,80627,80631,80642,80653,80656,80664,80668,80673,80676,80681,80718,80727,80733,80736,80749,80761,80794,80798,80800,80802,80805,80837,80838,80855,80857,80895,80919,80928,80942,80945,80958,80959,81025,81041,81058,81065,81081,81083,81084,81086,81095,81153,81154,81172,81178,81183,81184,81193,81194,81196,81204,81206,81208,81209,81214,81217,81220,81221,81223,81234,81237,81245,81247,81250,81271,81349,81352,81372,81373,81509,81536,81555,81559,81566,81572,81573,81629,81642,81679,81690,81700,81703,81712,81718,81719,81721,81723,81726,81727,81728,81729,81731,81732,81733,81734,81735,81736,81737,81738,81739,81740,81741,81752,81754,81757,81771,81777,81793,81810,81829,81836,81874,81875,81940,81944,81945,81947,81952,81959,81961,82020,82023,82028,82139,82167,82170,82185,82192,82197,82219,82255,82259,82295,82299,82320,82327,82334,82356,82360,82383,82397,82403,82411,82415,82426,82436,82452,82454,82458,82527,82531,82571,82612,82614,82620,82622,82630,82631,82665,82702,82706,82724,82727,82740,82745,82753,82771,82786,82788,82790,82835,82840,82843,82847,82851,82853,82855,82866,82872,82888,82890,82914,82934,82951,82953,82954,82971,82983,83010,83048,83056,83072,83076,83079,83097,83099,83110,83117,83127,83170,83234,83237,83238,83339,83412,83413,83432,83463,83464,83472,83480,83500,83503,83525,83579,83601,83607,83610,83611,83615,83662,83663,83693,83697,83698,83699,83702,83718,83729,83740,83741,83742,83743,83744,83745,83746,83780,83800,83829,83830,83831,83832,83842,83847,83853,83864,83867,83908,83929,83952,83956,83970,83977,83984,84030,84062,84063,84070,84072,84092,84100,84115,84119,84120,84146,84161,84167,84186,84188,84216,84230,84232,84234,84245,84249,84296,84299,84306,84355,84386,84388,84401,84462,84497,84498,84516,84528,84536,84538,84552,84557,84558,84563,84567,84568,84589,84594,84596,84597,84599,84616,84623,84660,84689,84692,84702,84744,84784,84823,84834,84841,84850,84856,84860,84862,84878,84880,84910,84911,84914,84935,84948,84949,84953,84954,84961,84974,84982,85003,85021,85051,85084,85141,85170,85174,85193,85196,85229,85230,85231,85236,85246,85252,85253,85267,85269,85273,85281,85290,85292,85316,85323,85350,85352,85365,85373,85390,85401,85408,85412,85428,85454,85456,85467,85469,85480,85500,85502,85507,85521,85523,85524,85525,85526,85530,85532,85535,85537,85538,85556,85560,85561,85564,85573,85575,85576,85578,85610,85630,85632,85633,85643,85654,85684,85695,85696,85697,85701,85704,85707,85708,85709,85711,85713,85719,85721,85731,85733,85734,85740,85745,85771,85790,85799,85838,85842,85851,85875,85886,86003,86022,86067,86075,86077,86080,86107,86131,86134,86135,86137,86180,86194,86208,86210,86255,86256,86257,86267,86291,86292,86302,86308,86310,86332,86348,86366,86370,86376,86378,86383,86393,86400,86407,86409,86413,86414,86425,86426,86432,86453,86483,86489,86506,86540,86559,86566,86572,86581,86585,86591,86600,86603,86622,86724,86780,86785,86788,86794,86801,86808,86819,86838,86853,86911,86938,86981,86985,86994,87005,87016,87032,87033,87048,87093,87097,87153,87169,87177,87199,87206,87211,87214,87220,87221,87227,87234,87251,87252,87256,87259,87266,87268,87299,87315,87322,87323,87380,87391,87405,87427,87443,87457,87458,87469,87488,87508,87519,87524,87617,87621,87629,87631,87640,87645,87652,87654,87657,87658,87659,87685,87698,87701,87703,87713,87762,87769,87780,87796,87803,87808,87815,87817,87818,87859,87861,87862,87875,87903,87913,87931,87932,87949,87955,87966,87969,87972,87973,87992,87996,88009,88027,88038,88043,88055,88059,88062,88069,88070,88133,88154,88164,88165,88175,88178,88183,88185,88186,88198,88201,88204,88207,88210,88219,88221,88223,88225,88231,88237,88247,88253,88277,88282,88305,88313,88319,88320,88330,88348,88352,88373,88425,88427,88435,88451,88454,88455,88458,88476,88481,88483,88485,88486,88497,88500,88508,88518,88522,88545,88561,88567,88579,88602,88604,88625,88636,88637,88638,88639,88640,88641,88642,88643,88644,88648,88681,88691,88729,88755,88760,88768,88770,88783,88795,88796,88806,88836,88837,88840,88860,88861,88862,88866,88872,88873,88875,88876,88895,88911,88919,88920,88921,88922,88924,88925,88931,88954,88960,88962,88978,88981,88983,88997,88999,89041,89042,89043,89044,89045,89046,89121,89131,89150,89152,89159,89186,89194,89196,89227,89242,89253,89254,89255,89256,89257,89258,89259,89260,89273,89279,89281,89284,89286,89339,89352,89353,89354,89355,89428,89436,89437,89476,89491,89510,89518,89519,89530,89542,89551,89555,89567,89574,89617,89645,89662,89666,89695,89698,89702,89703,89706,89716,89730,89733,89734,89751,89756,89773,89790,89807,89824,89833,89842,89907,89917,89924,89942,89966,89967,90028,90047,90055,90085,90087,90098,90099,90101,90106,90139,90168,90259,90263,90264,90336,90344,90347,90351,90353,90359,90360,90366,90373,90391,90393,90397,90405,90434,90440,90449,90510,90620,90621,90670,90677,90685,90698,90699,90729,90752,90764,90819,90854,90884,90909,90948,91078,91103,91111,91134,91154,91179,91277,91288,91298,91307,91331,91347,91349,91373,91390,91410,91462,91574,91600,91603,91629,91650,91686,91689,91694,91696,91707,91743,91758,91830,91844,91852,91855,91920,91935,91946,91979,92023,92048,92092,92109,92110,92115,92120,92128,92131,92143,92211,92215,92230,92240,92249,92263,92277,92282,92304,92335,92372,92373,92399,92406,92426,92707,92710,92716,92717,92718,92719,92737,92788,92792,92813,92850,92871,92888,92895,92902,92906,92964,93010,93051,93059,93083,93090,93101,93230,93237,93244,93276,93311,93314,93318,93335,93336,93338,93340,93346,93361,93393,93394,93423,93429,93433,93451,93473,93479,93484,93502,93503,93530,93561,93572,93573,93578,93581,93588,93594,93597,93629,93644,93660,93689,93690,93720,93747,93751,93757,93766,93777,93779,93780,93781,93786,93788,93789,93792,93796,93835,93852,93853,93864,93946,93968,93969,93972,93975,94019,94025,94029,94048,94170,94186,94197,94208,94209,94212,94213,94217,94218,94220,94221,94225,94264,94265,94269,94271,94272,94275,94277,94278,94316,94330,94341,94365,94368,94392,94400,94423,94444,94448,94469,94479,94489,94491,94503,94524,94557,94558,94563,94588,94593,94600,94602,94610,94635,94653,94657,94659,94662,94712,94733,94793,94831,94833,94839,94941,94956,94980,95014,95034,95047,95169,95205,95217,95229,95230,95250,95276,95293,95296,95298,95299,95366,95372,95390,95413,95432,95437,95442,95447,95448,95470,95475,95479,95480,95513,95514,95519,95527,95542,95663,95760,95762,95791,95823,95824,95843,95913,95914,95918,95920,95957,95959,96028,96040,96041,96042,96093,96096,96132,96181,96194,96195,96277,96280,96293,96303,96325,96342,96353,96369,96423,96431,96432,96441,96446,96449,96466,96493,96495,96498,96500,96506,96507,96512,96520,96524,96527,96529,96530,96532,96533,96534,96536,96537,96568,96572,96592,96642,96653,96661,96665,96678,96681,96694,96697,96720,96722,96727,96729,96739,96759,96769,96776,96793,96798,96807,96822,96831,96840,96847,96850,96851,96853,96861,96867,96868,96869,96882,96884,96885,96912,96913,96916,96919,96936,96937,96942,96969,96974,96982,96986,96989,96994,96995,97002,97014,97016,97022,97026,97030,97031,97033,97034,97035,97054,97055,97056,97057,97058,97059,97061,97062,97063,97079,97081,97088,97091,97095,97096,97097,97107,97108,97109,97111,97112,97113,97115,97116,97122,97124,97128,97133,97134,97144,97147,97149,97150,97159,97162,97163,97165,97166,97167,97169,97172,97178,97180,97182,97186,97196,97202,97203,97207,97213,97225,97237,97248,97250,97280,97285,97307,97322,97332,97343,97344,97345,97346,97360,97377,97397,97407,97408,97417,97428,97459,97502,97503,97515,97535,97539,97546,97549,97556,97565,97571,97572,97577,97586,97589,97597,97598,97607,97608,97625,97626,97664,97676,97699,97706,97708,97732,97750,97801,97835,97903,97921,97944,97959,97960,97966,97968,97977,97978,97987,97991,98006,98015,98017,98018,98030,98059,98078,98092,98094,98109,98141,98149,98163,98173,98179,98189,98194,98196,98208,98233,98242,98245,98250,98264,98265,98271,98292,98296,98313,98319,98320,98321,98325,98326,98327,98329,98336,98338,98345,98360,98378,98381,98383,98391,98403,98404,98444,98445,98450,98462,98481,98499,98519,98520,98525,98527,98534,98543,98545,98554,98566,98570,98579,98583,98591,98593,98600,98602,98604,98609,98611,98617,98619,98621,98622,98624,98625,98627,98638,98658,98659,98673,98691,98702,98712,98717,98722,98723,98763,98814,98835,98853,98858,98860,98871,98873,98884,98891,98895,98910,98912,98924,98928,98955,98975,98982,98983,98985,98998,99005,99020,99048,99068,99071,99072,99099,99106,99111,99113,99122,99126,99128,99176,99185,99199,99215,99216,99225,99247,99254,99258,99264,99265,99276,99295,99296,99304,99308,99324,99327,99361,99365,99380,99384,99385,99392,99394,99399,99406,99414,99426,99430,99432,99434,99461,99462,99476,99480,99483,99490,99491,99494,99503,99507,99519,99556,99561,99564,99585,99586,99587,99590,99593,99598,99604,99605,99617,99620,99628,99630,99632,99646,99651,99666,99669,99681,99709,99732,99734,99738,99756,99793,99795,99796,99797,99800,99812,99817,99843,99849,99870,99919,99927,99941,99946,99953,99984,99994,99997,100005,100026,100029,100059,100093,100102,100136,100144,100165,100192,100233,100241,100249,100263,100276,100312,100315,100320,100321,100326,100331,100343,100345,100397,100403,100456,100477,100478,100480,100490,100494,100503,100507,100528,100535,100556,100557,100567,100589,100590,100591,100592,100603,100607,100608,100610,100632,100641,100647,100653,100658,100671,100686,100703,100712,100713,100742,100746,100758,100797,100803,100815,100816,100858,100865,100867,100907,100951,100960,101013,101020,101032,101037,101053,101059,101087,101090,101093,101109,101112,101116,101127,101134,101146,101160,101161,101180,101183,101187,101284,101302,101309,101314,101338,101357,101378,101385,101394,101412,101413,101422,101486,101496,101498,101499,101511,101515,101525,101529,101552,101582,101584,101588,101591,101594,101601,101602,101612,101624,101651,101652,101654,101656,101667,101696,101732,101734,101736,101738,101806,101836,101841,101842,101856,101860,101864,101866,101871,101891,101905,101907,101913,101946,101984,102045,102054,102057,102058,102116,102128,102129,102134,102146,102158,102182,102206,102226,102240,102248,102249,102259,102279,102295,102310,102312,102341,102364,102386,102408,102415,102426,102456,102457,102460,102463,102479,102534,102569,102581,102582,102602,102603,102629,102726,102797,102845,102848,102915,102918,102919,102951,102984,102994,102995,103004,103013,103018,103087,103151,103320,103363,103400,103419,103494,103534,103536,103541,103578,103591,103598,103644,103654,103678,103688,103704,103714,103723,103744,103755,103756,103762,103769,103774,103780,103813,103913,103917,103932,103946,103952,103962,103966,103984,104038,104040,104177,104180,104268,104516,104534,104648,104726,104819,104823,104905,104936,104939,104945,104953,104995,104998,105008,105013,105018,105041,105046,105066,105067,105072,105074,105119,105143,105192,105201,105202,105210,105211,105212,105216,105223,105239,105249,105256,105265,105269,105285,105311,105335,105336,105340,105343,105344,105353,105367,105369,105409,105422,105442,105460,105462,105473,105474,105475,105476,105477,105478,105479,105487,105490,105493,105505,105510,105521,105526,105527,105530,105543,105547,105562,105563,105565,105600,105601,105603,105634,105731,105738,105760,105766,105830,105831,105834,105841,105859,105896,105900,105903,105904,105924,105927,105929,105984,106005,106027,106029,106067,106080,106108,106187,106213,106224,106242,106273,106283,106400,106415,106457,106466,106498,106509,106510,106511,106512,106538,106548,106567,106588,106600,106613,106624,106663,106664,106678,106708,106794,106814,106834,107082,107629,107668,107751,107797,107799,107927,107965,108035,108053,108101,108160,108161,108162,108163,108164,108203,108214,108221,108227,108268,108530,108531,108544,108642,108759,108780,108781,108809,108841,109075,109122,109180,109187,109295,109325,109352,109361,109365,109368,109413,109414,109540,109546,109654,109670,109671,109684,109731,109756,109765,109906,109912,109920,109921,109923,109935,109936,109940,109949,109971,109981,110005,110048,110054,110062,110082,110214,110468,110469,110489,110628,110649,110656,110794,0 };
//	static uint32 CastList[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,263,264,265,266,283,284,285,286,287,288,289,290,291,292,303,323,324,325,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,383,384,385,386,387,388,389,403,404,405,406,407,408,409,410,411,412,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,463,464,483,484,503,504,523,524,525,543,563,564,583,584,585,586,587,588,589,590,591,592,603,623,624,625,626,627,643,663,664,683,684,703,704,705,706,723,724,743,744,763,783,803,804,805,823,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,863,864,865,866,883,884,903,904,905,906,907,908,909,910,911,912,913,923,924,925,926,927,928,929,930,931,943,963,983,1003,1023,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1183,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1483,1503,1504,1505,1506,1507,1508,1509,1510,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1543,1563,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1643,1663,1664,1665,1666,1667,1668,1669,1683,1703,1704,1723,1743,1763,1783,1803,1823,1824,1825,1843,1863,1864,1865,1866,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1903,1904,1923,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149,2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199,2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249,2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299,2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399,2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2443,2463,2483,2484,2485,2486,2487,2488,2503,2504,2505,2506,2523,2543,2544,2545,2563,2564,2565,2566,2567,2568,2583,2584,2585,2586,2587,2588,2589,2590,2591,2603,2604,2605,2606,2607,2608,2609,2610,2611,2612,2613,2614,2615,2616,2617,2618,2619,2620,2621,2622,2623,2624,2625,2626,2627,2628,2629,2630,2631,2632,2633,2634,2635,2636,2637,2638,2639,2640,2641,2642,2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,2691,2692,2693,2694,2695,2696,2697,2698,2699,2700,2701,2702,2703,2704,2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,2721,2722,2723,2724,2725,2726,2727,2728,2729,2730,2731,2732,2733,2734,2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,2751,2752,2753,2754,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,2766,2767,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,2780,2781,2782,2783,2784,2785,2786,2787,2788,2789,2790,2791,2792,2793,2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,2810,2811,2812,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,2857,2858,2859,2860,2861,2862,2863,2864,2865,2866,2867,2868,2869,2870,2871,2872,2873,2874,2875,2876,2877,2878,2879,2880,2881,2882,2883,2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,2900,2901,2902,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,2916,2917,2918,2919,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,2944,2945,2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,2962,2963,2964,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014,3015,3016,3017,3018,3019,3020,3021,3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,3051,3052,3053,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,3067,3068,3069,3070,3071,3072,3073,3074,3075,3076,3077,3078,3079,3080,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,3109,3110,3111,3112,3113,3114,3115,3116,3117,3118,3119,3120,3121,3122,3123,3124,3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,3157,3158,3159,3160,3161,3162,3163,3164,3197,3198,3199,3200,3201,3202,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,3234,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3324,3325,3326,3327,3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,3360,3361,3362,3363,3364,3365,3366,3367,3368,3369,3370,3371,3374,3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,3388,3389,3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,3406,3407,3408,3409,3410,3411,3412,3413,3414,3415,3416,3417,3418,3419,3420,3421,3422,3423,3424,3426,3427,3428,3429,3430,3431,3432,3433,3434,3435,3436,3437,3438,3439,3440,3441,3442,3443,3444,3445,3446,3447,3448,3449,3450,3451,3452,3453,3454,3455,3456,3457,3458,3459,3460,3461,3462,3463,3464,3465,3466,3467,3468,3469,3470,3471,3472,3473,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,3487,3488,3489,3490,3491,3492,3493,3494,3495,3496,3497,3498,3499,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,3512,3513,3514,3515,3516,3517,3518,3519,3520,3521,3522,3523,3524,3525,3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,3558,3559,3560,3561,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,3574,3575,3576,3577,3578,3579,3580,3581,3582,3583,3584,3585,3586,3587,3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3599,3600,3601,3602,3603,3604,3605,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3630,3631,3632,3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3646,3647,3648,3649,3650,3651,3652,3653,3654,3655,3656,3657,3658,3659,3660,3661,3662,3663,3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,3696,3697,3698,3699,3700,3701,3702,3703,3704,3705,3706,3707,3708,3709,3710,3711,3712,3713,3714,3715,3716,3717,3718,3719,3720,3721,3722,3723,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,3739,3740,3741,3742,3743,3744,3745,3746,3747,3748,3749,3750,3751,3752,3753,3754,3755,3756,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,3767,3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,3779,3780,3781,3782,3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,3796,3797,3798,3799,3800,3801,3802,3803,3804,3805,3806,3807,3808,3809,3810,3811,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,3822,3823,3824,3825,3826,3827,3828,3829,3830,3831,3832,3833,3834,3835,3836,3837,3838,3839,3840,3841,3842,3843,3844,3845,3846,3847,3848,3849,3850,3851,3852,3853,3854,3855,3856,3857,3858,3859,3860,3861,3862,3863,3864,3865,3866,3867,3868,3869,3870,3871,3872,3873,3874,3875,3876,3877,3879,3880,3881,3882,3883,3884,3885,3886,3887,3888,3889,3890,3891,3892,3893,3894,3895,3896,3897,3898,3899,3900,3901,3902,3903,3904,3905,3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,3922,3923,3924,3925,3926,3927,3928,3929,3930,3931,3932,3933,3936,3937,3938,3939,3940,3941,3942,3943,3944,3945,3946,3947,3948,3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,3965,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,3978,3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,3992,3993,3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,4024,4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,4056,4057,4058,4059,4060,4061,4062,4063,4064,4065,4066,4067,4068,4069,4070,4071,4072,4073,4074,4075,4076,4077,4078,4079,4080,4081,4082,4083,4084,4085,4086,4087,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,4109,4110,4111,4112,4113,4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,4125,4126,4127,4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,4138,4139,4140,4141,4142,4143,4144,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,4206,4207,4208,4209,4211,4212,4213,4214,4215,4216,4217,4221,4222,4223,4225,4227,4236,4237,4238,4239,4244,4245,4246,4247,4248,4249,4250,4251,4252,4253,4256,4257,4258,4259,4262,4263,4264,4265,4266,4267,4270,0 };
	static uint32 CastList[] = { 2,3,6,7,12,25,26,255,283,425,723,803,1023,1103,1894,1899,2343,2443,2563,2671,2672,2673,2674,2675,3225,3239,3273,3322,3345,3869,3870,3883,4066,4067,4074,4097,4098,4099,0 };
								 
//	static uint32 CastList[] = { 0 };

	if( ParamCount <= 0 )
	{
		plr->BroadcastMessage( "Usage : cmd [SpellId]");
		plr->BroadcastMessage( "Ex : castnextspell 0 -> will cast next spell");
	}
	else if( ParamCount == 1 &&  Param <= 0 )
	{
		uint32 CurId;
		if( Param == 0 )
		{
			int64 *index = plr->GetCreateIn64Extension( EXTENSION_ID_CAST_SEQ_INDEX );
			uint32 PrevId = CastList[ *index ];
			plr->RemoveAura( PrevId, 0, AURA_SEARCH_ALL, MAX_AURAS );
			*index = *index + 1;
			CurId = CastList[ *index ];
			if( CurId == 0 )
			{
				*index = 0;
				return true;
			}
			plr->BroadcastMessage( "Casting Spell %d at index %d", CurId, *index );
		}
		else
			CurId = -Param;

/*		{
			SpellEntry *spe = dbcSpell.LookupEntryForced( CurId );
			Spell *sp = SpellPool.PooledNew( __FILE__, __LINE__ );
			sp->Init( plr, spe, true, NULL);
			SpellCastTargets tgt( plr->GetGUID() );
			tgt.m_unitTarget = plr->GetGUID();
			sp->m_targetUnits[0].push_back( plr->GetGUID() );
			sp->m_targetUnits[1].push_back( plr->GetGUID() );
			sp->m_targetUnits[2].push_back( plr->GetGUID() );
			//!!!!!eeeeek, we are only debugging !
			spe->ForcedAuraVisibleFlags |= VISUALAURA_FLAG_SEND_VALUES | VISUALAURA_FLAG_VISIBLE_1 | VISUALAURA_FLAG_VISIBLE_2 | VISUALAURA_FLAG_VISIBLE_3;
			sp->forced_duration = 30000;
			sp->prepare(&tgt);
		}/**/
		{
			plr->SetUInt32Value( PLAYER_VISIBLE_ITEM_16_ENCHANTMENT, CurId );
		}/**/
	}
	else if( ParamCount == 1 )
	{
		int64 *index = plr->GetCreateIn64Extension( EXTENSION_ID_CAST_SEQ_INDEX );
		for( uint32 i=0;i<1500 && CastList[i] != 0 && CastList[i] != Param; i++ )
			*index = i;
		plr->BroadcastMessage( "Restarted cast sequance to spell %d at index %d", Param, *index );
	}

	return true;
}

bool ChatHandler::HandleLearnSkillineCommand(const char* args, WorldSession *m_session)
{
	if (!*args)
		return false;

	Player *plr = getSelectedChar(m_session, true);
	if(!plr)
	{
		plr = m_session->GetPlayer();
		SystemMessage(m_session, "Auto-targeting self.");
	}
	if(!plr) 
		return false;

	uint32 SkillLine;
	uint32 ClassSpecific;	//glyphs should be class specific

	int32 ParamCount;
	ParamCount = sscanf( args, "%d %d", &SkillLine, &ClassSpecific );

	sGMLog.writefromsession(m_session, "taught %s thought skilline %u", plr->GetName(), SkillLine );
	plr->LearnAllSpellsFromSkillLine( SkillLine, true, ClassSpecific == 1 );
	BlueSystemMessageToPlr(plr, "%s taught you skilline %d", m_session->GetPlayer()->GetName(), SkillLine );
	return true;
}

bool ChatHandler::HandleLearnCommand(const char* args, WorldSession *m_session)
{
	if (!*args)
		return false;

	Player *plr = getSelectedChar(m_session, true);
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() )
	{
		plr = m_session->GetPlayer();
	}
#endif
	if(!plr)
	{
		plr = m_session->GetPlayer();
		SystemMessage(m_session, "Auto-targeting self.");
	}
	if(!plr) return false;

	uint32 skilline_all[ 20 ] = { 129,171,165,164,182,185,186,197,202,333,356,755,773,777,778 };
	/*uint32 skillines[ 12 ][ 20 ] = 
	{
		{0},
		{26,43,44,45,46,54,55,256,257,0}, // WARRIOR = 1
		{43,44,54,55,184,267,594,0}, // PALADIN = 2
		{43,44,45,46,50,51,55,163,0}, // HUNTER = 3
		{38,39,43,45,46,54,253,633,0}, // ROGUE = 4
		{54,56,78,613,0}, // PRIEST = 5
		{43,44,54,55,770,771,772,0}, // DEATHKNIGHT = 6
		{44,54,373,374,375,0}, // SHAMAN = 7
		{6,8,43,237,0}, // MAGE = 8
		{43,354,355,593,0}, // WARLOCK = 9
		{0}, // 10
		{54,574,134,573,0} // DRUID = 11
	};*/

	if(stricmp(args, "mounts")==0)
	{
		plr->LearnAllSpellsFromSkillLine( SKILL_MOUNTS, true, false );
		sGMLog.writefromsession(m_session, "taught %s thought all mounts", plr->GetName());
	}
	else if(stricmp(args, "pets")==0)
	{
		plr->LearnAllSpellsFromSkillLine( SKILL_COMPANIONS, true, false );
		uint32 spell = atol((char*)args);
		sGMLog.writefromsession(m_session, "taught %s thought all pets", plr->GetName());
	}
	else if(stricmp(args, "professions")==0)
	{
		for(uint32 i=0;i<20 && skilline_all[i]!=0;i++)
			plr->LearnAllSpellsFromSkillLine( skilline_all[i], true, false );
		sGMLog.writefromsession(m_session, "taught %s thought all professions.", plr->GetName());
	}
	else if(stricmp(args, "all")==0 || stricmp(args, "alldev")==0)
	{
		uint32 c = plr->getClass();
		bool skip_talents = true;
		if( stricmp(args, "alldev")==0 )
			skip_talents = false;
		//check if we have this skilline
		for(uint32 i=0;i<4 && class_skillines[c][i]!=0;i++)
			plr->LearnAllSpellsFromSkillLine( class_skillines[c][i], skip_talents, true );
		sGMLog.writefromsession(m_session, "taught %s full class spells.", plr->GetName());
	}
/*	if(stricmp(args, "all")==0)
	{
		sGMLog.writefromsession(m_session, "taught %s all spells.", plr->GetName());
		static uint32 spellarray[DRUID+1][9999] = {
			{ 0 },		// CLASS 0
			{ 71, 2458, 355, 469, 674, 676, 750, 871, 1161, 1680, 1719, 2048, 2565, 2687, 3411, 5246, 6554, 7620, 11578, 11585, 12678, 18499, 20230, 23920, 25203, 25208, 25212, 25225, 25231, 25236, 25242, 25264, 25266, 25275, 29704, 29707, 30357, 34428, 0 },		// CLASS 1
			{ 750, 1020, 1038, 1044, 1152, 3127, 4987, 5502, 5573, 7620, 10278, 10308, 10322, 10324, 10326, 19746, 19752, 20271, 20347, 20348, 20356, 20772, 20773, 25780, 25895, 25898, 27136, 27137, 27138, 27139, 27140, 27141, 27142, 27143, 27144, 27145, 27148, 27149, 27150, 27151, 27152, 27153, 27154, 27155, 27158, 27169, 27173, 27180, 31789, 31801, 31884, 31895, 32223, 33388, 33391, 33776, 34090, 34091, 0 },		// CLASS 2
			{ 136, 674, 781, 883, 982, 1002, 1130, 1462, 1494, 1495, 1499, 1510, 1513, 1515, 1543, 1978, 2641, 2643, 2974, 3018, 3034, 3043, 3044, 3045, 3111, 3127, 3661, 3662, 5116, 5118, 5384, 6197, 6991, 13159, 13161, 13163, 13165, 13542, 13543, 13544, 13549, 13550, 13551, 13552, 13553, 13554, 13555, 13795, 13809, 13813, 14260, 14261, 14262, 14263, 14264, 14265, 14266, 14267, 14268, 14269, 14270, 14271, 14272, 14273, 14274, 14279, 14280, 14281, 14282, 14283, 14284, 14285, 14286, 14287, 14288, 14289, 14290, 14294, 14295, 14302, 14303, 14304, 14305, 14310, 14311, 14316, 14317, 14318, 14319, 14320, 14321, 14322, 14323, 14324, 14325, 14326, 14327, 15629, 15630, 15631, 15632, 19801, 19878, 19879, 19880, 19882, 19883, 19884, 19885, 20043, 20190, 20736, 25294, 25295, 25296, 27014, 27015, 27016, 27018, 27019, 27020, 27021, 27022, 27023, 27025, 27044, 27045, 27046, 34026, 34074, 34120, 34477, 34600, 36916, 0 },		// CLASS 3
			{ 674, 921, 1725, 1787, 1804, 1833, 1842, 1860, 2094, 2836, 2842, 3127, 5938, 6774, 8643, 8681, 11297, 11305, 26669, 26679, 26862, 26863, 26865, 26866, 26867, 26884, 26889, 27441, 27448, 31224, 32684, 38764, 38768, 0 },		// CLASS 4
			{ 17, 139, 453, 527, 528, 552, 586, 588, 589, 591, 592, 594, 596, 598, 600, 602, 605, 970, 976, 984, 988, 992, 996, 1004, 1006, 1243, 1244, 1245, 1706, 2006, 2010, 2052, 2053, 2054, 2055, 2060, 2061, 2096, 2767, 2791, 3747, 6060, 6063, 6064, 6065, 6066, 6074, 6075, 6076, 6077, 6078, 7128, 8092, 8102, 8103, 8104, 8105, 8106, 8122, 8124, 8129, 8131, 8192, 9472, 9473, 9474, 9484, 9485, 9578, 9579, 9592, 10874, 10875, 10876, 10880, 10881, 10888, 10890, 10892, 10893, 10894, 10898, 10899, 10900, 10901, 10909, 10911, 10912, 10915, 10916, 10917, 10927, 10928, 10929, 10933, 10934, 10937, 10938, 10941, 10942, 10945, 10946, 10947, 10951, 10952, 10953, 10955, 10957, 10960, 10961, 10963, 10964, 10965, 14914, 15261, 15262, 15263, 15264, 15265, 15266, 15267, 19289, 19291, 19292, 19293, 20770, 25210, 25213, 25217, 25218, 25221, 25222, 25233, 25235, 25308, 25314, 25315, 25316, 25363, 25364, 25367, 25368, 25372, 25375, 25379, 25380, 25384, 25389, 25429, 25431, 25435, 25450, 25596, 32375, 32379, 32546, 32996, 33076, 34433, 34863, 34864, 34865, 34866, 0 },		// CLASS 5
			{ 50096,61274,50108,61275,50109,61276,50110,61277,50111,61278,52297,48266,45902,52374,49410,50842,48721,49926,55258,47476,51426,49927,45529,55259,56222,49913,49939,48743,51427,49928,55260,49914,49940,49929,55261,51428,49915,49941,51429,49916,49930,55262,59921,61455,49142,45477,52372,48263,47528,45524,51416,51408,49896,49020,3714,48792,51417,57330,49903,51423,56815,56816,57532,51418,51409,49904,51424,47568,51419,57623,51410,49909,51425,55268,51411,50444,51969,51983,51970,51986,50536,59879,45469,45470,48778,47632,47633,47541,52375,50977,49576,45462,52373,49998,46584,51325,43265,49917,49892,49999,49918,49936,55265,48707,49893,51326,45463,49919,51373,51376,48265,49937,55270,51327,49923,49920,51374,51378,49894,55271,42650,42651,51328,49938,49895,49924,49921,51375,51379,53341,53331,53343,54447,53342,54446,53323,53344,53428,0 },		// CLASS 6
			{ 131, 324, 325, 332, 370, 421, 526, 529, 546, 547, 548, 556, 905, 913, 915, 930, 939, 943, 945, 959, 1064, 1535, 2008, 2484, 2645, 2860, 2870, 3599, 5394, 5675, 5730, 6041, 6196, 6363, 6364, 6365, 6375, 6377, 6390, 6391, 6392, 6495, 8004, 8005, 8008, 8010, 8012, 8017, 8024, 8027, 8030, 8033, 8038, 8042, 8044, 8045, 8046, 8050, 8052, 8053, 8056, 8058, 8071, 8075, 8134, 8143, 8154, 8155, 8160, 8161, 8166, 8170, 8177, 8181, 8184, 8190, 8227, 8232, 8235, 8249, 8498, 8499, 8512, 8835, 10391, 10392, 10395, 10396, 10406, 10407, 10408, 10412, 10413, 10414, 10427, 10428, 10431, 10432, 10437, 10438, 10442, 10447, 10448, 10456, 10462, 10463, 10466, 10467, 10468, 10472, 10473, 10478, 10479, 10486, 10495, 10496, 10497, 10526, 10537, 10538, 10585, 10595, 10600, 10601, 10605, 10613, 10622, 10623, 10627, 11314, 11315, 15107, 15111, 15112, 15207, 15208, 16339, 16341, 16342, 16355, 16356, 16362, 16387, 20608, 20609, 20610, 20776, 20777, 24398, 25357, 25359, 25361, 25391, 25396, 25420, 25422, 25423, 25439, 25442, 25448, 25449, 25454, 25457, 25464, 25469, 25472, 25489, 25500, 25505, 25508, 25509, 25525, 25528, 25533, 25546, 25547, 25557, 25560, 25563, 25567, 25570, 25574, 25577, 25908, 29228, 33736, 36936, 0 },		// CLASS 7
			{ 10, 66, 116, 118, 120, 122, 130, 143, 145, 205, 475, 543, 587, 597, 604, 759, 837, 865, 990, 1008, 1449, 1459, 1460, 1461, 1463, 1953, 2120, 2121, 2136, 2137, 2138, 2139, 2855, 2948, 3140, 3552, 5143, 5144, 5145, 5504, 5505, 5506, 6117, 6127, 6129, 6131, 6141, 6143, 7300, 7301, 7302, 7320, 7322, 8400, 8401, 8402, 8406, 8407, 8408, 8412, 8413, 8416, 8417, 8422, 8423, 8427, 8437, 8438, 8439, 8444, 8445, 8446, 8450, 8451, 8455, 8457, 8458, 8461, 8462, 8492, 8494, 8495, 10053, 10054, 10138, 10139, 10140, 10144, 10145, 10148, 10149, 10150, 10151, 10156, 10157, 10159, 10160, 10161, 10169, 10170, 10173, 10174, 10177, 10179, 10180, 10181, 10185, 10186, 10187, 10191, 10192, 10193, 10197, 10199, 10201, 10202, 10205, 10206, 10207, 10211, 10212, 10215, 10216, 10219, 10220, 10223, 10225, 10230, 12051, 12824, 12825, 12826, 22782, 22783, 25304, 25306, 25345, 27070, 27071, 27072, 27073, 27074, 27075, 27078, 27079, 27080, 27082, 27085, 27086, 27087, 27088, 27101, 27124, 27125, 27126, 27128, 27130, 27131, 28609, 28612, 30449, 30451, 30455, 30482, 32796, 33717, 33944, 33946, 37420, 38699, 0 },		// CLASS 8
			{ 126, 132, 172, 348, 603, 688, 689, 691, 693, 695, 696, 697, 698, 699, 702, 704, 705, 706, 707, 709, 710, 712, 755, 980, 1010, 1014, 1086, 1088, 1094, 1098, 1106, 1108, 1120, 1122, 1454, 1455, 1456, 1490, 1714, 1949, 2362, 2941, 3698, 3699, 3700, 5138, 5484, 5500, 5676, 5697, 5699, 5740, 5782, 5784, 6201, 6202, 6205, 6213, 6215, 6217, 6219, 6222, 6223, 6226, 6229, 6353, 6366, 6789, 7641, 7646, 7648, 7651, 7658, 7659, 8288, 8289, 11659, 11660, 11661, 11665, 11667, 11668, 11671, 11672, 11675, 11677, 11678, 11683, 11684, 11687, 11688, 11689, 11693, 11694, 11695, 11699, 11700, 11703, 11704, 11707, 11708, 11711, 11712, 11713, 11717, 11719, 11721, 11722, 11725, 11726, 11729, 11730, 11733, 11734, 11735, 11739, 11740, 17727, 17728, 17862, 17919, 17920, 17921, 17922, 17923, 17924, 17925, 17926, 17928, 17937, 18540, 18647, 20752, 20755, 20756, 20757, 23161, 25307, 25309, 25311, 27209, 27210, 27211, 27212, 27213, 27215, 27216, 27217, 27218, 27219, 27220, 27221, 27222, 27223, 27224, 27226, 27228, 27229, 27230, 27238, 27243, 27259, 27260, 28172, 28176, 28189, 28610, 29722, 29858, 29893, 30459, 30545, 30908, 30909, 30910, 32231, 0 },		// CLASS 9
			{ 0 },		// CLASS 10
			{ 99, 339, 467, 740, 768, 769, 770, 774, 778, 779, 780, 782, 783, 1058, 1062, 1066, 1075, 1079, 1082, 1126, 1178, 1430, 1735, 1822, 1823, 1824, 1850, 2090, 2091, 2637, 2782, 2893, 2908, 2912, 3025, 3029, 3137, 3627, 5177, 5178, 5179, 5180, 5186, 5187, 5188, 5189, 5195, 5196, 5201, 5209, 5211, 5215, 5217, 5221, 5225, 5229, 5232, 5234, 6756, 6778, 6780, 6783, 6785, 6787, 6793, 6795, 6798, 6800, 6807, 6808, 6809, 8903, 8905, 8907, 8910, 8914, 8918, 8921, 8924, 8925, 8926, 8927, 8928, 8929, 8936, 8938, 8939, 8940, 8941, 8946, 8949, 8950, 8951, 8955, 8972, 8983, 8992, 8998, 9005, 9490, 9492, 9493, 9634, 9745, 9747, 9749, 9750, 9752, 9754, 9756, 9758, 9821, 9823, 9827, 9829, 9830, 9833, 9834, 9835, 9839, 9840, 9841, 9845, 9846, 9849, 9850, 9852, 9853, 9856, 9857, 9858, 9862, 9863, 9866, 9867, 9875, 9876, 9880, 9881, 9884, 9885, 9888, 9889, 9894, 9896, 9898, 9901, 9904, 9907, 9908, 9910, 9912, 9913, 16914, 16952, 16954, 16958, 16961, 17401, 17402, 18657, 18658, 18960, 20484, 20719, 20739, 20742, 20747, 20748, 22568, 22570, 22812, 22827, 22828, 22829, 22842, 22895, 22896, 24248, 25297, 25298, 25299, 26978, 26979, 26980, 26981, 26982, 26983, 26984, 26985, 26986, 26987, 26988, 26989, 26990, 26992, 26993, 26994, 26995, 26996, 26997, 26998, 26999, 27000, 27001, 27002, 27003, 27005, 27006, 27008, 27012, 29166, 31018, 33357, 33745, 33763, 33786, 33943, 34090, 0 },		// CLASS 11
		};

		uint32 c = plr->getClass();
		for(uint32 i = 0; spellarray[c][i] != 0; ++i)
		{
			plr->addSpell(spellarray[c][i]);
		}

		static uint32 paladinspellarray[RACE_DRAENEI+1][2] = {
			{ 0 },		// RACE 0
			{ 13819, 0 },		// HUMAN
			{ 0 },		// ORC
			{ 13819, 0 },		// DWARF
			{ 0 },		// NIGHTELF
			{ 0 },		// UNDEAD
			{ 0 },		// TAUREN
			{ 0 },		// GNOME
			{ 0 },		// TROLL
			{ 34769, 0 },		// BLOODELF
			{ 13819, 0 },		// DRAENEI
		};

		static uint32 priestspellarray[RACE_DRAENEI+1][16] = {
			{ 0 },		// RACE 0
			{ 13896, 13908, 19236, 19238, 19240, 19241, 19242, 19243, 19271, 19273, 19274, 19275, 25437, 25441, 0 },		// HUMAN
			{ 0 },		// ORC
			{ 13908, 19236, 19238, 19240, 44041, 19241, 19242, 19243, 25437, 44043, 44044, 44045, 44046, 44047, 0 },		// DWARF
			{ 2651, 10797, 19296, 19299, 19302, 19303, 19304, 19305, 25446, 0 },		// NIGHTELF
			{ 2652, 2944, 19261, 19262, 19264, 19265, 19266, 19276, 19277, 19278, 19279, 19280, 25461, 25467, 0 },		// UNDEAD
			{ 0 },		// TAUREN
			{ 0 },		// GNOME
			{ 9035, 18137, 19281, 19282, 19283, 19284, 19285, 19308, 19309, 19310, 19311, 19312, 25470, 25477, 0 },		// TROLL
			{ 2652, 19261, 19262, 19264, 19265, 19266, 25461, 32676, 0 },		// BLOODELF
			{ 32548, 44041, 44043, 44044, 44045, 44046, 44047, 0 },		// DRAENEI
		};

		static uint32 shamanspellarray[RACE_DRAENEI+1][2] = {
			{ 0 },		// RACE 0
			{ 0 },		// HUMAN
			{ 2825, 0 },		// ORC
			{ 0 },		// DWARF
			{ 0 },		// NIGHTELF
			{ 0 },		// UNDEAD
			{ 2825, 0 },		// TAUREN
			{ 0 },		// GNOME
			{ 2825, 0 },		// TROLL
			{ 0 },		// BLOODELF
			{ 32182, 0 },		// DRAENEI
		};

		static uint32 magespellarray[RACE_DRAENEI+1][13] = {
			{ 0 },		// RACE 0
			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 49359, 49360, 0 },		// HUMAN
			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 49358, 49361, 0 },		// ORC
			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 49359, 49360, 0 },		// DWARF
			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 49359, 49360, 0 },		// NIGHTELF
			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 49358, 49361, 0 },		// UNDEAD
			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 49358, 49361, 0 },		// TAUREN
			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 49359, 49360, 0 },		// GNOME
			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 49358, 49361, 0 },		// TROLL
			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 49358, 49361, 0 },		// BLOODELF
			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 49359, 49360, 0 },		// DRAENEI
		};

		uint32 r = plr->getRace();
		switch(c)
		{
		case PALADIN:
			for( uint32 i = 0; paladinspellarray[r][i] != 0; ++i )
			{
				plr->addSpell( paladinspellarray[r][i] );
			}
			break;
		case PRIEST:
			for( uint32 i = 0; priestspellarray[r][i] != 0; ++i )
			{
				plr->addSpell( priestspellarray[r][i] );
			}
			break;
		case MAGE:
			for( uint32 i = 0; magespellarray[r][i] != 0; ++i )
			{
				plr->addSpell( magespellarray[r][i] );
			}
			break;
		case SHAMAN:
			for( uint32 i = 0; shamanspellarray[r][i] != 0; ++i )
			{
				plr->addSpell( shamanspellarray[r][i] );
			}
			break;
		}
		return true;
	}*/

	uint32 spell = atol((char*)args);
	sGMLog.writefromsession(m_session, "taught %s spell %u", plr->GetName(), spell);

	SpellEntry * sp = dbcSpell.LookupEntry(spell);
	if(!plr->GetSession()->HasGMPermissions() && (sp->eff[0].Effect==SPELL_EFFECT_INSTANT_KILL||sp->eff[1].Effect==SPELL_EFFECT_INSTANT_KILL||sp->eff[2].Effect==SPELL_EFFECT_INSTANT_KILL))
	{
		SystemMessage(m_session, "don't be an idiot and teach players instakill spells. this action has been logged.");
		return true;
	}

	if (plr->HasSpell(spell)) // check to see if char already knows
	{
		std::string OutStr = plr->GetName();
		OutStr += " already knows that spell.";

		SystemMessage(m_session, OutStr.c_str());
		return true;
	}

	plr->addSpell(spell);
	BlueSystemMessageToPlr(plr, "%s taught you Spell %d", m_session->GetPlayer()->GetName(), spell);

	return true;
}

bool ChatHandler::HandleReviveCommand(const char* args, WorldSession *m_session)
{
	Player* SelectedPlayer = getSelectedChar(m_session, true);
	if(!SelectedPlayer) 
		return true;
	
	SelectedPlayer->SetMovement(MOVE_UNROOT);
	SelectedPlayer->ResurrectPlayer();
	SelectedPlayer->SetUInt32Value(UNIT_FIELD_HEALTH, SelectedPlayer->GetUInt32Value(UNIT_FIELD_MAXHEALTH) );

	if ( SelectedPlayer != m_session->GetPlayer() )
		sGMLog.writefromsession( m_session, "revived player %s", SelectedPlayer->GetName() );

	return true;
}

bool ChatHandler::HandleExploreCheatCommand(const char* args, WorldSession *m_session)
{
	if (!*args)
		return false;

	Player *chr = getSelectedChar(m_session);
	if (chr == NULL)
	{
		chr = m_session->GetPlayer();
		SystemMessage(m_session, "Auto-targeting self.");
	}

	if (strcmp(args, "on") == 0)
	{
		SystemMessage(m_session, "%s has explored all zones now.", chr->GetName());
		SystemMessage(m_session, "%s has explored all zones for you.", m_session->GetPlayer()->GetName());
		sGMLog.writefromsession( m_session, "explored all zones for player %s", chr->GetName() );
	}
	else if(strcmp(args, "off") == 0)
	{
		SystemMessage(m_session, "%s has no more explored zones.", chr->GetName());
		SystemMessage(m_session, "%s has hidden all zones from you.", m_session->GetPlayer()->GetName());
		sGMLog.writefromsession( m_session, "hid all zones for player %s", chr->GetName() );
	}
	else 
		return false;

	for (uint8 i=PLAYER_EXPLORED_ZONES_1-PLAYER_EXPLORED_ZONES_1; i<PLAYER_REST_STATE_EXPERIENCE-PLAYER_EXPLORED_ZONES_1; i++)
	{
		if (strcmp(args, "on") == 0)
		{
			chr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0xFFFFFFFF);
		}
		else if(strcmp(args, "off") == 0)
		{
			chr->SetFlag(PLAYER_EXPLORED_ZONES_1+i,0);
		}
	}
	return true;
}

bool ChatHandler::HandleBanCharacterCommand(const char* args, WorldSession *m_session)
{
	if(!*args)
		return false;

	// this is rather complicated due to ban reasons being able to have spaces. so we'll have to some c string magic
	// rather than just sscanf'ing it.
	char * pCharacter = (char*)args;
	char * pBanDuration = strchr(pCharacter, ' ');
	PlayerInfo * pInfo = NULL;
	if(pBanDuration == NULL)
		return false;

	char * pReason = strchr(pBanDuration+1, ' ');
	if(pReason == NULL)
		return false;

	// zero them out to create sepearate strings.
	*pBanDuration = 0;
	++pBanDuration;
	*pReason = 0;
	++pReason;

	int32 BanTime = GetTimePeriodFromString(pBanDuration);
	if(BanTime < 1)
		return false;

#ifdef FORCED_GM_BAN_LIMITATION
	if( m_session->HasGMPermissions() == false )
	{
		if( BanTime == 0 || BanTime > FORCED_GM_BAN_LIMITATION )
			BanTime = FORCED_GM_BAN_LIMITATION;
	}
#endif
	Player * pPlayer = objmgr.GetPlayer(pCharacter, false);
	if(pPlayer == NULL)
	{
		pInfo = objmgr.GetPlayerInfoByName(pCharacter);
		if(pInfo == NULL)
		{
			SystemMessage(m_session, "Player not found.");
			return true;
		}

		SystemMessage(m_session, "Banning player '%s' in database for '%s'.", pCharacter, pReason);
		string escaped_reason = CharacterDatabase.EscapeString(string(pReason));
		
		uint32 BantimeSQL = BanTime ? BanTime+(uint32)UNIXTIME : 1;
		CharacterDatabase.Execute("UPDATE characters SET banned = %u, banReason = '%s' WHERE guid = %u and banned < %u",
			BantimeSQL, escaped_reason.c_str(), pInfo->guid, BantimeSQL);
	}
	else
	{
		SystemMessage(m_session, "Banning player '%s' ingame for '%s'.", pCharacter, pReason);
		string sReason = string(pReason);
		uint32 uBanTime = BanTime ? BanTime+(uint32)UNIXTIME : 1;
		pPlayer->SetBanned(uBanTime, sReason);
		pInfo = pPlayer->m_playerInfo;
	}

	SystemMessage(m_session, "This ban is due to expire %s%s.", BanTime ? "on " : "", BanTime ? ConvertTimeStampToDataTime(BanTime+(uint32)UNIXTIME).c_str() : "Never");
	sGMLog.writefromsession(m_session, "banned %s, reason %s, for %s", pCharacter, pReason, BanTime ? ConvertTimeStampToString(BanTime).c_str() : "ever");
	char msg[200];
	if( m_session && m_session->GetPlayer() )
		snprintf( msg, 200, "%sGM: %s has been banned by %s for %s. Reason: %s", MSG_COLOR_RED, pCharacter, m_session->GetPlayer()->GetName(), BanTime ? ConvertTimeStampToString( BanTime ).c_str() : "ever", pReason );
	sWorld.SendWorldText( msg, NULL );
	if( sWorld.m_banTable && pInfo )
	{
		CharacterDatabase.Execute("INSERT INTO %s VALUES('%s', '%s', %u, %u, '%s')", sWorld.m_banTable, m_session->GetPlayer()->GetName(), pInfo->name, (uint32)UNIXTIME, (uint32)UNIXTIME + BanTime, CharacterDatabase.EscapeString(string(pReason)).c_str() );
	}
	if(pPlayer)
	{
		SystemMessage(m_session, "Kicking %s.", pPlayer->GetName());
		pPlayer->Kick();
	}
	return true;
}

bool ChatHandler::HandleUnBanCharacterCommand(const char* args, WorldSession *m_session)
{
	if(!*args)
		return false;

	char Character[255];
	if(sscanf(args, "%s", Character) == 0)
	{
		RedSystemMessage(m_session, "A character name and reason is required.");
		return true;
	}

	// Check if player is in world.
	Player * pPlayer = ObjectMgr::getSingleton( ).GetPlayer(Character, false);
	if(pPlayer != 0)
	{
		GreenSystemMessage(m_session, "Unbanned player %s ingame.",pPlayer->GetName());
		pPlayer->UnSetBanned();
	}
	else
	{
		GreenSystemMessage(m_session, "Player %s not found ingame.", Character);
	}

	// Ban in database
	CharacterDatabase.Execute("UPDATE characters SET banned = 0 WHERE name = '%s'", CharacterDatabase.EscapeString(string(Character)).c_str());

	SystemMessage(m_session, "Unbanned character %s in database.", Character);
	sGMLog.writefromsession(m_session, "unbanned %s", Character);
	return true;
}

bool ChatHandler::HandleSpellDisableAddCommand(const char* args, WorldSession *m_session)
{
	if(!*args)
		return false;

	uint32 spell_id;
	if(sscanf(args, "%u", &spell_id) == 0)
	{
		RedSystemMessage(m_session, "Usage : .spelldisable_add <spell_id>");
		return true;
	}

	SpellEntry *sp = dbcSpell.LookupEntryForced( spell_id );

	if( sp == NULL )
	{
		RedSystemMessage(m_session, "Invalid spell id %d",spell_id);
		return true;
	}

	if( sp->c_is_flags & SPELL_FLAG_IS_DISABLED )
		m_session->GetPlayer()->BroadcastMessage("Spell %d is already disabled",spell_id);
	else
	{
		// Ban in database
		WorldDatabase.Execute("REPLACE INTO spell_disable (spellid, replacement_spellid) VALUES (%d, 0) ", spell_id );
		sp->c_is_flags |= SPELL_FLAG_IS_DISABLED;

		m_session->GetPlayer()->BroadcastMessage("Disabled Spell : %d",spell_id);
	}

	return true;
}

bool ChatHandler::HandleSpellDisableRemoveCommand(const char* args, WorldSession *m_session)
{
	if(!*args)
		return false;

	uint32 spell_id;
	if(sscanf(args, "%u", &spell_id) == 0)
	{
		RedSystemMessage(m_session, "Usage : .spelldisable_remove <spell_id>");
		return true;
	}

	SpellEntry *sp = dbcSpell.LookupEntryForced( spell_id );

	if( sp == NULL )
	{
		RedSystemMessage(m_session, "Invalid spell id %d",spell_id);
		return true;
	}

	if( sp->c_is_flags & SPELL_FLAG_IS_DISABLED )
	{
		// Ban in database
		WorldDatabase.Execute("delete from spell_disable where spellid = %d", spell_id );
		sp->c_is_flags &= ~SPELL_FLAG_IS_DISABLED;

		m_session->GetPlayer()->BroadcastMessage("Removed Spell Disable : %d",spell_id);
	}
	else
		m_session->GetPlayer()->BroadcastMessage("Spell %d is not disabled",spell_id);

	return true;
}

bool ChatHandler::HandleAddSkillCommand(const char* args, WorldSession *m_session)
{
	char buf[256];
	Player* target = objmgr.GetPlayer((uint32)m_session->GetPlayer()->GetSelection());

	if(!target) {
		SystemMessage(m_session, "Select A Player first.");
		return true;
	}

	uint32 skillline;
	uint16 cur, max;

	char* pSkillline = strtok((char*)args, " ");
	if (!pSkillline)
		return false;

	char* pCurrent = strtok(NULL, " ");
	if (!pCurrent)
		return false;

	char* pMax = strtok(NULL, " ");
	if (!pMax)
		return false;

	skillline = (uint32)atol(pSkillline);
	cur = (uint16)atol(pCurrent);
	max = (uint16)atol(pMax);

	target->_AddSkillLine(skillline,cur,max);

	snprintf(buf,256,"SkillLine: %u CurrentValue %u Max Value %u Added.",(unsigned int)skillline,(unsigned int)cur,(unsigned int)max);
	sGMLog.writefromsession(m_session, "added skill line %u (%u/%u) to %s", skillline, cur, max, target->GetName());
	SystemMessage(m_session, buf);

	return true;
}

bool ChatHandler::HandleNpcInfoCommand(const char *args, WorldSession *m_session)
{
	uint32 guid = GUID_LOPART(m_session->GetPlayer()->GetSelection());
	Creature *crt = getSelectedCreature(m_session);
	if(!crt) return false;
	if(crt->GetCreatureInfo())
		BlueSystemMessage(m_session, "Showing creature info for %s", crt->GetCreatureInfo()->Name);
	SystemMessage(m_session, "GUID: %d", guid);
	SystemMessage(m_session, "Faction: %d", crt->GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE));
	SystemMessage(m_session, "NPCFlags: %d", crt->GetUInt32Value(UNIT_NPC_FLAGS));
	SystemMessage(m_session, "DisplayID: %d", crt->GetUInt32Value(UNIT_FIELD_DISPLAYID));
    if (crt->GetProto())
        SystemMessage(m_session, "Respawn: %s - %dms", (crt->m_noRespawn)?"OFF":(crt->m_respawnTimeOverride>0)?"OVERWRITTEN":"ON",(crt->m_respawnTimeOverride>0)?crt->m_respawnTimeOverride:crt->GetProto()->RespawnTime);
	if(crt->m_faction)
		SystemMessage(m_session, "Combat Support: 0x%.3X", crt->m_faction->FriendlyMask);
	SystemMessage(m_session, "Health (cur/max): %d/%d", crt->GetUInt32Value(UNIT_FIELD_HEALTH), crt->GetUInt32Value(UNIT_FIELD_MAXHEALTH));
	SystemMessage(m_session, "Mana (cur/max): %d/%d", crt->GetPower( POWER_TYPE_MANA ), crt->GetMaxPower( POWER_TYPE_MANA ));
	SystemMessage(m_session, "Armor/Holy/Fire/Nature/Frost/Shadow/Arcane");
	SystemMessage(m_session, "%d/%d/%d/%d/%d/%d/%d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES), crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_1), crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_2), crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_3), crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_4), crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_5), crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_6));
	
	/*GreenSystemMessage(m_session, "Base Armor: %d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES));
	GreenSystemMessage(m_session, "Base Mana: %d", crt->GetMaxPower( POWER_TYPE_MANA ));
	GreenSystemMessage(m_session, "Base Holy: %d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_1));
	GreenSystemMessage(m_session, "Base Fire: %d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_2));
	GreenSystemMessage(m_session, "Base Nature: %d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_3));
	GreenSystemMessage(m_session, "Base Frost: %d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_4));
	GreenSystemMessage(m_session, "Base Shadow: %d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_5));
	GreenSystemMessage(m_session, "Base Arcane: %d", crt->GetUInt32Value(UNIT_FIELD_RESISTANCES_6));*/
	SystemMessage(m_session, "Damage (min/max): %f/%f", crt->GetFloatValue(UNIT_FIELD_MINDAMAGE),crt->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
	
	ColorSystemMessage(m_session, MSG_COLOR_RED, "Entry ID: %d", crt->GetUInt32Value(OBJECT_FIELD_ENTRY));
	ColorSystemMessage(m_session, MSG_COLOR_RED, "SQL Entry ID: %d", crt->GetSQL_id());
	// show byte
	std::stringstream sstext;
	uint32 theBytes = crt->GetUInt32Value(UNIT_FIELD_BYTES_0);
	sstext << "UNIT_FIELD_BYTES_0 are " << uint16((uint8)theBytes & 0xFF) << " " << uint16((uint8)(theBytes >> 8) & 0xFF) << " ";
	sstext << uint16((uint8)(theBytes >> 16) & 0xFF) << " " << uint16((uint8)(theBytes >> 24) & 0xFF) << '\0';
	SystemMessage(m_session, sstext.str().c_str());
	return true;
}

bool ChatHandler::HandleIncreaseWeaponSkill(const char *args, WorldSession *m_session)
{
	char *pMin = strtok((char*)args, " ");
	uint32 cnt = 0;
	if(!pMin)
		cnt = 1;
	else
		cnt = atol(pMin);

	Player *pr = getSelectedChar(m_session, true);
	
	uint32 SubClassSkill = 0;
	if(!pr) pr = m_session->GetPlayer();
	if(!pr) return false;
	Item *it = pr->GetItemInterface()->GetInventoryItem(EQUIPMENT_SLOT_MAINHAND);
	ItemPrototype* proto = NULL;
	if (!it)
		it = pr->GetItemInterface()->GetInventoryItem(EQUIPMENT_SLOT_RANGED);
	if (it)
		proto = it->GetProto();
	if (proto)
	{
		switch(proto->SubClass)
		{
			// Weapons
		case 0:	// 1 handed axes
			SubClassSkill = SKILL_AXES;
			break;
		case 1:	// 2 handed axes
			SubClassSkill = SKILL_2H_AXES;
			break;		
		case 2:	// bows
			SubClassSkill = SKILL_BOWS;
			break;
		case 3:	// guns
			SubClassSkill = SKILL_GUNS;
			break;		
		case 4:	// 1 handed mace
			SubClassSkill = SKILL_MACES;
			break;
		case 5:	// 2 handed mace
			SubClassSkill = SKILL_2H_MACES;
			break;		
		case 6:	// polearms
			SubClassSkill = SKILL_POLEARMS;
			break;
		case 7: // 1 handed sword
			SubClassSkill = SKILL_SWORDS;
			break;
		case 8: // 2 handed sword
			SubClassSkill = SKILL_2H_SWORDS;
			break;
		case 9: // obsolete
			SubClassSkill = 136;
			break;
		case 10: //1 handed exotic
			SubClassSkill = 136;
			break;
		case 11: // 2 handed exotic
			SubClassSkill = 0;
			break;
		case 12: // fist
			SubClassSkill = SKILL_FIST_WEAPONS;
			break;
		case 13: // misc
			SubClassSkill = 0;
			break;
		case 15: // daggers
			SubClassSkill = SKILL_DAGGERS;
			break;
		case 16: // thrown
			SubClassSkill = SKILL_THROWN;
			break;
//		case 17: // spears
//			SubClassSkill = SKILL_SPEARS;
//			break;
		case 18: // crossbows
			SubClassSkill = SKILL_CROSSBOWS;
			break;
		case 19: // wands
			SubClassSkill = SKILL_WANDS;
			break;
		case 20: // fishing
			SubClassSkill = SKILL_FISHING;
			break;
		}
	} 
	else
	{
		SubClassSkill = 162;
	}

	if(!SubClassSkill)
	{
		RedSystemMessage(m_session, "Can't find skill ID :-/");
		return false;
	}

	uint32 skill = SubClassSkill;

	BlueSystemMessage(m_session, "Modifying skill line %d. Advancing %d times.", skill, cnt);
	sGMLog.writefromsession(m_session, "increased weapon skill (%u) of %s by %u", skill, pr->GetName(), cnt);

	if(!pr->_HasSkillLine(skill))
	{
		SystemMessage(m_session, "Does not have skill line, adding.");
		pr->_AddSkillLine(skill, 1, 300);   
	} 
	else 
	{
		pr->_AdvanceSkillLine(skill,cnt);
	}	   
	return true;	
}


bool ChatHandler::HandleResetTalentsCommand(const char* args, WorldSession *m_session)
{
	Player *plr = this->getSelectedChar(m_session);
	if(!plr) return true;

	plr->Reset_Talents();

	SystemMessage(m_session, "Reset talents of %s.", plr->GetName());;
	BlueSystemMessageToPlr(plr, "%s reset all your talents.", m_session->GetPlayer()->GetName());
	sGMLog.writefromsession(m_session, "reset talents of %s", plr->GetName());
	return true;
}

bool ChatHandler::HandleResetSpellsCommand(const char* args, WorldSession *m_session)
{
	Player *plr = this->getSelectedChar(m_session);
	if(!plr) return true;

	plr->Reset_Spells();
	
	SystemMessage(m_session, "Reset spells of %s to level 1.", plr->GetName());;
	BlueSystemMessage(m_session, "%s reset all your spells to starting values.", m_session->GetPlayer()->GetName());
	sGMLog.writefromsession(m_session, "reset spells of %s", plr->GetName());
	return true;
}

bool ChatHandler::HandleAccountLevelCommand(const char * args, WorldSession * m_session)
{
    if(!*args) return false;

	char account[100];
	char gmlevel[100];
	int argc = sscanf(args, "%s %s", account, gmlevel);
	if(argc != 2)
		return false;

	sLogonCommHandler.Account_SetGM( account, gmlevel );

	GreenSystemMessage(m_session, "Account '%s' level has been updated to '%s'. The change will be effective immediately.", account, gmlevel);
	sGMLog.writefromsession(m_session, "set account %s flags to %s", account, gmlevel);

	return true;
}

bool ChatHandler::HandleAccountUnbanCommand(const char * args, WorldSession * m_session)
{
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() )
	{
		return true;
	}
#endif
	if(!*args) return false;
	char * pAccount = (char*)args;
	
	sLogonCommHandler.Account_SetBanned( pAccount, 0, "" );
	GreenSystemMessage(m_session, "Account '%s' has been unbanned. This change will be effective immediately.", pAccount);
	
	sGMLog.writefromsession(m_session, "unbanned account %s", pAccount);
	return true;
}

bool ChatHandler::HandleAccountBannedCommand(const char * args, WorldSession * m_session)
{
    if(!*args) return false;

	/*char account[100];
	uint32 banned;
	int argc = sscanf(args, "%s %u", account, (unsigned int*)&banned);
	if(argc != 2)
		return false;*/

	char * pAccount = (char*)args;
	char * pDuration = strchr(pAccount, ' ');
	if( pDuration == NULL )
		return false;
	*pDuration = 0;
	++pDuration;

	int32 timeperiod = GetTimePeriodFromString(pDuration);
	if( timeperiod < 0 )
		return false;

#ifdef FORCED_GM_BAN_LIMITATION
	if( m_session->HasGMPermissions() == false )
	{
		if( timeperiod > FORCED_GM_BAN_LIMITATION )
			timeperiod = FORCED_GM_BAN_LIMITATION;
		else if( timeperiod == 0 )
			timeperiod = FORCED_GM_BAN_LIMITATION;
	}
#endif
	uint32 banned = (timeperiod ? (uint32)UNIXTIME+timeperiod : 1);
	char emptystring = 0;
	char * pReason = strchr(pDuration+1, ' ');
	if( pReason == NULL )
	{
//		pReason = &emptystring;
		SystemMessage(m_session, "You need to specify a ban reason");
		return true;
	}

	/*stringstream my_sql;
	my_sql << "UPDATE accounts SET banned = " << banned << " WHERE login = '" << CharacterDatabase.EscapeString(string(pAccount)) << "'";

	sLogonCommHandler.LogonDatabaseSQLExecute(my_sql.str().c_str());
	sLogonCommHandler.LogonDatabaseReloadAccounts();*/
	char reason_buf[5000];
	sprintf(reason_buf,"GM %s at %s : %s",m_session->GetPlayer()->GetName(), ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME).c_str(), pReason);
	sLogonCommHandler.Account_SetBanned(pAccount, banned, reason_buf);

	GreenSystemMessage(m_session, "Account '%s' has been banned %s%s for reason : %s. The change will be effective immediately.", pAccount, pReason, 
		timeperiod ? "until " : "forever", timeperiod ? ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME).c_str() : "", pReason);

	sWorld.DisconnectUsersWithAccount(pAccount, m_session);
	sGMLog.writefromsession(m_session, "banned account %s until %s", pAccount, timeperiod ? ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME).c_str() : "permanant");
	return true;
}

bool ChatHandler::HandleAccountMuteCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	char * pAccount = (char*)args;
	char * pDuration = strchr(pAccount, ' ');
	if(pDuration == NULL)
		return false;
	*pDuration = 0;
	++pDuration;

	int32 timeperiod = GetTimePeriodFromString(pDuration);
	if(timeperiod <= 0)
		return false;

#ifdef FORCED_GM_BAN_LIMITATION
	if( m_session->HasGMPermissions() == false )
	{
		if( timeperiod > FORCED_GM_BAN_LIMITATION )
			timeperiod = FORCED_GM_BAN_LIMITATION;
		else if( timeperiod == 0 )
			timeperiod = FORCED_GM_BAN_LIMITATION;
	}
#endif
	uint32 banned = (uint32)UNIXTIME+timeperiod;

	sLogonCommHandler.Account_SetMute( pAccount, banned );

	string tsstr = ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME);
	GreenSystemMessage(m_session, "Account '%s' has been muted until %s. The change will be effective immediately.", pAccount, 
		tsstr.c_str());

	sGMLog.writefromsession(m_session, "muted account %s until %s", pAccount, ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME).c_str());

	WorldSession * pSession = sWorld.FindSessionByName(pAccount);
	if( pSession != NULL )
	{
		pSession->m_muted = banned;
		pSession->SystemMessage("Your voice has been muted until %s by a GM. Until this time, you will not be able to speak in any form.", tsstr.c_str());
	}

	return true;
}

bool ChatHandler::HandleAccountUnmuteCommand(const char * args, WorldSession * m_session)
{
	sLogonCommHandler.Account_SetMute( args, 0 );

	GreenSystemMessage(m_session, "Account '%s' has been unmuted.", args);
	sGMLog.writefromsession( m_session, "unmuted account %s", args );
	WorldSession * pSession = sWorld.FindSessionByName(args);
	if( pSession != NULL )
	{
		pSession->m_muted = 0;
		pSession->SystemMessage("Your voice has restored. You may speak again.");
	}

	return true;
}

bool ChatHandler::HandleIPMuteCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	char * IP = (char*)args;
	char * pDuration = strchr(IP, ' ');
	if(pDuration == NULL)
		return false;
	*pDuration = 0;
	++pDuration;

	int32 timeperiod = GetTimePeriodFromString(pDuration);
	if(timeperiod <= 0)
		return false;

#ifdef FORCED_GM_BAN_LIMITATION
	if( m_session->HasGMPermissions() == false )
	{
		if( timeperiod > FORCED_GM_BAN_LIMITATION )
			timeperiod = FORCED_GM_BAN_LIMITATION;
		else if( timeperiod == 0 )
			timeperiod = FORCED_GM_BAN_LIMITATION;
	}
#endif
	uint32 banned = (uint32)UNIXTIME+timeperiod;
//	sLogonCommHandler.Account_SetMute( pAccount, banned );

	string tsstr = ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME);
	GreenSystemMessage(m_session, "IP '%s' has been muted until %s. The change will be effective immediately.", IP, 
		tsstr.c_str());

	sGMLog.writefromsession(m_session, "muted IP %s until %s", IP, ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME).c_str());

	sWorld.MuteSessionsByIP(IP,banned);
	objmgr.AddIPMute( IP, timeperiod );

	return true;
}

bool ChatHandler::HandleIPUnmuteCommand(const char * args, WorldSession * m_session)
{
//	sLogonCommHandler.Account_SetMute( args, 0 );

	GreenSystemMessage(m_session, "IP '%s' has been unmuted.", args);
	sGMLog.writefromsession( m_session, "unmuted IP %s", args );
	sWorld.UnMuteSessionsByIP( args );
	objmgr.RemoveIPMute( args );
	return true;
}

bool ChatHandler::HandleGetTransporterTime(const char* args, WorldSession* m_session)
{
	//Player *plyr = m_session->GetPlayer();
	Creature * crt = getSelectedCreature(m_session, false);
	if( crt == NULL )
		return false;

	WorldPacket data(SMSG_ATTACKERSTATEUPDATE, 1000);
	data << uint32(0x00000102);
	data << crt->GetNewGUID();
	data << m_session->GetPlayer()->GetNewGUID();
	
	data << uint32(6);
	data << uint8(1);
	data << uint32(1);
	data << uint32(0x40c00000);
	data << uint32(6);
	data << uint32(0);
	data << uint32(0);
	data << uint32(1);
	data << uint32(0x000003e8);
	data << uint32(0);
	data << uint32(0);
	m_session->SendPacket(&data);
	return true;
}

bool ChatHandler::HandleRemoveAurasCommand(const char *args, WorldSession *m_session)
{
	Player *plr = getSelectedChar(m_session, true);
	if(plr) 
	{
		BlueSystemMessage(m_session, "Removing all auras...");
		for(uint32 i = 0; i < MAX_NEGATIVE_AURAS1(plr); ++i)
			if(plr->m_auras[i] != 0) 
				plr->m_auras[i]->Remove();
		if(plr != m_session->GetPlayer())
			sGMLog.writefromsession(m_session, "Removed all of %s's auras.", plr->GetName());
	}
	else
	{
		Creature *plr = getSelectedCreature(m_session, true);
		if( plr == NULL )
			return false;
		BlueSystemMessage(m_session, "Removing all auras...");
		for(uint32 i = 0; i < MAX_NEGATIVE_AURAS1(plr); ++i)
			if(plr->m_auras[i] != 0) 
				plr->m_auras[i]->Remove();		
	}
	return true;
}

bool ChatHandler::HandleRemoveRessurectionSickessAuraCommand(const char *args, WorldSession *m_session)
{
	Player *plr = getSelectedChar(m_session, true);
	if(!plr) return false;

	BlueSystemMessage(m_session, "Removing ressurection sickness...");
	plr->RemoveAura( 15007 );
	if(plr != m_session->GetPlayer())
		sGMLog.writefromsession(m_session, "Removed resurrection sickness from %s", plr->GetName());
	return true;
}

bool ChatHandler::HandleParalyzeCommand(const char* args, WorldSession *m_session)
{
	//Player *plr = getSelectedChar(m_session, true);
	//if(!plr) return false;
	Player *plr = m_session->GetPlayer()->GetMapMgr()->GetPlayer(m_session->GetPlayer()->GetSelection());
	if( !plr )
	{
		RedSystemMessage(m_session, "Invalid target.");
		return true;
	}

	BlueSystemMessage(m_session, "Rooting target.");
	BlueSystemMessageToPlr( plr , "You have been rooted by %s.", m_session->GetPlayer()->GetName() );
	sGMLog.writefromsession( m_session, "rooted player %s", plr->GetName() );
	plr->SetMovement( MOVE_ROOT );
	return true;
}

bool ChatHandler::HandleUnParalyzeCommand(const char* args, WorldSession *m_session)
{
	//Player *plr = getSelectedChar(m_session, true);
	//if(!plr) return false;
	Unit *plr = m_session->GetPlayer()->GetMapMgr()->GetUnit(m_session->GetPlayer()->GetSelection());
	if(!plr || plr->GetTypeId() != TYPEID_PLAYER)
	{
		RedSystemMessage(m_session, "Invalid target.");
		return true;
	}
	
	BlueSystemMessage(m_session, "Unrooting target.");
	BlueSystemMessageToPlr( SafePlayerCast( plr ), "You have been unrooted by %s.", m_session->GetPlayer()->GetName() );
	sGMLog.writefromsession( m_session, "unrooted player %s", SafePlayerCast( plr )->GetName() );
	WorldPacket data;
	data.Initialize(SMSG_FORCE_MOVE_UNROOT);
	data << plr->GetNewGUID();
	data << uint32(5);

	plr->SendMessageToSet(&data, true);
	return true;
}

bool ChatHandler::HandleSetMotdCommand(const char* args, WorldSession* m_session)
{
	if(!args || strlen(args) < 2)
	{
		RedSystemMessage(m_session, "You must specify a message.");
		return true;
	}

	GreenSystemMessage(m_session, "Motd has been set to: %s", args);
	World::getSingleton().SetMotd(args);
	sGMLog.writefromsession(m_session, "Set MOTD to %s", args);
	return true;
}

bool ChatHandler::HandleAddItemSetCommand(const char* args, WorldSession* m_session)
{
	uint32 setid = (args ? atoi(args) : 0);
	if(!setid)
	{
		RedSystemMessage(m_session, "You must specify a setid.");
		return true;
	}

	Player *chr = getSelectedChar(m_session);
	if (chr == NULL) {
	RedSystemMessage(m_session, "Unable to select character.");
	return true;
	}

	ItemSetEntry *entry = dbcItemSet.LookupEntry(setid);
	std::list<ItemPrototype*>* l = objmgr.GetListForItemSet(setid);
	if(!entry || !l)
	{
		RedSystemMessage(m_session, "Invalid item set.");
		return true;
	}
	//const char* setname = sItemSetStore.LookupString(entry->name);
	BlueSystemMessage(m_session, "Searching item set %u...", setid);
	uint32 start = getMSTime();
	sGMLog.writefromsession(m_session, "used add item set command, set %u, target %s", setid, chr->GetName());
	for(std::list<ItemPrototype*>::iterator itr = l->begin(); itr != l->end(); ++itr)
	{
		Item *itm = objmgr.CreateItem((*itr)->ItemId, m_session->GetPlayer());
		if(!itm) continue;
		if(itm->GetProto()->Bonding == ITEM_BIND_ON_PICKUP)
		{
			if(itm->GetProto()->Flags & ITEM_FLAG_ACCOUNTBOUND) // don't "Soulbind" account-bound items
				itm->AccountBind();
			else
				itm->SoulBind();
		}

		if(!chr->GetItemInterface()->AddItemToFreeSlot(&itm))
		{
			m_session->SendNotification("No free slots left!");
			itm->DeleteMe();
			return true;
		} else {
			//SystemMessage(m_session, "Added item: %s [%u]", (*itr)->Name1, (*itr)->ItemId);
			SlotResult * le = chr->GetItemInterface()->LastSearchResult();
			chr->GetSession()->SendItemPushResult(itm,false,true,false,true,le->ContainerSlot,le->Slot,1);
		}
	}
	GreenSystemMessage(m_session, "Added set to inventory complete. Time: %u ms", getMSTime() - start);
	return true;
}

bool ChatHandler::HandleCastTimeCheatCommand(const char* args, WorldSession* m_session)
{
	Player * plyr = getSelectedChar(m_session, true);
	if(!plyr) 
		return true;

	if(!*args) 
		if (plyr->CastTimeCheat) 
			args = "off"; 
		else 
			args = "on";

	if(strcmp(args, "on") == 0)
	{
		plyr->CastTimeCheat = true;
		BlueSystemMessage(m_session, "activated the cast time cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "activated the cast time cheat on you.", m_session->GetPlayer()->GetName());
	}
	else if(strcmp(args, "off") == 0)
	{
		plyr->CastTimeCheat = false;
		BlueSystemMessage(m_session, "deactivated the cast time cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "deactivated the cast time cheat on you.", m_session->GetPlayer()->GetName());
	
		if ( plyr != m_session->GetPlayer() )
			sGMLog.writefromsession(m_session, "god cast time on %s set to %s", plyr->GetName(), args);
	}
	else
		return false;
	return true;
}

bool ChatHandler::HandleCooldownCheatCommand(const char* args, WorldSession* m_session)
{
	Player * plyr = getSelectedChar(m_session, true);
	if(!plyr) 
		return true;

	if(!*args) 
		if (plyr->CooldownCheat) 
			args = "off"; 
		else 
			args = "on";

	if(strcmp(args, "on") == 0)
	{
		plyr->CooldownCheat = true;
		//best case we could simply iterate through cooldowns or create a special function ...
		SpellSet::const_iterator itr = plyr->mSpells.begin();
		for(; itr != plyr->mSpells.end(); ++itr)
		{
			WorldPacket data(12);
			data.SetOpcode(SMSG_CLEAR_COOLDOWN);
			data << (*itr) << plyr->GetGUID();
			plyr->GetSession()->SendPacket(&data);
//			plyr->ClearCooldownForSpell( (*itr) );
		}
		plyr->m_cooldownMap[0].clear();
		plyr->m_cooldownMap[1].clear();
		BlueSystemMessage(m_session, "activated the cooldown cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "activated the cooldown cheat on you.", m_session->GetPlayer()->GetName());
	}
	else if(strcmp(args, "off") == 0)
	{
		plyr->CooldownCheat = false;
		BlueSystemMessage(m_session, "deactivated the cooldown cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "deactivated the cooldown cheat on you.", m_session->GetPlayer()->GetName());
	
		if ( plyr != m_session->GetPlayer() )
			sGMLog.writefromsession(m_session, "cooldown cheat on %s set to %s", plyr->GetName(), args);
	}
	else
		return false;
	return true;
}

bool ChatHandler::HandleGodModeCommand(const char* args, WorldSession* m_session)
{
	Player * plyr = getSelectedChar(m_session, true);
	if(!plyr) 
		return true;

	if(!*args) 
		if (plyr->bInvincible) 
			args = "off"; 
		else 
			args = "on";

	if(strcmp(args, "on") == 0)
	{
		plyr->bInvincible = true;
		BlueSystemMessage(m_session, "activated the god mode cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "activated the god mode cheat on you.", m_session->GetPlayer()->GetName());
	}
	else if(strcmp(args, "off") == 0)
	{
		plyr->bInvincible = false;
		BlueSystemMessage(m_session, "deactivated the god mode cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "deactivated the god mode cheat on you.", m_session->GetPlayer()->GetName());
	
		if ( plyr != m_session->GetPlayer() )
			sGMLog.writefromsession(m_session, "god mode cheat on %s set to %s", plyr->GetName(), args);
	}
	else
		return false;
	return true;
}

bool ChatHandler::HandlePowerCheatCommand(const char* args, WorldSession* m_session)
{
	Player * plyr = getSelectedChar(m_session, true);
	if(!plyr) 
		return true;

	if(!*args) 
		if (plyr->PowerCheat) 
			args = "off"; 
		else 
			args = "on";

	//just reset power status anyway
	for(int i= 0;i<7;i++)
		plyr->SetPower(  i, plyr->GetMaxPower(  i ) );
	if(strcmp(args, "on") == 0)
	{
		plyr->PowerCheat = true;
		BlueSystemMessage(m_session, "activated the power cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "activated the power cheat on you.", m_session->GetPlayer()->GetName());
	}
	else if(strcmp(args, "off") == 0)
	{
		plyr->PowerCheat = false;
		BlueSystemMessage(m_session, "deactivated the power cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "deactivated the power cheat on you.", m_session->GetPlayer()->GetName());
	
		if ( plyr != m_session->GetPlayer() )
			sGMLog.writefromsession(m_session, "power cheat on %s set to %s", plyr->GetName(), args);
	}
	else
		return false;
	return true;
}

bool ChatHandler::HandleShowCheatsCommand(const char* args, WorldSession* m_session)
{
	Player * plyr = getSelectedChar(m_session, true);
	if(!plyr) return true;

	uint32 active = 0, inactive = 0;
#define print_cheat_status(CheatName, CheatVariable) SystemMessage(m_session, "%s%s: %s%s", MSG_COLOR_LIGHTBLUE, CheatName, \
		CheatVariable ? MSG_COLOR_LIGHTRED : MSG_COLOR_GREEN, CheatVariable ? "Active" : "Inactive");  \
		if(CheatVariable) \
		active++; \
		else \
		inactive++; 

	GreenSystemMessage(m_session, "Showing cheat status for: %s", plyr->GetName());
	print_cheat_status("Cooldown", plyr->CooldownCheat);
	print_cheat_status("CastTime", plyr->CastTimeCheat);
	print_cheat_status("GodMode", plyr->bInvincible);
	print_cheat_status("Power", plyr->PowerCheat);
	print_cheat_status("Fly", plyr->FlyCheat);
	print_cheat_status("AuraStack", plyr->AuraStackCheat);
	print_cheat_status("TriggerPass", plyr->TriggerpassCheat);
	SystemMessage(m_session, "%u cheats active, %u inactive.", active, inactive);

#undef print_cheat_status

	return true;
}

bool ChatHandler::HandleFlyCommand(const char* args, WorldSession* m_session)
{
	Player *chr = getSelectedChar(m_session);
	
	if(!chr)
		chr = m_session->GetPlayer();
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() && m_session->GetPlayer()->GetMapMgr() && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 169 && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 994 )
	{
		chr = m_session->GetPlayer();
	}
#endif

	if(!*args) 
		if (chr->FlyCheat) 
			args = "off"; 
		else 
			args = "on";

	if(strcmp(args, "on") == 0)
	{
		chr->EnableFlight();
		chr->m_setflycheat = true;
		BlueSystemMessage(chr->GetSession(), "Flying mode enabled.");
		if(chr != m_session->GetPlayer())
			sGMLog.writefromsession(m_session, "enabled flying mode for %s", chr->GetName());
#ifdef FORCED_GM_TRAINEE_MODE
		HandleFlySpeedCheatCommand("",m_session);
#endif
	}
	else if(strcmp(args, "off") == 0)
	{
		chr->DisableFlight();
		BlueSystemMessage(chr->GetSession(), "Flying mode disabled.");
		if( chr != m_session->GetPlayer() )
			sGMLog.writefromsession( m_session, "disabled flying mode for %s", chr->GetName() );
	}
	else
		return false;
	return true;
}

bool ChatHandler::HandleDBReloadCommand(const char* args, WorldSession* m_session)
{
	char str[200];
	int ret = 0;

	if(!*args || strlen(args) < 3)
		return false;

	uint32 mstime = getMSTime();
	snprintf(str, 200, "%s%s initiated server-side reload of table `%s`. The server may experience some lag while this occurs.",
		MSG_COLOR_LIGHTRED, m_session->GetPlayer()->GetName(), args);
	sWorld.SendWorldText(str, 0);

	if (0 == stricmp(args, "spell_disable"))
	{
		objmgr.ReloadDisabledSpells();
		ret = 1;
	} 
/*	else if (0 == stricmp(args, "spellfixes"))
	{
		objmgr.LoadSpellFixes();
		ret = 1;
	} */
	else if (0 == stricmp(args, "vendors"))
	{
		objmgr.ReloadVendors();
		ret = 1;
	}
	else
	{
		ret = Storage_ReloadTable(args);
	}

	if (ret == 0)
		snprintf(str, 200, "%sDatabase reload failed.", MSG_COLOR_LIGHTRED);
	else
		snprintf(str, 200, "%sDatabase reload completed in %u ms.", MSG_COLOR_LIGHTBLUE, (unsigned int)(getMSTime() - mstime));
	sWorld.SendWorldText(str, 0);
	sGMLog.writefromsession(m_session, "reloaded table %s", args);
	return true;
}

bool ChatHandler::HandleFlySpeedCheatCommand(const char* args, WorldSession* m_session)
{
	float Speed = (float)atof(args);
	if(Speed == 0)
		Speed = 20;

	Player * plr = getSelectedChar(m_session);
	if(plr == 0)
		return true;

	BlueSystemMessage(m_session, "Setting the fly speed of %s to %f.", plr->GetName(), Speed);
	GreenSystemMessage(plr->GetSession(), "%s set your fly speed to %f.", m_session->GetPlayer()->GetName(), Speed);
	if ( plr != m_session->GetPlayer() )
		sGMLog.writefromsession( m_session, "set %s's fly speed to %2.2f", plr->GetName(), Speed );
	
	plr->SetPlayerSpeed( FLY, Speed );
	plr->m_flySpeed = Speed;
	
	return true;
}

bool ChatHandler::HandleModifyLevelCommand(const char* args, WorldSession* m_session)
{
	Player * plr = getSelectedChar(m_session, true);
	if(plr == 0) return true;

	uint32 Level = args ? atol(args) : 0;
	if(Level == 0 || Level > sWorld.m_levelCap)
	{
		RedSystemMessage(m_session, "A level (numeric) is required to be specified after this command.");
		return true;
	}

	// Set level message
	BlueSystemMessage(m_session, "Setting the level of %s to %u.", plr->GetName(), Level);
	GreenSystemMessageToPlr(plr, "%s set your level to %u.", m_session->GetPlayer()->GetName(), Level);

	sGMLog.writefromsession(m_session, "used modify level on %s, level %u", plr->GetName(), Level);

	// lookup level information
	if( Level >= PLAYER_LEVEL_CAP )
	{
		RedSystemMessage(m_session, "Levelup information not found due to out of range level.");
		return true;
	}

	plr->ApplyLevelInfo( Level );
	plr->Event_AchiementCriteria_Received(ACHIEVEMENT_CRITERIA_TYPE_REACH_LEVEL,ACHIEVEMENT_UNUSED_FIELD_VALUE,ACHIEVEMENT_UNUSED_FIELD_VALUE,Level,ACHIEVEMENT_EVENT_ACTION_SET_MAX);
	plr->Reset_Talents();
	return true;
}

bool ChatHandler::HandleCreatePetCommand(const char* args, WorldSession* m_session)
{
/*	if(!args || strlen(args) < 2)
		return false;

	uint32 Entry = atol(args);
	if(!Entry)
		return false;
	CreatureProto * pTemplate = CreatureProtoStorage.LookupEntry(Entry);
	CreatureInfo * pCreatureInfo = CreatureNameStorage.LookupEntry(Entry);
	if(!pTemplate || !pCreatureInfo)
	{
		RedSystemMessage(m_session, "Invalid creature spawn template: %u", Entry);
		return true;
	}
	Player * plr = m_session->GetPlayer();

	// spawn a creature of this id to create from
	Creature * pCreature = new Creature(HIGHGUID_UNIT ,1);//no need in guid
	CreatureSpawn * sp = new CreatureSpawn;
	sp->id = 1;
	sp->bytes = 0;
	sp->bytes2 = 0;
	sp->displayid = pCreatureInfo->Male_DisplayID;
	sp->emote_state = 0;
	sp->entry = pCreatureInfo->Id;
	sp->factionid = pTemplate->Faction;
	sp->flags = 0;
	sp->form = 0;
	sp->movetype = 0;
	sp->o = plr->GetOrientation();
	sp->x = plr->GetPositionX();
	sp->y = plr->GetPositionY();
	//sp->respawnNpcLink = 0;
	sp->stand_state = 0;
	sp->channel_spell=sp->channel_target_creature=sp->channel_target_go=0;
	pCreature->Load(sp, (uint32)NULL, NULL);

	Pet *old_tame = plr->GetSummon();
	if(old_tame != NULL)
	{
		old_tame->Dismiss(true);
	}

	// create a pet from this creature
	Pet * pPet = objmgr.CreatePet();
	pPet->SetInstanceID(plr->GetInstanceID());
	pPet->SetMapId(plr->GetMapId());
	pPet->CreateAsSummon(Entry, pCreatureInfo, pCreature, plr, NULL, 0x2, 0);

	// remove the temp creature
	delete sp;
	delete pCreature;

	sGMLog.writefromsession(m_session, "used create pet entry %u", Entry);
*/
	return true;
}


#ifdef USE_SPECIFIC_AIAGENTS
//this is custom stuff !
bool ChatHandler::HandlePetSpawnAIBot(const char* args, WorldSession *m_session)
{
	if (!*args)
		return false;

	if( !m_session->GetPlayer() )
		return false; //wtf ?

	uint32 botprice = m_session->GetPlayer()->GetUInt32Value(UNIT_FIELD_LEVEL)*10000; //1 gold per level ?

	if( m_session->GetPlayer()->GetGold() < botprice )
	{
		GreenSystemMessage(m_session, "You need a total of %u coins to afford a bot", botprice);
		return false;
	}

	uint8 botType = (uint8)atof((char*)args);

	if ( botType!=0 )
	{
		RedSystemMessage(m_session, "Incorrect value. Accepting value 0 only = healbot :)");
		return true;
	}

	uint32 Entry;
	char name[50];
	uint8 race = m_session->GetPlayer()->getRace();

	if( race == RACE_HUMAN || race == RACE_DWARF || race == RACE_NIGHTELF || race == RACE_GNOME || race == RACE_DRAENEI )
	{
		Entry = 1826;
		strcpy( name, "|cffff6060A_HealBot" );
	}
	else
	{
		Entry = 5473;
		strcpy( name, "|cffff6060H_HealBot" );
	}

	CreatureProto * pTemplate = CreatureProtoStorage.LookupEntry(Entry);
	CreatureInfo * pCreatureInfo = CreatureNameStorage.LookupEntry(Entry);
	if(!pTemplate || !pCreatureInfo)
	{
		RedSystemMessage(m_session, "Invalid creature spawn template: %u", Entry);
		return true;
	}
	Player * plr = m_session->GetPlayer();
	Unit *newguard = plr->create_guardian(Entry,2*60*1000,float(-M_PI*2), plr->getLevel() );
	AiAgentHealSupport *new_interface = new AiAgentHealSupport;
	new_interface->Init(newguard,AITYPE_PET,MOVEMENTTYPE_NONE,plr);
	newguard->ReplaceAIInterface( (AIInterface *) new_interface );

/*	Pet *old_tame = plr->GetSummon();
	if(old_tame != NULL)
	{
		old_tame->Dismiss(true);
	}

	// create a pet from this creature
	Pet * pPet = objmgr.CreatePet();
	pPet->SetInstanceID(plr->GetInstanceID());
	pPet->SetMapId(plr->GetMapId());

	pPet->SetFloatValue ( OBJECT_FIELD_SCALE_X, pTemplate->Scale / 2); //we do not wish to block visualy other players
	AiAgentHealSupport *new_interface = new AiAgentHealSupport;
	pPet->ReplaceAIInterface( (AIInterface *) new_interface );
//	new_interface->Init(pPet,AITYPE_PET,MOVEMENTTYPE_NONE,plr); // i think this will get called automatically for pet

	pPet->CreateAsSummon(Entry, pCreatureInfo, pCreature, plr, NULL, 0x2, 0);

	pPet->Rename(name);

	//healer bot should not have any specific ations
	pPet->SetActionBarSlot(0,PET_SPELL_FOLLOW);
	pPet->SetActionBarSlot(1,PET_SPELL_STAY);
	pPet->SetActionBarSlot(2,0);
	pPet->SetActionBarSlot(3,0);
	pPet->SetActionBarSlot(4,0);
	pPet->SetActionBarSlot(5,0);
	pPet->SetActionBarSlot(6,0);
	pPet->SetActionBarSlot(7,0);
	pPet->SetActionBarSlot(8,0);
	pPet->SetActionBarSlot(9,0);
	pPet->SendSpellsToOwner();

	// remove the temp creature
	delete sp;
	delete pCreature;*/

	sGMLog.writefromsession(m_session, "used create an AI bot");
	return true;
}
#endif

bool ChatHandler::HandleAddPetSpellCommand(const char* args, WorldSession* m_session)
{
	Player * plr = m_session->GetPlayer();
	Pet * pPet = plr->GetSummon();
	if(pPet == 0)
	{
		RedSystemMessage(m_session, "You have no pet.");
		return true;
	}

	uint32 SpellId = atol(args);
	SpellEntry * spell = dbcSpell.LookupEntry(SpellId);
	if(!SpellId || !spell)
	{
		RedSystemMessage(m_session, "Invalid spell id requested.");
		return true;
	}

	pPet->AddSpell(spell, true);
	GreenSystemMessage(m_session, "Added spell %u to your pet.", SpellId);
	return true;
}

bool ChatHandler::HandleRemovePetSpellCommand(const char* args, WorldSession* m_session)
{
	Player * plr = m_session->GetPlayer();
	Pet * pPet = plr->GetSummon();
	if(pPet == 0)
	{
		RedSystemMessage(m_session, "You have no pet.");
		return true;
	}

	uint32 SpellId = atol(args);
	SpellEntry * spell = dbcSpell.LookupEntry(SpellId);
	if(!SpellId || !spell)
	{
		RedSystemMessage(m_session, "Invalid spell id requested.");
		return true;
	}

	pPet->RemoveSpell(SpellId);
	GreenSystemMessage(m_session, "Added spell %u to your pet.", SpellId);
	return true;
}

bool ChatHandler::HandleRenamePetCommand(const char* args, WorldSession* m_session)
{
	Player * plr = m_session->GetPlayer();
	Pet * pPet = plr->GetSummon();
	if(pPet == 0)
	{
		RedSystemMessage(m_session, "You have no pet.");
		return true;
	}

	if(strlen(args) < 1)
	{
		RedSystemMessage(m_session, "You must specify a name.");
		return true;
	}

	GreenSystemMessage(m_session, "Renamed your pet to %s.", args);
	pPet->Rename(args);
	return true;
}

bool ChatHandler::HandleShutdownCommand(const char* args, WorldSession* m_session)
{
	uint32 shutdowntime = atol(args);
	if(!args)
		shutdowntime = 5;

	
	char msg[500];
	snprintf(msg, 500, "%sServer shutdown initiated by %s, shutting down in %u seconds.", MSG_COLOR_LIGHTBLUE,
		m_session->GetPlayer()->GetName(), (unsigned int)shutdowntime);

	sWorld.SendWorldText(msg);
	sGMLog.writefromsession(m_session, "initiated server shutdown timer %u sec", shutdowntime);
	shutdowntime *= 1000;
	sMaster.m_ShutdownTimer = shutdowntime;
	sMaster.m_ShutdownEvent = true;
	sMaster.m_restartEvent = false;
	return true;
}

bool ChatHandler::HandleShutdownRestartCommand(const char* args, WorldSession* m_session)
{
	uint32 shutdowntime = atol(args);
	if(!args)
		shutdowntime = 5;

	char msg[500];
	snprintf(msg, 500, "%sServer restart initiated by %s, shutting down in %u seconds.", MSG_COLOR_LIGHTBLUE,
		m_session->GetPlayer()->GetName(), (unsigned int)shutdowntime);

	sGMLog.writefromsession(m_session, "initiated server restart timer %u sec", shutdowntime);
	sWorld.SendWorldText(msg);
		shutdowntime *= 1000;
	sMaster.m_ShutdownTimer = shutdowntime;
	sMaster.m_ShutdownEvent = true;
	sMaster.m_restartEvent = true;
	return true;
}

bool ChatHandler::HandleAllowWhispersCommand(const char* args, WorldSession* m_session)
{
	if(args == 0 || strlen(args) < 2) return false;
	Player * plr = objmgr.GetPlayer(args, false);
	if(!plr)
	{
		RedSystemMessage(m_session, "Player not found.");
		return true;
	}

	m_session->GetPlayer()->gmTargets.insert(plr);
	BlueSystemMessage(m_session, "Now accepting whispers from %s.", plr->GetName());
	return true;
}

bool ChatHandler::HandleBlockWhispersCommand(const char* args, WorldSession* m_session)
{
	if(args == 0 || strlen(args) < 2) return false;
	Player * plr = objmgr.GetPlayer(args, false);
	if(!plr)
	{
		RedSystemMessage(m_session, "Player not found.");
		return true;
	}

	m_session->GetPlayer()->gmTargets.erase(plr);
	BlueSystemMessage(m_session, "Now blocking whispers from %s.", plr->GetName());
	return true;
}

bool ChatHandler::HandleAdvanceAllSkillsCommand(const char* args, WorldSession* m_session)
{
	uint32 amt = args ? atol(args) : 0;
	if(!amt)
	{
		RedSystemMessage(m_session, "An amount to increment is required.");
		return true;
	}

	Player * plr = getSelectedChar(m_session);
	if(!plr)
		return true;


	plr->_AdvanceAllSkills(amt);
	GreenSystemMessageToPlr(plr, "Advanced all your skill lines by %u points.", amt);
	sGMLog.writefromsession(m_session, "advanced all skills by %u on %s", amt, plr->GetName());
	return true;
}

bool ChatHandler::HandleKillByPlayerCommand(const char* args, WorldSession* m_session)
{
	if(!args || strlen(args) < 2)
	{
		RedSystemMessage(m_session, "A player's name is required.");
		return true;
	}

	sWorld.DisconnectUsersWithPlayerName(args,m_session);
	sGMLog.writefromsession( m_session, "disconnected player %s", args );
	return true;
}

bool ChatHandler::HandleKillBySessionCommand(const char* args, WorldSession* m_session)
{
	if(!args || strlen(args) < 2)
	{
		RedSystemMessage(m_session, "A player's name is required.");
		return true;
	}

	sWorld.DisconnectUsersWithAccount(args,m_session);
	sGMLog.writefromsession( m_session, "disconnected player with account %s", args );
	return true;
}
bool ChatHandler::HandleKillByIPCommand(const char* args, WorldSession* m_session)
{
	if(!args || strlen(args) < 2)
	{
		RedSystemMessage(m_session, "An IP is required.");
		return true;
	}

	sWorld.DisconnectUsersWithIP(args,m_session);
	sGMLog.writefromsession( m_session, "disconnected players with IP %s", args );
	return true;
}

bool ChatHandler::HandleMassSummonCommand(const char* args, WorldSession* m_session)
{
	PlayerStorageMap::const_iterator itr;
	objmgr._playerslock.AcquireReadLock();
	Player * summoner = m_session->GetPlayer();
	Player * plr;
	uint32 c=0;
	for (itr = objmgr._players.begin(); itr != objmgr._players.end(); itr++)
	{
		plr = itr->second;
		if(plr->GetSession() && plr->IsInWorld())
		{
			//plr->SafeTeleport(summoner->GetMapId(), summoner->GetInstanceID(), summoner->GetPosition());
			/* let's do this the blizz way */
			plr->SummonRequest(summoner->GetLowGUID(), summoner->GetZoneId(), summoner->GetMapId(), summoner->GetInstanceID(), summoner->GetPosition());
			++c;
		}
	}
	sGMLog.writefromsession(m_session, "requested a mass summon of %u players.", c);
	objmgr._playerslock.ReleaseReadLock();
	return true;
}

bool ChatHandler::HandleCastAllCommand(const char* args, WorldSession* m_session)
{
	if(!args || strlen(args) < 2)
	{
		RedSystemMessage(m_session, "No spellid specified.");
		return true;
	}
	Player * plr;
	uint32 spellid = atol(args);
	SpellEntry * info = dbcSpell.LookupEntry(spellid);
	if(!info)
	{
		RedSystemMessage(m_session, "Invalid spell specified.");
		return true;
	}

	// this makes sure no moron casts a learn spell on everybody and wrecks the server
	for (int i = 0; i < 3; i++)
	{
		if (info->eff[i].Effect == 36) //SPELL_EFFECT_LEARN_SPELL - 36
		{
			sGMLog.writefromsession(m_session, "used wrong / learnall castall command, spellid %u", spellid);
			RedSystemMessage(m_session, "Learn spell specified.");
			return true;
		}
	}

	sGMLog.writefromsession(m_session, "used castall command, spellid %u", spellid);

	PlayerStorageMap::const_iterator itr;
	objmgr._playerslock.AcquireReadLock();
	for (itr = objmgr._players.begin(); itr != objmgr._players.end(); itr++)
	{
		plr = itr->second;
		if(plr->GetSession() && plr->IsInWorld())
		{
			if(plr->GetMapMgr() != m_session->GetPlayer()->GetMapMgr())
			{
				sEventMgr.AddEvent( SafeUnitCast( plr ), &Unit::EventCastSpell2, SafeUnitCast( plr )->GetGUID(), info->Id, true, EVENT_PLAYER_CHECKFORCHEATS, 100, 1,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT );
			}
			else
			{
				Spell * sp = SpellPool.PooledNew( __FILE__, __LINE__ );
				sp->Init(plr, info, true, 0);
				SpellCastTargets targets(plr->GetGUID());
				sp->prepare(&targets);
			}
		}
	}
	objmgr._playerslock.ReleaseReadLock();

	BlueSystemMessage(m_session, "Casted spell %u on all players!", spellid);
	return true;
}

bool ChatHandler::HandleNpcReturnCommand(const char* args, WorldSession* m_session)
{
	Creature * creature = getSelectedCreature(m_session);
	if(!creature || !creature->m_spawn) return true;

	// return to respawn coords
	float x = creature->m_spawn->x;
	float y = creature->m_spawn->y;
	float z = creature->m_spawn->z;
	float o = creature->m_spawn->o;
	
	// restart movement
	creature->GetAIInterface()->SetAIState(STATE_IDLE);
	creature->GetAIInterface()->WipeHateList();
	creature->GetAIInterface()->WipeTargetList();
	creature->GetAIInterface()->MoveTo(x, y, z, o);

	sGMLog.writefromsession( m_session, "returned NPC %s, sqlid %u", creature->GetCreatureInfo()->Name, creature->GetSQL_id() );

	return true;
}

bool ChatHandler::HandleModPeriodCommand(const char* args, WorldSession * m_session)
{
	Transporter * trans = m_session->GetPlayer()->m_CurrentTransporter;
	if(trans == 0)
	{
		RedSystemMessage(m_session, "You must be on a transporter.");
		return true;
	}

	uint32 np = args ? atol(args) : 0;
	if(np == 0)
	{
		RedSystemMessage(m_session, "A time in ms must be specified.");
		return true;
	}

	trans->SetPeriod(np);
	BlueSystemMessage(m_session, "Period of %s set to %u.", trans->GetInfo()->Name, np);
	return true;
}

bool ChatHandler::HandleFormationLink1Command(const char* args, WorldSession * m_session)
{
	// set formation "master"
	Creature * pCreature = getSelectedCreature(m_session, true);
	if(pCreature == 0) return true;

	m_session->GetPlayer()->linkTarget = pCreature;
	BlueSystemMessage(m_session, "Linkup \"master\" set to %s.", pCreature->GetCreatureInfo()->Name);
	return true;
}

bool ChatHandler::HandleFormationLink2Command(const char* args, WorldSession * m_session)
{
	// set formation "slave" with distance and angle
	float ang, dist;
	if(*args == 0 || sscanf(args, "%f %f", &dist, &ang) != 2)
	{
		RedSystemMessage(m_session, "You must specify a distance and angle.");
		return true;
	}

	if(m_session->GetPlayer()->linkTarget == 0 || m_session->GetPlayer()->linkTarget->GetTypeId() != TYPEID_UNIT)
	{
		RedSystemMessage(m_session, "Master not selected. select the master, and use formationlink1.");
		return true;
	}

	Creature * slave = getSelectedCreature(m_session, true);
	if(slave == 0) return true;

	slave->GetAIInterface()->m_formationFollowDistance = dist;
	slave->GetAIInterface()->m_formationFollowAngle = ang;
	slave->GetAIInterface()->m_formationLinkTarget = SafeCreatureCast( m_session->GetPlayer()->linkTarget );
	slave->GetAIInterface()->m_formationLinkSqlId = slave->GetAIInterface()->m_formationLinkTarget->GetSQL_id();
	slave->GetAIInterface()->SetUnitToFollowAngle(ang);
	
	// add to db
	WorldDatabase.Execute("INSERT INTO creature_formations VALUES(%u, %u, '%f', '%f')", 
		slave->GetSQL_id(), slave->GetAIInterface()->m_formationLinkSqlId, ang, dist);

	BlueSystemMessage(m_session, "%s linked up to %s with a distance of %f at %f radians.", slave->GetCreatureInfo()->Name, 
		SafeCreatureCast( m_session->GetPlayer()->linkTarget )->GetCreatureInfo()->Name, dist, ang );

	return true;
}

bool ChatHandler::HandleNpcFollowCommand(const char* args, WorldSession * m_session)
{
	Creature * creature = getSelectedCreature(m_session, true);
	if(!creature) return true;

	creature->GetAIInterface()->SetUnitToFollow(m_session->GetPlayer());

	sGMLog.writefromsession( m_session, "used npc follow command on %s, sqlid %u", creature->GetCreatureInfo()->Name, creature->GetSQL_id() );
	return true;
}

bool ChatHandler::HandleFormationClearCommand(const char* args, WorldSession * m_session)
{
	Creature * c = getSelectedCreature(m_session, true);
	if(!c) return true;

	c->GetAIInterface()->m_formationLinkSqlId = 0;
	c->GetAIInterface()->m_formationLinkTarget = 0;
	c->GetAIInterface()->m_formationFollowAngle = 0.0f;
	c->GetAIInterface()->m_formationFollowDistance = 0.0f;
	c->GetAIInterface()->SetUnitToFollow(0);
	
	WorldDatabase.Execute("DELETE FROM creature_formations WHERE spawn_id=%u", c->GetSQL_id());
	return true;
}

bool ChatHandler::HandleNullFollowCommand(const char* args, WorldSession * m_session)
{
	Creature * c = getSelectedCreature(m_session, true);
	if(!c) return true;

	// restart movement
	c->GetAIInterface()->SetAIState(STATE_IDLE);
	c->GetAIInterface()->SetUnitToFollow(0);

	sGMLog.writefromsession( m_session, "cancelled npc follow command on %s, sqlid %u", c->GetCreatureInfo()->Name, c->GetSQL_id() );
	return true;
}

bool ChatHandler::HandleAuraStackCheatCommand(const char* args, WorldSession * m_session)
{
	Player * plyr = getSelectedChar(m_session, true);
	if(!plyr) 
		return true;

	if(!*args) 
		if (plyr->AuraStackCheat)
			args = "off"; 
		else 
			args = "on";

	if(strcmp(args, "on") == 0)
	{
		plyr->AuraStackCheat = true;
		BlueSystemMessage(m_session, "activated the aura stack cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "activated the aura stack cheat on you.", m_session->GetPlayer()->GetName());
	}
	else if(strcmp(args, "off") == 0)
	{
		plyr->AuraStackCheat = false;
		BlueSystemMessage(m_session, "deactivated the aura stack cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "deactivated the aura stack cheat on you.", m_session->GetPlayer()->GetName());
	
		if ( plyr != m_session->GetPlayer() )
			sGMLog.writefromsession(m_session, "aura stack cheat on %s set to %s", plyr->GetName(), args);
	}
	else
		return false;
	return true;
}

bool ChatHandler::HandleTriggerpassCheatCommand(const char* args, WorldSession * m_session)
{
	Player * plyr = getSelectedChar(m_session, true);
	if(!plyr) 
		return true;

	if(!*args) 
		if (plyr->TriggerpassCheat) 
			args = "off"; 
		else 
			args = "on";

	if(strcmp(args, "on") == 0)
	{
		plyr->TriggerpassCheat = true;
		BlueSystemMessage(m_session, "activated the triggerpass cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "activated the triggerpass cheat on you.", m_session->GetPlayer()->GetName());
	}
	else if(strcmp(args, "off") == 0)
	{
		plyr->TriggerpassCheat = false;
		BlueSystemMessage(m_session, "deactivated the triggerpass cheat on %s.", plyr->GetName());
		GreenSystemMessageToPlr(plyr, "deactivated the triggerpass cheat on you.", m_session->GetPlayer()->GetName());
	
		if ( plyr != m_session->GetPlayer() )
			sGMLog.writefromsession(m_session, "triggerpass cheat on %s set to %s", plyr->GetName(), args);
	}
	else
		return false;
	return true;
}

bool ChatHandler::HandleResetSkillsCommand(const char* args, WorldSession * m_session)
{
	skilllineentry * se;
	Player * plr = getSelectedChar(m_session, true);
	if(!plr) return true;

	plr->_RemoveAllSkills();

	// Load skills from create info.
	PlayerCreateInfo * info = objmgr.GetPlayerCreateInfo(plr->getRace(), plr->getClass());
	if(!info) return true;

	for(std::list<CreateInfo_SkillStruct>::iterator ss = info->skills.begin(); ss!=info->skills.end(); ss++)
	{
		se = dbcSkillLine.LookupEntry(ss->skillid);
		if(se->type != SKILL_TYPE_LANGUAGE && ss->skillid && ss->currentval && ss->maxval)
			plr->_AddSkillLine(ss->skillid, ss->currentval, ss->maxval);		
	}
	//Chances depend on stats must be in this order!
	plr->UpdateStats();
	plr->UpdateChances();
	plr->_UpdateMaxSkillCounts();
	plr->_AddLanguages(false);
	BlueSystemMessage(m_session, "Reset skills to default.");
	sGMLog.writefromsession(m_session, "reset skills of %s to default", plr->GetName());
	return true;
}

bool ChatHandler::HandlePlayerInfo(const char* args, WorldSession * m_session)
{
	Player * plr;
	if(strlen(args) >= 2) // char name can be 2 letters
	{
		plr = objmgr.GetPlayer(args, false);
		if(!plr)
		{
			RedSystemMessage(m_session, "Unable to locate player %s.", args);		
			return true;
		}
	}
	else
		plr = getSelectedChar(m_session, true);
	
	if(!plr) return true;
	if(!plr->GetSession())
	{
		RedSystemMessage(m_session, "ERROR: this player hasn't got any session !");
		return true;
	}
	if(!plr->GetSession()->GetSocket())
	{
		RedSystemMessage(m_session, "ERROR: this player hasn't got any socket !");
		return true;
	}
	WorldSession* sess = plr->GetSession();

//	char* infos = new char[128];
	static const char* classes[12] =
	{"None","Warrior", "Paladin", "Hunter", "Rogue", "Priest", "DeathKnight", "Shaman", "Mage", "Warlock", "None", "Druid"};
	static const char* races[12] =
	{"None","Human","Orc","Dwarf","Night Elf","Undead","Tauren","Gnome","Troll","None","Blood Elf","Draenei"};

	char playedLevel[64];
	char playedTotal[64];

	int seconds = (plr->GetPlayedtime())[0];
	int mins=0;
	int hours=0;
	int days=0;
	if(seconds >= 60)
	{
		mins = seconds / 60;
		if(mins)
		{
			seconds -= mins*60;
			if(mins >= 60)
			{
				hours = mins / 60;
				if(hours)
				{
					mins -= hours*60;
					if(hours >= 24)
					{
						days = hours/24;
						if(days)
							hours -= days*24;
					}
				}
			}
		}
	}
	snprintf(playedLevel, 64, "[%d days, %d hours, %d minutes, %d seconds]", days, hours, mins, seconds);

	seconds = (plr->GetPlayedtime())[1];
	mins=0;
	hours=0;
	days=0;
	if(seconds >= 60)
	{
		mins = seconds / 60;
		if(mins)
		{
			seconds -= mins*60;
			if(mins >= 60)
			{
				hours = mins / 60;
				if(hours)
				{
					mins -= hours*60;
					if(hours >= 24)
					{
						days = hours/24;
						if(days)
							hours -= days*24;
					}
				}
			}
		}
	}
	snprintf(playedTotal, 64, "[%d days, %d hours, %d minutes, %d seconds]", days, hours, mins, seconds);

	GreenSystemMessage(m_session, "%s is a %s %s %s", plr->GetName(),
		(plr->getGender()?"Female":"Male"), races[plr->getRace()], classes[plr->getClass()]);

	BlueSystemMessage(m_session, "%s has played %s at this level",(plr->getGender()?"She":"He"), playedLevel);
	BlueSystemMessage(m_session, "and %s overall", playedTotal);

	BlueSystemMessage(m_session, "%s is connecting from account '%s'[%u] with permissions '%s'",
		(plr->getGender()?"She":"He"), sess->GetAccountName().c_str(), sess->GetAccountId(), sess->GetPermissions());

	BlueSystemMessage(m_session, "%s uses %s (build %u)", (plr->getGender()?"She":"He"),
		(sess->HasFlag(ACCOUNT_FLAG_XPACK_01)?"WoW Burning Crusade":"WoW"), sess->GetClientBuild());

	BlueSystemMessage(m_session, "%s uses %s (build %u)", (plr->getGender()?"She":"He"),
		(sess->HasFlag(ACCOUNT_FLAG_XPACK_02)?"WOTLK":"WoW"), sess->GetClientBuild());

	BlueSystemMessage(m_session, "%s IP is '%s', and has a latency of %ums", (plr->getGender()?"Her":"His"),
		sess->GetSocket()->GetRemoteIP().c_str(), sess->GetLatency());

	sGMLog.writefromsession(m_session, "queried playerinfo on %s", plr->GetName());
	return true;
}

bool ChatHandler::HandleGlobalPlaySoundCommand(const char* args, WorldSession * m_session)
{
	if(!*args) return false;
	uint32 sound = atoi(args);
	if(!sound) return false;

	WorldPacket data(SMSG_PLAY_SOUND, 4);
	data << sound;
	sWorld.SendGlobalMessage(&data, 0);
	BlueSystemMessage(m_session, "Broadcasted sound %u to server.", sound);
	sGMLog.writefromsession(m_session, "used play all command soundid %u", sound);
	return true;
}

bool ChatHandler::HandleIPBanCommand(const char * args, WorldSession * m_session)
{
	char * pIp = (char*)args;
	char * pDuration = strchr(pIp, ' ');
	if(pDuration == NULL)
		return false;
	*pDuration = 0;
	++pDuration;

	int32 timeperiod = GetTimePeriodFromString(pDuration);
	if(timeperiod < 1)
		return false;

	uint32 o1, o2, o3, o4;
	if ( sscanf(pIp, "%3u.%3u.%3u.%3u", (unsigned int*)&o1, (unsigned int*)&o2, (unsigned int*)&o3, (unsigned int*)&o4) != 4
			|| o1 > 255 || o2 > 255 || o3 > 255 || o4 > 255)
	{
		RedSystemMessage(m_session, "Invalid IPv4 address [%s]", pIp);
		return true;	// error in syntax, but we wont remind client of command usage
	}

	time_t expire_time;
	if ( timeperiod == 0)		// permanent ban
		expire_time = 0;
	else
		expire_time = UNIXTIME + (time_t)timeperiod;
	string IP = pIp;
	string::size_type i = IP.find("/");
	if (i == string::npos)
	{
		RedSystemMessage(m_session, "Lack of CIDR address assumes a 32bit match (if you don't understand, dont worry, it worked)");
		IP.append("/32");
		pIp = (char*)IP.c_str(); //is this correct? - optical
	}

	//temporal IP or real pro flooder who will change it tomorrow ?
	char emptystring = 0;
	char * pReason = strchr(pDuration+1, ' ');
	if( pReason == NULL )
	{
//		pReason = &emptystring;
		SystemMessage(m_session, "You need to specify a ban reason");
		return true;
	}

	char reason_buf[5000];
	sprintf(reason_buf,"GM %s at %s : %s",m_session->GetPlayer()->GetName(), ctime( &expire_time ), pReason );

	SystemMessage(m_session, "Adding [%s] to IP ban table, expires %s.Reason is :%s", pIp, (expire_time == 0)? "Never" : ctime( &expire_time ),pReason);
	sLogonCommHandler.IPBan_Add( pIp, (uint32)expire_time, reason_buf );
	sWorld.DisconnectUsersWithIP(IP.substr(0,IP.find("/")).c_str(), m_session);
	sGMLog.writefromsession(m_session, "banned ip address %s, expires %s", pIp, (expire_time == 0)? "Never" : ctime( &expire_time ));
	return true;
}

bool ChatHandler::HandleIPUnBanCommand(const char * args, WorldSession * m_session)
{
	string pIp = args;
	if (pIp.length() == 0)
		return false;

	if (pIp.find("/") == string::npos)
	{
		RedSystemMessage(m_session, "Lack of CIDR address assumes a 32bit match (if you don't understand, dont worry, it worked)");
		pIp.append("/32");
	}
	/**
	 * We can afford to be less fussy with the validty of the IP address given since
	 * we are only attempting to remove it.
	 * Sadly, we can only blindly execute SQL statements on the logonserver so we have
	 * no idea if the address existed and so the account/IPBanner cache requires reloading.
	 */

	SystemMessage(m_session,"Deleting [%s] from ip ban table if it exists",pIp.c_str());
	sLogonCommHandler.IPBan_Remove( pIp.c_str() );
	sGMLog.writefromsession(m_session, "unbanned ip address %s", pIp.c_str());
	return true;
}
bool ChatHandler::HandleCreatureSpawnCommand(const char *args, WorldSession *m_session)
{
	uint32 entry = atol(args);
	if(entry == 0)
		return false;

	CreatureProto * proto = CreatureProtoStorage.LookupEntry(entry);
	CreatureInfo * info = CreatureNameStorage.LookupEntry(entry);
	if(proto == 0 || info == 0)
	{
		RedSystemMessage(m_session, "Invalid entry id.");
		return true;
	}

	CreatureSpawn * sp = new CreatureSpawn;
	//sp->displayid = info->DisplayID;
	info->GenerateModelId(&sp->displayid);
	sp->entry = entry;
//	sp->proto = proto;
	sp->form = NULL;
	sp->id = objmgr.GenerateCreatureSpawnID();
	sp->movetype = 0;
	sp->x = m_session->GetPlayer()->GetPositionX();
	sp->y = m_session->GetPlayer()->GetPositionY();
	sp->z = m_session->GetPlayer()->GetPositionZ();
	sp->o = m_session->GetPlayer()->GetOrientation();
	sp->emote_state = 0;
	sp->flags = 0;
	sp->factionid = proto->Faction;
	sp->bytes0 = 0;
	sp->bytes1 = 0;
	sp->bytes2 = 0;
	//sp->respawnNpcLink = 0;
	sp->stand_state = 0;
//	sp->channel_spell=sp->channel_target_creature=sp->channel_target_go=0;
	sp->Item1SlotDisplay = sp->Item2SlotDisplay = sp->Item3SlotDisplay = 0;
	sp->MountedDisplayID = 0;
	sp->difficulty_spawnmask = 65535;
	sp->phase = 2147483647;


	Creature * p ;
//m_session->GetPlayer()->GetMapMgr()->m_CreatureHighGuid = 0x00223332;
	p = m_session->GetPlayer()->GetMapMgr()->CreateCreature(entry);
//p->SetNewGuid( 0x22334455 );
	ASSERT(p);
	p->Load(sp, (uint32)NULL, NULL);
	p->PushToWorld(m_session->GetPlayer()->GetMapMgr());
	
	uint32 x = m_session->GetPlayer()->GetMapMgr()->GetPosX(m_session->GetPlayer()->GetPositionX());
	uint32 y = m_session->GetPlayer()->GetMapMgr()->GetPosY(m_session->GetPlayer()->GetPositionY());

	// Add spawn to map
	m_session->GetPlayer()->GetMapMgr()->GetBaseMap()->GetSpawnsListAndCreate(
		x,
		y)->CreatureSpawns.push_back(sp);

	BlueSystemMessage(m_session, "Spawned a creature `%s` with entry %u at %f %f %f on map %u", info->Name, 
		entry, sp->x, sp->y, sp->z, m_session->GetPlayer()->GetMapId());

	// Save it to the database.
	p->SaveToDB();

	sGMLog.writefromsession(m_session, "spawned a %s (%d) at %u %f %f %f", info->Name, info->Id, m_session->GetPlayer()->GetMapId(),sp->x,sp->y,sp->z);

	return true;
}

bool ChatHandler::HandleRemoveItemCommand(const char * args, WorldSession * m_session)
{
	uint32 item_id;
	int32 count, ocount;
	int argc = sscanf(args, "%u %u", (unsigned int*)&item_id, (unsigned int*)&count);
	if(argc == 1)
		count = 1;
	else if(argc != 2 || !count)
		return false;

	ocount = count;
	Player * plr = getSelectedChar(m_session, true);
	if(!plr) return true;

	// loop until they're all gone.
	int32 loop_count = 0;
	int32 start_count = plr->GetItemInterface()->GetItemCount(item_id, true);
	int32 start_count2 = start_count;
	if(count > start_count)
		count = start_count;

	while(start_count >= count && (count > 0) && loop_count < 20)	 // Prevent a loop here.
	{
		plr->GetItemInterface()->RemoveItemAmt(item_id, count);
		start_count2 = plr->GetItemInterface()->GetItemCount(item_id, true);
		count -= (start_count - start_count2);
		start_count = start_count2;
		++loop_count;
	}

	ItemPrototype * iProto	= ItemPrototypeStorage.LookupEntry(item_id);

	if( iProto )
	{
		sGMLog.writefromsession(m_session, "used remove item %s (id: %u) count %u from %s", iProto->Name1, item_id, ocount, plr->GetName());
		BlueSystemMessage(m_session, "Removing %u copies of item %s (id: %u) from %s's inventory.", ocount, GetItemLinkByProto(iProto, m_session->language).c_str(), item_id, plr->GetName());
		BlueSystemMessage(plr->GetSession(), "%s removed %u copies of item %s from your inventory.", m_session->GetPlayer()->GetName(), ocount, GetItemLinkByProto(iProto, plr->GetSession()->language).c_str());
	}
	else RedSystemMessage(m_session, "Cannot remove non valid item id: %u .",item_id);

	return true;
}

bool ChatHandler::HandleForceRenameCommand(const char * args, WorldSession * m_session)
{
	// prevent buffer overflow
	if(strlen(args) > 100)
		return false;

	string tmp = string(args);
	if( strlen( tmp.c_str() ) < 2 )
	{
		Player* target = m_session->GetPlayer()->GetMapMgr()->GetPlayer( m_session->GetPlayer()->GetSelection() );
		if( target )
			tmp = target->GetName();
	}
	PlayerInfo * pi;
	pi = objmgr.GetPlayerInfoByName(tmp.c_str());
	if(pi == 0)
	{
		RedSystemMessage(m_session, "Player with %s name not found.", tmp.c_str() );
		return true;
	}

	Player * plr = objmgr.GetPlayer((uint32)pi->guid);
	if(plr == 0)
	{
		CharacterDatabase.Execute("UPDATE characters SET forced_rename_pending = 1 WHERE guid = %u", (uint32)pi->guid);
	}
	else
	{
		plr->rename_pending = true;
		plr->SaveToDB(false);
		BlueSystemMessageToPlr(plr, "%s forced your character to be renamed next logon.", m_session->GetPlayer()->GetName());
	}

	CharacterDatabase.Execute("INSERT INTO banned_names VALUES('%s')", CharacterDatabase.EscapeString(string(pi->name)).c_str());
	GreenSystemMessage(m_session, "Forcing %s to rename his character next logon.", tmp.c_str() );
	sGMLog.writefromsession(m_session, "forced %s to rename his charater (%u)", pi->name, pi->guid);
	return true;
}

bool ChatHandler::HandleGetStandingCommand(const char * args, WorldSession * m_session)
{
	uint32 faction = atoi(args);
	Player * plr = getSelectedChar(m_session, true);
	if(!plr) return true;

	int32 standing = plr->GetStanding(faction);
	int32 bstanding = plr->GetBaseStanding(faction);

	GreenSystemMessage(m_session, "Reputation for faction %u:", faction);
	SystemMessage(m_session, "Base Standing: %d", bstanding);
	BlueSystemMessage(m_session, "Standing: %d", standing);
	return true;
}

bool ChatHandler::HandleSetStandingCommand(const char * args, WorldSession * m_session)
{
	uint32 faction;
	int32 standing;
	if(sscanf(args, "%u %d", (unsigned int*)&faction, (unsigned int*)&standing) != 2)
		return false;
	Player * plr = getSelectedChar(m_session, true);
	if(!plr) return true;;

	BlueSystemMessage(m_session, "Setting standing of %u to %d on %s.", faction, standing, plr->GetName());
	plr->SetStanding(faction, standing);
	GreenSystemMessageToPlr(plr, "%s set your standing of faction %u to %d.", m_session->GetPlayer()->GetName(), faction, standing);
	sGMLog.writefromsession(m_session, "set standing of faction %u to %u for %s", faction,standing,plr->GetName());
	return true;
}

void SendHighlightedName(WorldSession * m_session, const char* prefix, char* full_name, string& lowercase_name, string& highlight, uint32 id)
{
	char message[1024];
	char start[50];
	start[0] = message[0] = 0;

	snprintf(start, 50, "%s %u: %s", prefix, (unsigned int)id, MSG_COLOR_WHITE);

	string::size_type hlen = highlight.length();
	string fullname = string(full_name);
	string::size_type offset = lowercase_name.find(highlight);
	string::size_type remaining = fullname.size() - offset - hlen;
	strcat(message, start);
	strncat(message, fullname.c_str(), offset);
	strcat(message, MSG_COLOR_LIGHTRED);
	strncat(message, (fullname.c_str() + offset), hlen);
	strcat(message, MSG_COLOR_WHITE);
	if(remaining > 0) strncat(message, (fullname.c_str() + offset + hlen), remaining);

	sChatHandler.SystemMessage(m_session, message);
}

void SendItemLinkToPlayer(ItemPrototype * iProto, WorldSession * pSession, bool ItemCount, Player * owner = NULL, uint32 language = NULL)
{
	if(!iProto || !pSession)
		return;
	if(ItemCount && owner == NULL)
		return;
		
 	if(ItemCount)
	{
		int16 count = (int16)(owner->GetItemInterface()->GetItemCount(iProto->ItemId, true));
		int16 slot = owner->GetItemInterface()->GetBagSlotByGuid(iProto->ItemId);
		sChatHandler.SystemMessage(pSession,"Item %u %s Count %u Slot %u ContainerSlots %u", iProto->ItemId, GetItemLinkByProto(iProto, language).c_str(), count, slot, iProto->ContainerSlots);
	}
 	else
		sChatHandler.SystemMessage(pSession,"Item %u %s ContainerSlots %u", iProto->ItemId, GetItemLinkByProto(iProto, language).c_str(), iProto->ContainerSlots);
}


bool ChatHandler::HandleLookupItemCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	string x = string(args);
	arcemu_TOLOWER(x);
	if(x.length() < 4)
	{
		RedSystemMessage(m_session, "Your search string must be at least 5 characters long.");
		return true;
	}

	BlueSystemMessage(m_session, "Starting search of item `%s`...", x.c_str());
	uint32 t = getMSTime();
	ItemPrototype * it;
	uint32 count = 0;

	StorageContainerIterator<ItemPrototype> * itr = ItemPrototypeStorage.MakeIterator();

	while(!itr->AtEnd())
	{
		it = itr->Get();
		LocalizedItem *lit	= (m_session->language>0) ? sLocalizationMgr.GetLocalizedItem(it->ItemId, m_session->language) : NULL;

		std::string litName	= std::string(lit ? lit->Name : "");
		
		arcemu_TOLOWER(litName);
		
		bool localizedFound	= false;
		if(FindXinYString(x, litName))
			localizedFound	= true;

		if(FindXinYString(x, it->lowercase_name) || localizedFound)
		{
			// Print out the name in a cool highlighted fashion
			//SendHighlightedName(m_session, it->Name1, it->lowercase_name, x, it->ItemId, true);
			SendItemLinkToPlayer(it, m_session, false, 0, localizedFound ? m_session->language : 0);
			++count;
			if(count == 25)
			{
				RedSystemMessage(m_session, "More than 25 results returned. aborting.");
				break;
			}
		}
		
		if(!itr->Inc())
			break;
	}
	itr->Destruct();

	BlueSystemMessage(m_session, "Search completed in %u ms.", getMSTime() - t);
	return true;
}

bool ChatHandler::HandleLookupObjectCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	string x = string(args);
	arcemu_TOLOWER(x);

	StorageContainerIterator<GameObjectInfo> * itr = GameObjectNameStorage.MakeIterator();

	GreenSystemMessage(m_session, "Starting search of object `%s`...", x.c_str());
	uint32 t = getMSTime();
	GameObjectInfo * i;
	uint32 count = 0;
	string y;
	string recout;
	while(!itr->AtEnd())
	{
		i = itr->Get();
		y = string(i->Name);
		arcemu_TOLOWER(y);
		if(FindXinYString(x,y))
		{
			//string objectID=MyConvertIntToString(i->ID);
			string Name;
			std::stringstream strm;
			strm<<i->ID;
			//string ObjectID = i.c_str();
			const char*objectName=i->Name;
			recout="|cfffff000Object ";
			recout+=strm.str();
			recout+="|cffFFFFFF: ";
			recout+=objectName;
			recout = recout + Name;
			SendMultilineMessage(m_session,recout.c_str());
			++count;
			if(count==50 || count > 50)
			{
				RedSystemMessage(m_session,"More than 50 results returned. aborting.");
				break;
			}
		}
		if(!itr->Inc()) break;
	}
	itr->Destruct();
	if (count==0)
	{
		recout="|cff00ccffNo matches found.";
		SendMultilineMessage(m_session,recout.c_str());
	}
	BlueSystemMessage(m_session,"Search completed in %u ms.",getMSTime()-t);
	return true;
}
bool ChatHandler::HandleLookupCreatureCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	string x = string(args);
	arcemu_TOLOWER(x);
	if(x.length() < 4)
	{
		RedSystemMessage(m_session, "Your search string must be at least 5 characters long.");
		return true;
	}

	StorageContainerIterator<CreatureInfo> * itr = CreatureNameStorage.MakeIterator();

	GreenSystemMessage(m_session, "Starting search of creature `%s`...", x.c_str());
	uint32 t = getMSTime();
	CreatureInfo * i;
	uint32 count = 0;
	while(!itr->AtEnd())
	{
		i = itr->Get();
		LocalizedCreatureName *li	= (m_session->language>0) ? sLocalizationMgr.GetLocalizedCreatureName(i->Id, m_session->language) : NULL;

		std::string liName	= std::string(li ? li->Name : "");
		
		arcemu_TOLOWER(liName);
		
		bool localizedFound	= false;

		if(FindXinYString(x, liName))
			localizedFound	= true;

		if(FindXinYString(x, i->lowercase_name) || localizedFound)
 		{
 			// Print out the name in a cool highlighted fashion
			SendHighlightedName(m_session, "Creature", localizedFound ? li->Name : i->Name, localizedFound ? liName : i->lowercase_name, x, i->Id);
			++count;
			if(count == 25)
			{
				RedSystemMessage(m_session, "More than 25 results returned. aborting.");
				break;
			}
		}
		if(!itr->Inc())
			break;
	}
	itr->Destruct();

	GreenSystemMessage(m_session, "Search completed in %u ms.", getMSTime() - t);
	return true;
}

bool ChatHandler::HandleLookupSpellCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	string x = string(args);
	arcemu_TOLOWER(x);
	if(x.length() < 4)
	{
		RedSystemMessage(m_session, "Your search string must be at least 5 characters long.");
		return true;
	}

	GreenSystemMessage(m_session, "Starting search of spell `%s`...", x.c_str());
	uint32 t = getMSTime();
	uint32 count = 0;
	string recout;
	char itoabuf[200];
	for (uint32 index = 0; index < dbcSpell.GetNumRows(); ++index)
	{
		SpellEntry* spell = dbcSpell.LookupRow(index);
		string y = string(spell->Name);
		arcemu_TOLOWER(y);
		if(FindXinYString(x, y))
 		{
 			// Print out the name in a cool highlighted fashion
			// SendHighlightedName(m_session, "Spell", spell->Name, y, x, spell->Id);
			// Send spell link instead
			sprintf((char*)itoabuf,"%u",spell->Id);
			recout = (char*)itoabuf;
			recout += ": |cff71d5ff|Hspell:";
			recout += (char*)itoabuf;
			recout += "|h[";
			recout += spell->Name;
			recout += "]|h|r";
			SendMultilineMessage(m_session, recout.c_str());
			
			++count;
			if(count == 25)
			{
				RedSystemMessage(m_session, "More than 25 results returned. aborting.");
				break;
			}
		}
	}
	
	GreenSystemMessage(m_session, "Search completed in %u ms.", getMSTime() - t);
	return true;
}

bool ChatHandler::HandleLookupSkillCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	string x = string(args);
	arcemu_TOLOWER(x);
	if(x.length() < 4)
	{
		RedSystemMessage(m_session, "Your search string must be at least 5 characters long.");
		return true;
	}

	GreenSystemMessage(m_session, "Starting search of skill `%s`...", x.c_str());
	uint32 t = getMSTime();
	uint32 count = 0;
	for (uint32 index = 0; index < dbcSkillLine.GetNumRows(); ++index)
	{
		skilllineentry* skill = dbcSkillLine.LookupRow(index);
		string y = string(skill->Name);
		arcemu_TOLOWER(y);
		if(FindXinYString(x, y))
 		{
 			// Print out the name in a cool highlighted fashion
			SendHighlightedName(m_session, "Skill", skill->Name, y, x, skill->id);
			++count;
			if(count == 25)
			{
				RedSystemMessage(m_session, "More than 25 results returned. aborting.");
				break;
			}
		}
	}
	
	GreenSystemMessage(m_session, "Search completed in %u ms.", getMSTime() - t);
	return true;
}

bool ChatHandler::HandleLookupFactionCommand(const char * args, WorldSession * m_session)
{
	if(!*args) return false;

	string x = string(args);
	arcemu_TOLOWER(x);
	if(x.length() < 4)
	{
		RedSystemMessage(m_session, "Your search string must be at least 5 characters long.");
		return true;
	}

	GreenSystemMessage(m_session, "Starting search of faction `%s`...", x.c_str());
	uint32 t = getMSTime();
	uint32 count = 0;
	for (uint32 index = 0; index < dbcFaction.GetNumRows(); ++index)
	{
		FactionDBC* faction = dbcFaction.LookupRow(index);
		string y = string(faction->Name);
		arcemu_TOLOWER(y);
		if(FindXinYString(x, y))
 		{
 			// Print out the name in a cool highlighted fashion
			SendHighlightedName(m_session, "Faction", faction->Name, y, x, faction->ID);
			++count;
			if(count == 25)
			{
				RedSystemMessage(m_session, "More than 25 results returned. aborting.");
				break;
			}
		}
	}
	
	GreenSystemMessage(m_session, "Search completed in %u ms.", getMSTime() - t);
	return true;
}

bool ChatHandler::HandleGORotate(const char * args, WorldSession * m_session)
{
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() && m_session->GetPlayer()->GetMapMgr() && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 169 && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 994 )
	{
		RedSystemMessage(m_session, "You are not allowed to issue that command on this map");
		return true;
	}
#endif
	char Axis;
	float deg;
	if(sscanf(args, "%c %f", &Axis, &deg) < 1) return false;
	GameObject *go = m_session->GetPlayer()->GetSelectedGo();
	if( !go )
	{
		RedSystemMessage(m_session, "No selected GameObject...");
		return true;
	}

	switch(tolower(Axis))
	{
	case 'x':
//		go->ModFloatValue(GAMEOBJECT_PARENTROTATION, rad);
		break;
	case 'y':
//		go->ModFloatValue(GAMEOBJECT_PARENTROTATION_1, rad);
		break;
	case 'o':
		if(m_session->GetPlayer())
		{
			float ori = m_session->GetPlayer()->GetOrientation();
			go->SetParentRotation(2, sinf(ori / 2));
			go->SetParentRotation(3, cosf(ori / 2));
			go->SetOrientation(ori);
			go->UpdateGoRotationXFromOrientation();
		}
		break;
	default:
		RedSystemMessage(m_session, "Invalid Axis, Please use x, y, or o.");
		return true;
	}

	uint32 NewGuid = m_session->GetPlayer()->GetMapMgr()->GenerateGameobjectGuid();
	go->RemoveFromWorld(true);
	go->SetNewGuid(NewGuid);
	go->SaveToDB();
	go->PushToWorld(m_session->GetPlayer()->GetMapMgr());
	//lets reselect the object that can be really annoying...
	m_session->GetPlayer()->m_GM_SelectedGO = NewGuid;
	return true;
}

bool ChatHandler::HandleGOMove(const char * args, WorldSession * m_session)
{
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() && m_session->GetPlayer()->GetMapMgr() && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 169 && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 994 )
	{
		RedSystemMessage(m_session, "You are not allowed to issue that command on this map");
		return true;
	}
#endif
	// move the go to player's coordinates
	GameObject *go = m_session->GetPlayer()->GetSelectedGo();
	if( !go )
	{
		RedSystemMessage(m_session, "No selected GameObject...");
		return true;
	}

	go->RemoveFromWorld(true);
	go->SetPosition(m_session->GetPlayer()->GetPosition());
	uint32 NewGuid = m_session->GetPlayer()->GetMapMgr()->GenerateGameobjectGuid();
	go->SetNewGuid(NewGuid);
	go->SaveToDB();
	go->PushToWorld(m_session->GetPlayer()->GetMapMgr());
	m_session->GetPlayer()->m_GM_SelectedGO = NewGuid;
	return true;
}

bool ChatHandler::HandleGOFlags(const char * args, WorldSession * m_session)
{
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() && m_session->GetPlayer()->GetMapMgr() && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 169 && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 994 )
	{
		RedSystemMessage(m_session, "You are not allowed to issue that command on this map");
		return true;
	}
#endif
	// move the go to player's coordinates
	GameObject *go = m_session->GetPlayer()->GetSelectedGo();
	if( !go )
	{
		RedSystemMessage(m_session, "No selected GameObject...");
		return true;
	}

	uint32 Flags;
	if( sscanf(args, "%u", &Flags) < 1 ) 
	{
		BlueSystemMessage(m_session, "Missing parameter 'flags'.");
		return false;
	}

	m_session->GetPlayer()->BroadcastMessage( "Set flags from %d to %d", go->GetUInt32Value( GAMEOBJECT_FLAGS ), Flags );
	go->SetUInt32Value( GAMEOBJECT_FLAGS, Flags );
	//in case GM resets the instance the flags should update
	if( go->m_spawn )
		go->m_spawn->flags = Flags;
	//make the change persistent
	go->SaveToDB();
	return true;
}

bool ChatHandler::HandleGOAnimate(const char * args, WorldSession * m_session)
{
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() && m_session->GetPlayer()->GetMapMgr() && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 169 && m_session->GetPlayer()->GetMapMgr()->GetMapId() != 994 )
	{
		RedSystemMessage(m_session, "You are not allowed to issue that command on this map");
		return true;
	}
#endif
	GameObject *go = m_session->GetPlayer()->GetSelectedGo();
	if( !go )
	{
		RedSystemMessage(m_session, "No selected GameObject...");
		return true;
	}

	go->SetFlag( GAMEOBJECT_FLAGS, 40 );
	go->SaveToDB();

	return true;
}

bool ChatHandler::HandleNpcPossessCommand(const char * args, WorldSession * m_session)
{
	Unit * pTarget = getSelectedChar(m_session, false);
	if(!pTarget)
	{
		pTarget = getSelectedCreature(m_session, false);
		if(pTarget && (pTarget->IsPet() || pTarget->GetUInt32Value(UNIT_FIELD_CREATEDBY) != 0))
			return false;
	}
		
	if(!pTarget)
	{
		RedSystemMessage(m_session, "You must select a player/creature.");
		return true;
	}

	m_session->GetPlayer()->Possess(pTarget);
	BlueSystemMessage(m_session, "Possessed "I64FMT, pTarget->GetGUID());
	switch( pTarget->GetTypeId() )
	{
		case TYPEID_PLAYER:
			sGMLog.writefromsession( m_session, "used possess command on PLAYER %s", SafePlayerCast( pTarget )->GetName() );
			break;
		case TYPEID_UNIT:
			sGMLog.writefromsession( m_session, "used possess command on CREATURE %s, sqlid %u", SafeCreatureCast( pTarget )->GetCreatureInfo() ? SafeCreatureCast( pTarget )->GetCreatureInfo()->Name : "unknown", SafeCreatureCast( pTarget )->GetSQL_id() );
			break;
	}
	return true;
}

bool ChatHandler::HandleNpcUnPossessCommand(const char * args, WorldSession * m_session)
{
	Creature * creature = getSelectedCreature(m_session);
 	m_session->GetPlayer()->UnPossess();

	if(creature)
	{
			// restart movement
			creature->GetAIInterface()->SetAIState(STATE_IDLE);
			creature->GetAIInterface()->WipeHateList();
			creature->GetAIInterface()->WipeTargetList();

			if(creature->m_spawn)
			{
				// return to respawn coords
				float x = creature->m_spawn->x;
				float y = creature->m_spawn->y;
				float z = creature->m_spawn->z;
				float o = creature->m_spawn->o;
				creature->GetAIInterface()->MoveTo(x, y, z, o);
			}
	}
	GreenSystemMessage(m_session, "Removed any possessed targets.");
	sGMLog.writefromsession(m_session, "used unpossess command");
	return true;
}

bool ChatHandler::HandleRehashCommand(const char * args, WorldSession * m_session)
{
	/* 
	rehashes
	*/
	char msg[250];
	snprintf(msg, 250, "%s is rehashing config file.", m_session->GetPlayer()->GetName());
	sWorld.SendWorldWideScreenText(msg, 0);
	sWorld.SendWorldText(msg, 0);
	sWorld.Rehash(true);
	return true;
}

struct spell_thingo
{
	uint32 type;
	uint32 target;
};

list<SpellEntry*> aiagent_spells;
map<uint32, spell_thingo> aiagent_extra;

bool ChatHandler::HandleAIAgentDebugBegin(const char * args, WorldSession * m_session)
{
	QueryResult * result = WorldDatabase.Query("SELECT DISTINCT spell FROM ai_agents");
	if(!result) return false;

	do 
	{
		SpellEntry * se = dbcSpell.LookupEntryForced(result->Fetch()[0].GetUInt32());
		if(se)
			aiagent_spells.push_back(se);
	} while(result->NextRow());
	delete result;
	result = NULL;

	for(list<SpellEntry*>::iterator itr = aiagent_spells.begin(); itr != aiagent_spells.end(); ++itr)
	{
		result = WorldDatabase.Query("SELECT * FROM ai_agents WHERE spell = %u", (*itr)->Id);
		ASSERT(result);
		spell_thingo t;
		t.type = result->Fetch()[6].GetUInt32();
		t.target = result->Fetch()[7].GetUInt32();
		delete result;
		result = NULL;
		aiagent_extra[(*itr)->Id] = t;
	}

	GreenSystemMessage(m_session, "Loaded %u spells for testing.", aiagent_spells.size());
	return true;
}

SpellCastTargets SetTargets(SpellEntry * sp, uint32 type, uint32 targettype, Unit * dst, Creature * src)
{
	SpellCastTargets targets;
	targets.m_unitTarget = 0;
	targets.m_itemTarget = 0;
	targets.m_srcX = 0;
	targets.m_srcY = 0;
	targets.m_srcZ = 0;
	targets.m_destX = 0;
	targets.m_destY = 0;
	targets.m_destZ = 0;

	if(targettype == TTYPE_SINGLETARGET)
	{
		targets.m_targetMask = 2;
		targets.m_unitTarget = dst->GetGUID();
	}
	else if(targettype == TTYPE_SOURCE)
	{
		targets.m_targetMask = 32;
		targets.m_srcX = src->GetPositionX();
		targets.m_srcY = src->GetPositionY();
		targets.m_srcZ = src->GetPositionZ();
	}
	else if(targettype == TTYPE_DESTINATION)
	{
		targets.m_targetMask = 64;
		targets.m_destX = dst->GetPositionX();
		targets.m_destY = dst->GetPositionY();
		targets.m_destZ = dst->GetPositionZ();
	}

	return targets;
};

bool ChatHandler::HandleAIAgentDebugContinue(const char * args, WorldSession * m_session)
{
	uint32 count = atoi(args);
	if(!count) return false;

	Creature * pCreature = getSelectedCreature(m_session, true);
	if(!pCreature) return true;

	Player * pPlayer = m_session->GetPlayer();

	for(uint32 i = 0; i < count; ++i)
	{
		if(!aiagent_spells.size())
			break;

		SpellEntry * sp = *aiagent_spells.begin();
		aiagent_spells.erase(aiagent_spells.begin());
		BlueSystemMessage(m_session, "Casting %u, "MSG_COLOR_SUBWHITE"%u remaining.", sp->Id, aiagent_spells.size());

		map<uint32, spell_thingo>::iterator it = aiagent_extra.find(sp->Id);
		ASSERT(it != aiagent_extra.end());

		SpellCastTargets targets;
		if( sp->c_is_flags & SPELL_FLAG_IS_BUFF )
			targets = SetTargets(sp, it->second.type, it->second.type, pCreature, pCreature );
		else
			targets = SetTargets(sp, it->second.type, it->second.type, pPlayer, pCreature );

		pCreature->GetAIInterface()->CastSpell(pCreature, sp, targets);
	}

	if(!aiagent_spells.size())
		RedSystemMessage(m_session, "Finished.");
	/*else
		BlueSystemMessage(m_session, "Got %u remaining.", aiagent_spells.size());*/
	return true;
}

bool ChatHandler::HandleAIAgentDebugSkip(const char * args, WorldSession * m_session)
{
	uint32 count = atoi(args);
	if(!count) return false;

	for(uint32 i = 0; i < count; ++i)
	{
		if(!aiagent_spells.size())
			break;

		aiagent_spells.erase(aiagent_spells.begin());
	}
	BlueSystemMessage(m_session, "Erased %u spells.", count);
	return true;
}

bool ChatHandler::HandleRenameGuildCommand(const char* args, WorldSession *m_session)
{
	Player * plr = getSelectedChar(m_session);
	if(!plr || !plr->GetGuildId() || !args || !strlen(args)) return false;


	return true;
}

//People seem to get stuck in guilds from time to time. This should be helpfull. -DGM
bool ChatHandler::HandleGuildRemovePlayerCommand(const char* args, WorldSession *m_session)
{
	Player * plr = getSelectedChar(m_session);
	if(!plr || !plr->GetGuildId()) return false;
	return true;
}

//-DGM
bool ChatHandler::HandleGuildDisbandCommand(const char* args, WorldSession *m_session)
{
	Player * plr = getSelectedChar(m_session);
	if(!plr || !plr->GetGuildId() || !args || !strlen(args)) return false;
	return true;
}

bool ChatHandler::HandleGuildJoinCommand(const char * args,WorldSession *m_session)
{
	if(!*args)
		return false;

	Player * ptarget = getSelectedChar(m_session);
	if(!ptarget) return false;

	if(ptarget->IsInGuild())
	{
		RedSystemMessage(m_session, "%s is already in a guild.", ptarget->GetName());
		return true;
	}

	Guild * pGuild = NULL;
	pGuild = objmgr.GetGuildByGuildName(string(args));
	
	if(pGuild)
	{
		pGuild->AddGuildMember(ptarget->m_playerInfo,m_session,-2);
		GreenSystemMessage(m_session, "You have joined the guild '%s'",pGuild->GetGuildName());
		return true;
	}

	return false;
}

//-DGM
bool ChatHandler::HandleGuildMembersCommand(const char* args, WorldSession *m_session)
{
	Player * plr = getSelectedChar(m_session);
	if(!plr || !plr->GetGuildId()) return false;
	return true;
}

bool ChatHandler::HandleArenaCreateTeamCommand(const char * args, WorldSession * m_session)
{
	uint32 arena_team_type;
	char name[1000];
	uint32 real_type;
	Player * plr = getSelectedChar(m_session, true);
	if(sscanf(args, "%u %[^\n]", &arena_team_type, name) != 2)
	{
		SystemMessage(m_session, "Invalid syntax : <type> <name>.");
		return true;
	}

	switch(arena_team_type)
	{
	case 2:
		real_type=0;
		break;
	case 3:
		real_type=1;
		break;
	case 5:
		real_type=2;
		break;
	default:
		SystemMessage(m_session, "Invalid arena team type specified.");
		return true;
	}

	if(!plr)
		return true;

	if(plr->m_arenaTeams[real_type] != NULL)
	{
		SystemMessage(m_session, "Already in an arena team of that type.");
		return true;
	}

	ArenaTeam * t = new ArenaTeam(real_type,objmgr.GenerateArenaTeamId());
	t->m_emblemStyle=22;
	t->m_emblemColour=4292133532UL;
	t->m_borderColour=4294931722UL;
	t->m_borderStyle=1;
	t->m_backgroundColour=4284906803UL;
	t->m_leader=plr->GetLowGUID();
	t->m_name = string(name);
	t->AddMember(plr->m_playerInfo);
	objmgr.AddArenaTeam(t);
	SystemMessage(m_session, "created arena team.");
	return true;
}

bool ChatHandler::HandleArenaSetTeamLeaderCommand(const char * args, WorldSession * m_session)
{
	uint32 arena_team_type;
	uint32 real_type;
	Player * plr = getSelectedChar(m_session, true);
	if(sscanf(args, "%u", &arena_team_type) != 1)
	{
		SystemMessage(m_session, "Invalid syntax.");
		return true;
	}

	switch(arena_team_type)
	{
	case 2:
		real_type=0;
		break;
	case 3:
		real_type=1;
		break;
	case 5:
		real_type=2;
		break;
	default:
		SystemMessage(m_session, "Invalid arena team type specified.");
		return true;
	}

	if(!plr)
		return true;

	if(plr->m_arenaTeams[real_type] == NULL)
	{
		SystemMessage(m_session, "Not in an arena team of that type.");
		return true;
	}

	ArenaTeam * t = plr->m_arenaTeams[real_type];
	t->SetLeader(plr->m_playerInfo);
	SystemMessage(m_session, "player is now arena team leader.");
	return true;
}

bool ChatHandler::HandleArenaResetAllRatingsCommand(const char * args, WorldSession * m_session)
{
	objmgr.ResetArenaTeamRatings();
	return true;
}

bool ChatHandler::HandleWhisperBlockCommand(const char * args, WorldSession * m_session)
{
	if(m_session->GetPlayer()->bGMTagOn)
		return false;

	m_session->GetPlayer()->bGMTagOn = true;
	return true;
}

bool ChatHandler::HandleGenderChanger(const char* args, WorldSession *m_session)
{
	int gender;
	Player* target = objmgr.GetPlayer((uint32)m_session->GetPlayer()->GetSelection());
	if(!target) {
		SystemMessage(m_session, "Select A Player first.");
		return true;
	}
	uint32 displayId = target->GetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID);
	if (!*args)
	{
		if (target->getGender()== 1)
			gender = 0;
		else
			gender = 1;
	}
	else
		gender = min((int)atoi((char*)args),1);
	target->setGender(gender);
	if( target->getGender() == 0 )
	{
		target->SetUInt32Value(UNIT_FIELD_DISPLAYID, (target->getRace()==RACE_BLOODELF)?displayId+1:displayId-1 );
		target->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, (target->getRace()==RACE_BLOODELF)?displayId+1:displayId-1 );
	} else {
		target->SetUInt32Value(UNIT_FIELD_DISPLAYID, (target->getRace()==RACE_BLOODELF)?displayId-1:displayId+1 );
		target->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, (target->getRace()==RACE_BLOODELF)?displayId-1:displayId+1 );
	}
	SystemMessage(m_session, "Set %s's gender to %s(%u).", target->GetName(), gender?"Female":"Male", gender);
	return true;
}

bool ChatHandler::HandleDispelAllCommand(const char * args, WorldSession * m_session)
{
	uint32 pos=0;
	if(*args)
		pos=atoi(args);

	Player * plr;

	sGMLog.writefromsession(m_session, "used dispelall command, pos %u", pos);

	PlayerStorageMap::const_iterator itr;
	objmgr._playerslock.AcquireReadLock();
	for (itr = objmgr._players.begin(); itr != objmgr._players.end(); itr++)
	{
		plr = itr->second;
		if(plr->GetSession() && plr->IsInWorld())
		{
			if(plr->GetMapMgr() != m_session->GetPlayer()->GetMapMgr())
			{
				sEventMgr.AddEvent( SafeUnitCast( plr ), &Unit::DispelAll, pos ? true : false, EVENT_PLAYER_CHECKFORCHEATS, 100, 1,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT );
			}
			else
			{
				plr->DispelAll(pos?true:false);
			}
		}
	}
	sGMLog.writefromsession(m_session, "used mass dispel");
	objmgr._playerslock.ReleaseReadLock();

	BlueSystemMessage(m_session, "Dispel action done.");
	return true;
}

bool ChatHandler::HandleShowItems(const char * args, WorldSession * m_session)
{
	string q;
	Player * plr = getSelectedChar(m_session, true);
	if(!plr) return true;

	ItemIterator itr(plr->GetItemInterface());
	itr.BeginSearch();
	for(; !itr.End(); itr.Increment())
	{
		if(!(*itr))
			return false;

		SendItemLinkToPlayer((*itr)->GetProto(), m_session, true, plr, m_session->language);
	}
	itr.EndSearch();
	sGMLog.writefromsession(m_session, "used show items command on %s,", plr->GetName());

   return true;
}

bool ChatHandler::HandleShowSkills(const char * args, WorldSession * m_session)
{
	Player * plr = getSelectedChar(m_session, true);
	if(!plr) 
		return true;

	CommitPointerListNode<PlayerSkill> *itr;
	for(itr = plr->m_skills.begin(); itr != plr->m_skills.end(); itr = itr->Next() )
		SystemMessage(m_session, "Skill %u %s %u/%u", itr->data->Skill->id, itr->data->Skill->Name ,itr->data->CurrentValue, itr->data->MaximumValue);
	sGMLog.writefromsession(m_session, "used show skills command on %s,", plr->GetName());

	return true;
}

bool ChatHandler::HandleCollisionTestIndoor(const char * args, WorldSession * m_session)
{
	if (sWorld.Collision) {
		Player * plr = m_session->GetPlayer();
		const LocationVector & loc = plr->GetPosition();
		bool res = CollideInterface.IsIndoor(plr->GetMapId(), loc.x, loc.y, loc.z + 2.0f);
		SystemMessage(m_session, "Result was: %s.", res ? "indoors" : "outside");
		return true;
	} else {
		SystemMessage(m_session, "Collision is not enabled.");
		return true;
	}
}

bool ChatHandler::HandleCollisionTestLOS(const char * args, WorldSession * m_session)
{
	if (sWorld.Collision) {
		Object * pObj = NULL;
		Creature * pCreature = getSelectedCreature(m_session, false);
		Player * pPlayer = getSelectedChar(m_session, false);
		if(pCreature)
			pObj = pCreature;
		else if(pPlayer)
			pObj = pPlayer;

		if(pObj == NULL)
		{
			SystemMessage(m_session, "Invalid target.");
			return true;
		}

		const LocationVector & loc2 = pObj->GetPosition();
		const LocationVector & loc1 = m_session->GetPlayer()->GetPosition();
		bool res = CollideInterface.CheckLOS(pObj->GetMapId(), loc1.x, loc1.y, loc1.z, loc2.x, loc2.y, loc2.z);
		bool res2 = CollideInterface.CheckLOS(pObj->GetMapId(), loc1.x, loc1.y, loc1.z+2.0f, loc2.x, loc2.y, loc2.z+2.0f);
		bool res3 = CollideInterface.CheckLOS(pObj->GetMapId(), loc1.x, loc1.y, loc1.z+5.0f, loc2.x, loc2.y, loc2.z+5.0f);
		SystemMessage(m_session, "Result was: %s %s %s.", res ? "in LOS" : "not in LOS", res2 ? "in LOS" : "not in LOS", res3 ? "in LOS" : "not in LOS");
		return true;
	} else {
		SystemMessage(m_session, "Collision is not enabled.");
		return true;
	}
}

bool ChatHandler::HandleCollisionGetHeight(const char * args, WorldSession * m_session)
{
	if (sWorld.Collision) {
		Player * plr = m_session->GetPlayer();
		float z = CollideInterface.GetHeight(plr->GetMapId(), plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ() + 2.0f);
		float z2 = CollideInterface.GetHeight(plr->GetMapId(), plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ() + 5.0f);
		float z3 = CollideInterface.GetHeight(plr->GetMapId(), plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ());

		SystemMessage(m_session, "Results were: %f %f %f", z, z2, z3);
		return true;
	} else {
		SystemMessage(m_session, "Collision is not enabled.");
		return true;
	}
}
bool ChatHandler::HandleLevelUpCommand(const char* args, WorldSession *m_session)
{
	int levels = 0;

	if (!*args)
		levels = 1;
	else
		levels = atoi(args);

	if(levels <= 0)
		return false;

	Player *plr = getSelectedChar(m_session, true);

	if(!plr) plr = m_session->GetPlayer();

	if(!plr) return false;

	sGMLog.writefromsession(m_session, "used level up command on %s, with %u levels", plr->GetName(), levels);

	levels += plr->getLevel();

	if(levels>PLAYER_LEVEL_CAP)
		levels=PLAYER_LEVEL_CAP;

	plr->ApplyLevelInfo( levels );

	WorldPacket data;
	std::stringstream sstext;
	sstext << "You have been leveled up to Level " << levels << '\0';
	SystemMessage(plr->GetSession(), sstext.str().c_str());

	plr->Social_TellFriendsOnline();

	return true;
}

bool ChatHandler::HandleFixScaleCommand(const char * args, WorldSession * m_session)
{
	Creature * pCreature = getSelectedCreature(m_session, true);
	if( pCreature == NULL )
		return true;

	float sc = (float)atof(args);
	if(sc < 0.1f)
	{
		return false;
	}

	pCreature->SetFloatValue(OBJECT_FIELD_SCALE_X, sc);
	pCreature->GetProto()->Scale = sc;
	WorldDatabase.Execute("UPDATE creature_proto SET scale = '%f' WHERE entry = %u", sc, pCreature->GetEntry());
	return true;
}

bool ChatHandler::HandleAddTrainerSpellCommand( const char * args, WorldSession * m_session )
{
	Creature * pCreature = getSelectedCreature(m_session, true);
	if( pCreature == NULL )
		return true;

	uint32 spellid, cost, reqspell, reqlevel, delspell;
	if( sscanf(args, "%u %u %u %u %u", &spellid, &cost, &reqspell, &reqlevel, &delspell) != 5 )
		return false;

	Trainer * pTrainer =  pCreature->GetTrainer();
	if( pTrainer == NULL )
	{
		RedSystemMessage(m_session, "Target is not a trainer.");
		return true;
	}

	SpellEntry* pSpell = dbcSpell.LookupEntryForced(spellid);
	if(pSpell==NULL)
	{
		RedSystemMessage(m_session, "Invalid spell.");
		return true;
	}

	if( pSpell->eff[0].Effect == SPELL_EFFECT_INSTANT_KILL || pSpell->eff[1].Effect == SPELL_EFFECT_INSTANT_KILL || pSpell->eff[2].Effect == SPELL_EFFECT_INSTANT_KILL )
	{
		RedSystemMessage(m_session, "No. You're not doing that.");
		return true;
	}

	TrainerSpell *sp = new TrainerSpell;
	sp->Cost = cost;
	sp->AdsProfession = false;
	sp->pLearnSpell = pSpell;
	sp->pCastRealSpell = NULL;
	sp->pCastSpell = NULL;
	sp->RequiredLevel = reqlevel;
	sp->RequiredSpell = reqspell;
	sp->DeleteSpell = delspell;

	pTrainer->Spells.push_back(sp);
	pTrainer->SpellCount++;
	
	SystemMessage(m_session, "Added spell %u (%s) to trainer.", pSpell->Id, pSpell->Name);
	sGMLog.writefromsession(m_session, "added spell %u to trainer %u", spellid, pCreature->GetEntry());
	WorldDatabase.Execute("INSERT INTO trainer_spells VALUES(%u, %u, %u, %u, %u, %u, %u, %u, %u, %u)", 
		pCreature->GetEntry(), (int)0, pSpell->Id, cost, reqspell, (int)0, (int)0, reqlevel, delspell, (int)0);

	return true;
}

bool ChatHandler::HandleSetTitleCustom( const char *args, WorldSession *m_session )
{
	Player* plr = getSelectedChar( m_session, true );
	if( plr == NULL )
		return false;

	if( strlen( args ) > 20 )
	{
		RedSystemMessage( m_session, "Custom Title should not be longer then 20 letters!" );
		return false;
	}
	plr->SetNameSuffix( args );
	return true;
}

bool ChatHandler::HandleModCurrency( const char * args, WorldSession * m_session )
{
	Player* plr = getSelectedChar( m_session, true );
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() )
	{
		plr = m_session->GetPlayer();
	}
#endif
	if( plr == NULL )
		return true;

	int32 currency, ammount;
	if( sscanf(args, "%d %d", &currency, &ammount) != 2 )
	{
		RedSystemMessage(m_session, "Not enough parameters : .char modcurrency X Y");
		return false;
	}

	if( currency == 0 )
	{
		RedSystemMessage(m_session, "Currency type cannot be 0.");
		return false;
	}

	if( ammount == 0 )
	{
		RedSystemMessage(m_session, "Modding amount by 0 is pointless.");
		return false;
	}

	int32 nowhave = plr->GetCurrencyCount( currency );
	//if result would turn negative
	if( nowhave <= -ammount )
	{
		plr->SetCurrencyCount( currency, 0 );
		return true;
	}

	plr->ModCurrencyCount( currency, ammount );

	return true;
}

bool ChatHandler::HandleSetTitle( const char *args, WorldSession *m_session )
{
	Player* plr = getSelectedChar( m_session, true );
	if( plr == NULL )
		return false;

	int32 title = atol( args );
	if( title > int32( PVPTITLE_END ) || title < - int32( PVPTITLE_END ) )
	{
		RedSystemMessage( m_session, "Argument %i is out of range!", title );
		return false;
	}
	if( title == 0 )
	{
		plr->SetUInt64Value( PLAYER_FIELD_KNOWN_TITLES, 0 );
		plr->SetUInt64Value( PLAYER_FIELD_KNOWN_TITLES1, 0 );
		plr->SetUInt64Value( PLAYER_FIELD_KNOWN_TITLES2, 0 );
	}
	else if( title > 0 )
		plr->SetKnownTitle( ( RankTitles )( title ), true );
	else
		plr->SetKnownTitle( ( RankTitles )( -title ), false );

	plr->SetUInt32Value( PLAYER_CHOSEN_TITLE, 0 ); // better remove chosen one
	SystemMessage( m_session, "Title has been %s.", title > 0 ? "set" : "reset" );
	sGMLog.writefromsession(m_session, "added title id %u to player %s", title, plr->GetName() );
	return true;
}

/*
disabled because it crashes client. Missing info from the client
bool ChatHandler::HandlePandariceEvent(const char *args, WorldSession *m_session)
{
	uint32 guid = (uint32)m_session->GetPlayer()->GetSelection();
	Player *plr = getSelectedChar(m_session, true);
#ifdef FORCED_GM_TRAINEE_MODE
	if( m_session->CanUseCommand('k') && !m_session->HasGMPermissions() )
	{
		plr = m_session->GetPlayer();
	}
#endif	
//	if(!plr)
	{
		plr = m_session->GetPlayer();
		SystemMessage(m_session, "Auto-targeting self.");
	}
	if(!plr) 
		return false;

	if(plr != m_session->GetPlayer())
	{
		sGMLog.writefromsession(m_session, "Turning %s into a panda %d %d %d", plr->GetName(), plr->GetUInt32Value( UNIT_FIELD_BYTES_0 ), plr->GetUInt32Value( PLAYER_BYTES ), plr->GetUInt32Value( PLAYER_BYTES_2 ) );
	}

	uint32 old_bytes0 = plr->GetUInt32Value( UNIT_FIELD_BYTES_0 );
	uint32 old_bytes0_norace = old_bytes0 & (~0xFF);
	uint32 race = RACE_PANDA;
	plr->SetUInt32Value(UNIT_FIELD_BYTES_0, race  | old_bytes0_norace );
	uint32 skin = 1;
	uint32 face = 1;
	uint32 hairStyle = 1;
	uint32 hairColor = 1;
	plr->SetUInt32Value(PLAYER_BYTES, ((skin) | (face << 8) | (hairStyle << 16) | (hairColor << 24)));
	uint32 old_bytes2 = plr->GetUInt32Value( PLAYER_BYTES_2 );
	uint32 old_bytes2_nofacial = old_bytes2 & (~0xFF);
	uint32 facialHair = 1;
	plr->SetUInt32Value(PLAYER_BYTES_2, facialHair | old_bytes2_nofacial );

	return true;
}*/

bool ChatHandler::HandleSaveAurasToFile( const char * args, WorldSession * m_session )
{
	Player* plr = getSelectedChar( m_session, true );
	if( plr == NULL )
		return true;

	FILE *f = fopen( "SavedAuras.txt","at");
	if( f )
	{
		fprintf( f, "%s\n", plr->GetName() );
		for( uint32 i=FIRST_AURA_SLOT;i<MAX_POSITIVE_AURAS1(plr);i++)
			if( plr->m_auras[i] )
				fprintf( f, "%d,", plr->m_auras[i]->GetSpellId() );
		fprintf( f, "\n" );
		for( uint32 i=MAX_POSITIVE_AURAS;i<MAX_NEGATIVE_AURAS1(plr);i++)
			if( plr->m_auras[i] )
				fprintf( f, "%d,", plr->m_auras[i]->GetSpellId() );
		fprintf( f, "\n" );
		for( uint32 i=PAS_AURAS_START;i<MAX_PASSIVE_AURAS1(plr);i++)
			if( plr->m_auras[i] )
				fprintf( f, "%d,", plr->m_auras[i]->GetSpellId() );
		fprintf( f, "\n" );
		fclose( f );
	}
	m_session->GetPlayer()->BroadcastMessage("Saved auras to file");
	return true;
}

bool ChatHandler::HandleToggleSessionClientPacketLoggingCommand(const char* args, WorldSession *m_session)
{
#ifdef GM_COMMAND_TO_LOG_PLAYER_INCOMMING_PACKETS
	char TargetPlayerName[500];
	int32 ParamCount;
	ParamCount = sscanf(args, "%s", TargetPlayerName );

	Player* plr = NULL;

	if( ParamCount == 0 )
	{
		plr = getSelectedChar( m_session, true );
	}
	else
	{
		PlayerInfo *inf = objmgr.GetPlayerInfoByName( TargetPlayerName );
		if( inf && inf->m_loggedInPlayer != NULL )
			plr = inf->m_loggedInPlayer;
	}

	if( plr == NULL || plr->GetSession() == NULL )
	{
		SystemMessage( m_session, "No playername specified or no player selected to start logging network data" );
		return true;
	}

	if( plr->GetSession()->LogIncommingPackets != NULL )
	{
		fclose( plr->GetSession()->LogIncommingPackets );
		plr->GetSession()->LogIncommingPackets = NULL;
		SystemMessage( m_session, "Stopped logging network data of player" );
		sGMLog.writefromsession(m_session, "Stopped logging network data on ", plr->GetName() );
		return true;
	}

	sGMLog.writefromsession(m_session, "Started logging network data on %s", plr->GetName() );
	SystemMessage( m_session, "Started logging network data of player : Client -> Server" );

	char FileName[500];
	sprintf_s( FileName, 500, "./Logs/Netwi_%d_%s.txt",GetTickCount(), plr->GetName() );
	plr->GetSession()->LogIncommingPackets = fopen( FileName, "wt" );
#endif
	return true;
}

bool ChatHandler::HandleToggleSessionServerClientPacketLoggingCommand(const char* args, WorldSession *m_session)
{
#ifdef GM_COMMAND_TO_LOG_PLAYER_INCOMMING_PACKETS
	char TargetPlayerName[500];
	int32 ParamCount;
	ParamCount = sscanf(args, "%s", TargetPlayerName );

	Player* plr = NULL;

	if( ParamCount == 0 )
	{
		plr = getSelectedChar( m_session, true );
	}
	else
	{
		PlayerInfo *inf = objmgr.GetPlayerInfoByName( TargetPlayerName );
		if( inf && inf->m_loggedInPlayer != NULL )
			plr = inf->m_loggedInPlayer;
	}

	if( plr == NULL || plr->GetSession() == NULL )
	{
		SystemMessage( m_session, "No playername specified or no player selected to start logging network data" );
		return true;
	}

	if( plr->GetSession()->LogOutGoungPackets != NULL )
	{
		fclose( plr->GetSession()->LogOutGoungPackets );
		plr->GetSession()->LogOutGoungPackets = NULL;
		SystemMessage( m_session, "Stopped logging network data of player" );
		sGMLog.writefromsession(m_session, "Stopped logging network data on ", plr->GetName() );
		return true;
	}

	sGMLog.writefromsession(m_session, "Started logging network data on %s", plr->GetName() );
	SystemMessage( m_session, "Started logging network data of player : Server -> Client" );

	char FileName[500];
	sprintf_s( FileName, 500, "./Logs/Netwo_%d_%s.txt",GetTickCount(), plr->GetName() );
	plr->GetSession()->LogOutGoungPackets = fopen( FileName, "wt" );
#endif
	return true;
}
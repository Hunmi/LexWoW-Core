/*
 * ArcEmu MMORPG Server
 * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
 * Copyright (C) 2008 <http://www.ArcEmu.org/>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __UNIT_H
#define __UNIT_H

//safe way to handle arrays in debug mode
#include <array>

class AIInterface;
class DynamicObject;
class Group;
struct Modifier;
class Vehicle;
class Mount;
class CreatureProto;

#define FIRST_AURA_SLOT		0
#define MAX_AURAS			200 // 40 buff slots, 40 debuff slots.
#define MAX_POSITIVE_AURAS	100 // mark the limit of positive auras from total auras
#define MAX_NEGATIVE_VISUAL_AURAS_START MAX_POSITIVE_AURAS
#define MAX_POSITIVE_VISUAL_AURAS_START FIRST_AURA_SLOT
//you hardly get to this but since i was testing i got to it :) : 20 items * 11 (enchants) * 3 + 61 talents
#define MAX_PASSIVE_AURAS	381 
//!! passive visual auras are stored at the end on pos aura space. if size is too small client may bug
#define MAX_VISIBLE_PAS_AURAS	10
#define MAX_VISIBLE_AURAS	(MAX_VISIBLE_PAS_AURAS+MAX_AURAS) //number of positive and negative unique auras visible client side

#define POS_AURAS_START			FIRST_AURA_SLOT
#define MAX_POSITIVE_AURAS1(a)	a->m_auras_pos_size
#define NEG_AURAS_START			MAX_POSITIVE_AURAS
#define MAX_NEGATIVE_AURAS1(a)	a->m_auras_neg_size
#define	PAS_AURAS_START			MAX_AURAS
#define MAX_PASSIVE_AURAS1(a)	a->m_auras_pas_size

#define AURA_IN_PROCESS_TO_ADD 0x0000FFFF
#define AURA_INVALID_VISUAL_SLOT 0x0000FFFF		//make it larger then MAX_VISIBLE_AURAS

#define AURA_SEND_DELAY 1000	//we have this delay of sending auras to other players so client will have time to create object first
#define SPELL_SCHOOL_COUNT	7	//same as in spell.h

enum AuraSearchFlagTypes
{
	AURA_SEARCH_POSITIVE = 1,
	AURA_SEARCH_NEGATIVE = 2,
	AURA_SEARCH_PASSIVE  = 4,
	AURA_SEARCH_VISIBLE	 = (AURA_SEARCH_POSITIVE|AURA_SEARCH_NEGATIVE),
	AURA_SEARCH_BENEFIC	 = (AURA_SEARCH_POSITIVE|AURA_SEARCH_PASSIVE),
	AURA_SEARCH_ALL		 = (AURA_SEARCH_POSITIVE|AURA_SEARCH_NEGATIVE|AURA_SEARCH_PASSIVE),
};

enum Unit_State_Flags
{
	UF_TARGET_DIED				= 1,
	UF_ATTACKING				= 2,		// this unit is attacking it's selection
};

#define SPELL_GROUPS_COUNT	3
#define SPELL_GROUPS_BITS	(SPELL_GROUPS_COUNT*32)	//This is actually on 64 bits !

#define UNIT_TYPE_HUMANOID_BIT	(1 << (HUMANOID-1)) //should get computed by precompiler ;)
#define UNIT_TYPE_BEAST_BIT		(1 << (BEAST-1)) //should get computed by precompiler ;)

#define MECHANIC_TOTAL	33
#define DIMINISHCOUNT	22
#define CREATURE_TYPES	16	//found creature type 14 at least in 3.1.2
#define USE_DIMINISHING_FOR_DODGE_BLOCK_MISS_PARRY
#define AURASTATE_MAX_INDEX		24

//new_time = spell_cast_time * haste
#define SPELL_HASTE_CONTRIBUTION_TO_DOTS (1.15f)	//15% of real hasting

#define MANA_REGEN_INTERVAL_CLIENT_SECONDS_DISPLAY	5
#define MANA_REGEN_INTERVAL_SERVER_SECONDS_USAGE	1

class Aura;
class Spell;
class AIInterface;
class GameObject;

struct CreatureInfo;
struct FactionTemplateDBC;
struct FactionDBC;
struct ExtraAttack;

struct ReflectSpellSchool
{
	uint32 spellId;
	uint32 charges;
	int32 school;
	int32 chance;
	int32 require_aura_hash;
};

class Absorb
{
public:
	Absorb() 
	{ 
		MaxAbsorbPerHit = 0x0FFFFFFF; 
		MaxAbsorbCoeff = 0.0f; 
//		MaxAbsorbEvents = 0x0FFFFFFF; 
		OwnerAur = NULL;
	}
	uint32	spellid;
	uint64	caster;//not yet in use
	int32	amt;
	float	MaxAbsorbCoeff;	//some shields only absorb a portion of the dmg
	uint32	MaxAbsorbPerHit;
//	int32	MaxAbsorbEvents;
	//in case amt is not shared then we could use these directly
	// or we can just uise an uint8 to store scool as mask but then we need to convert school at each function call
	bool	schools[SPELL_SCHOOL_COUNT];
	Aura	*OwnerAur;	//for updating client side icon about remaining amt
};

//typedef std::list<Absorb*> SchoolAbsorb;

typedef struct 
{
	uint32 spellid;
	uint32 mindmg;
	uint32 maxdmg;
} OnHitSpell;

struct AreaAura
{
	uint32 auraid;
	Unit* caster;
};

typedef struct {
	SpellEntry *spell_info;
	uint32 charges;
	bool deleted;
} ExtraStrike;

enum DeathState
{
	ALIVE = 0,  // Unit is alive and well
	JUST_DIED,  // Unit has JUST died
	CORPSE,	 // Unit has died but remains in the world as a corpse
	DEAD		// Unit is dead and his corpse is gone from the world
};

enum Sheath_types
{
	WEAPON_SHEATH_NONE			= 0,
	WEAPON_SHEATH_MELEE			= 1,
	WEAPON_SHEATH_RANGED		= 3,
	WEAPON_SHEATH_RESTORE_SPAWN	= 99,
};

#define HIGHEST_FACTION = 46
enum Factions {
	FACTION_BLOODSAIL_BUCCANEERS,
	FACTION_BOOTY_BAY,
	FACTION_GELKIS_CLAN_CENTAUR,
	FACTION_MAGRAM_CLAN_CENTAUR,
	FACTION_THORIUM_BROTHERHOOD,
	FACTION_RAVENHOLDT,
	FACTION_SYNDICATE,
	FACTION_GADGETZAN,
	FACTION_WILDHAMMER_CLAN,
	FACTION_RATCHET,
	FACTION_STEAMWHEEDLE_CARTEL,
	FACTION_ALLIANCE,
	FACTION_HORDE,
	FACTION_ARGENT_DAWN,
	FACTION_ORGRIMMAR,
	FACTION_DARKSPEAR_TROLLS,
	FACTION_THUNDER_BLUFF,
	FACTION_UNDERCITY,
	FACTION_GNOMEREGAN_EXILES,
	FACTION_STORMWIND,
	FACTION_IRONFORGE,
	FACTION_DARNASSUS,
	FACTION_LEATHERWORKING_DRAGON,
	FACTION_LEATHERWORKING_ELEMENTAL,
	FACTION_LEATHERWORKING_TRIBAL,
	FACTION_ENGINEERING_GNOME,
	FACTION_ENGINEERING_GOBLIN,
	FACTION_WINTERSABER_TRAINERS,
	FACTION_EVERLOOK,
	FACTION_BLACKSMITHING_ARMOR,
	FACTION_BLACKSMITHING_WEAPON,
	FACTION_BLACKSMITHING_AXE,
	FACTION_BLACKSMITHING_SWORD,
	FACTION_BLACKSMITHING_HAMMER,
	FACTION_CAER_DARROW,
	FACTION_TIMBERMAW_HOLD,
	FACTION_CENARION_CIRCLE,
	FACTION_THRALLMAR,
	FACTION_HONOR_HOLD,
	FACTION_THE_SHA_TAR,
	FACTION_STORMPIKE_GUARDS,
	FACTION_FROSTWOLF_CLAN,
	FACTION_HYDRAXIAN_WATERLORDS,
	FACTION_OUTLAND,
	FACTION_SHEN_DRALAR,
	FACTION_SILVERWING_SENTINELS,
	FACTION_WARSONG_OUTRIDERS,
	FACTION_ALLIANCE_FORCES,
	FACTION_HORDE_FORCES,
	FACTION_EXODAR,
	FACTION_DARKMOON_FAIRE,
	FACTION_ZANDALAR_TRIBE,
	FACTION_THE_DEFILERS,
	FACTION_THE_LEAGUE_OF_ARATHOR,
	FACTION_BROOD_OF_NOZDORMU,
	FACTION_SILVERMOON_CITY,
	FACTION_TRANQUILLIEN,
	FACTION_THE_SCALE_OF_THE_SANDS,
	FACTION_THE_ALDOR,
	FACTION_SHATTRATH_CITY,
	FACTION_THE_CONSORTIUM,
	FACTION_THE_MAG_HAR,
	FACTION_THE_SCRYERS,
	FACTION_THE_VIOLET_EYE,
	FACTION_CENARION_EXPEDITION,
	FACTION_SPOREGGAR,
	FACTION_KURENAI,
	FACTION_KEEPERS_OF_TIME,
	FACTION_FRIENDLY_HIDDEN,
	FACTION_LOWER_CITY,
	FACTION_ASHTONGUE_DEATHSWORN,
	FACTION_NETHERWING,
	FACTION_SHATARI_SKYGUARD,
	FACTION_OGRI_LA,
	FACTION_SHATTERED_SUN_OFFENSIVE = 80
};

typedef enum
{
	TEXTEMOTE_AGREE                = 1,
	TEXTEMOTE_AMAZE                = 2,
	TEXTEMOTE_ANGRY                = 3,
	TEXTEMOTE_APOLOGIZE            = 4,
	TEXTEMOTE_APPLAUD            = 5,
	TEXTEMOTE_BASHFUL            = 6,
	TEXTEMOTE_BECKON            = 7,
	TEXTEMOTE_BEG                = 8,
	TEXTEMOTE_BITE                = 9,
	TEXTEMOTE_BLEED                = 10,
	TEXTEMOTE_BLINK                = 11,
	TEXTEMOTE_BLUSH                = 12,
	TEXTEMOTE_BONK                = 13,
	TEXTEMOTE_BORED                = 14,
	TEXTEMOTE_BOUNCE            = 15,
	TEXTEMOTE_BRB                = 16,
	TEXTEMOTE_BOW                = 17,
	TEXTEMOTE_BURP                = 18,
	TEXTEMOTE_BYE                = 19,
	TEXTEMOTE_CACKLE            = 20,
	TEXTEMOTE_CHEER                = 21,
	TEXTEMOTE_CHICKEN            = 22,
	TEXTEMOTE_CHUCKLE            = 23,
	TEXTEMOTE_CLAP                = 24,
	TEXTEMOTE_CONFUSED            = 25,
	TEXTEMOTE_CONGRATULATE        = 26,
	TEXTEMOTE_COUGH                = 27,
	TEXTEMOTE_COWER                = 28,
	TEXTEMOTE_CRACK                = 29,
	TEXTEMOTE_CRINGE            = 30,
	TEXTEMOTE_CRY                = 31,
	TEXTEMOTE_CURIOUS            = 32,
	TEXTEMOTE_CURTSEY            = 33,
	TEXTEMOTE_DANCE                = 34,
	TEXTEMOTE_DRINK                = 35,
	TEXTEMOTE_DROOL                = 36,
	TEXTEMOTE_EAT                = 37,
	TEXTEMOTE_EYE                = 38,
	TEXTEMOTE_FART                = 39,
	TEXTEMOTE_FIDGET            = 40,
	TEXTEMOTE_FLEX                = 41,
	TEXTEMOTE_FROWN                = 42,
	TEXTEMOTE_GASP                = 43,
	TEXTEMOTE_GAZE                = 44,
	TEXTEMOTE_GIGGLE            = 45,
	TEXTEMOTE_GLARE                = 46,
	TEXTEMOTE_GLOAT                = 47,
	TEXTEMOTE_GREET                = 48,
	TEXTEMOTE_GRIN                = 49,
	TEXTEMOTE_GROAN                = 50,
	TEXTEMOTE_GROVEL            = 51,
	TEXTEMOTE_GUFFAW            = 52,
	TEXTEMOTE_HAIL                = 53,
	TEXTEMOTE_HAPPY                = 54,
	TEXTEMOTE_HELLO                = 55,
	TEXTEMOTE_HUG                = 56,
	TEXTEMOTE_HUNGRY            = 57,
	TEXTEMOTE_KISS                = 58,
	TEXTEMOTE_KNEEL                = 59,
	TEXTEMOTE_LAUGH                = 60,
	TEXTEMOTE_LAYDOWN            = 61,
	TEXTEMOTE_MASSAGE            = 62,
	TEXTEMOTE_MOAN                = 63,
	TEXTEMOTE_MOON                = 64,
	TEXTEMOTE_MOURN                = 65,
	TEXTEMOTE_NO                = 66,
	TEXTEMOTE_NOD                = 67,
	TEXTEMOTE_NOSEPICK            = 68,
	TEXTEMOTE_PANIC                = 69,
	TEXTEMOTE_PEER                = 70,
	TEXTEMOTE_PLEAD                = 71,
	TEXTEMOTE_POINT                = 72,
	TEXTEMOTE_POKE                = 73,
	TEXTEMOTE_PRAY                = 74,
	TEXTEMOTE_ROAR                = 75,
	TEXTEMOTE_ROFL                = 76,
	TEXTEMOTE_RUDE                = 77,
	TEXTEMOTE_SALUTE            = 78,
	TEXTEMOTE_SCRATCH            = 79,
	TEXTEMOTE_SEXY                = 80,
	TEXTEMOTE_SHAKE                = 81,
	TEXTEMOTE_SHOUT                = 82,
	TEXTEMOTE_SHRUG                = 83,
	TEXTEMOTE_SHY                = 84,
	TEXTEMOTE_SIGH                = 85,
	TEXTEMOTE_SIT                = 86,
	TEXTEMOTE_SLEEP                = 87,
	TEXTEMOTE_SNARL                = 88,
	TEXTEMOTE_SPIT                = 89,
	TEXTEMOTE_STARE                = 90,
	TEXTEMOTE_SURPRISED            = 91,
	TEXTEMOTE_SURRENDER            = 92,
	TEXTEMOTE_TALK                = 93,
	TEXTEMOTE_TALKEX            = 94,
	TEXTEMOTE_TALKQ                = 95,
	TEXTEMOTE_TAP                = 96,
	TEXTEMOTE_THANK                = 97,
	TEXTEMOTE_THREATEN            = 98,
	TEXTEMOTE_TIRED                = 99,
	TEXTEMOTE_VICTORY            = 100,
	TEXTEMOTE_WAVE                = 101,
	TEXTEMOTE_WELCOME            = 102,
	TEXTEMOTE_WHINE                = 103,
	TEXTEMOTE_WHISTLE            = 104,
	TEXTEMOTE_WORK                = 105,
	TEXTEMOTE_YAWN                = 106,
	TEXTEMOTE_BOGGLE            = 107,
	TEXTEMOTE_CALM                = 108,
	TEXTEMOTE_COLD                = 109,
	TEXTEMOTE_COMFORT            = 110,
	TEXTEMOTE_CUDDLE            = 111,
	TEXTEMOTE_DUCK                = 112,
	TEXTEMOTE_INSULT            = 113,
	TEXTEMOTE_INTRODUCE            = 114,
	TEXTEMOTE_JK                = 115,
	TEXTEMOTE_LICK                = 116,
	TEXTEMOTE_LISTEN            = 117,
	TEXTEMOTE_LOST                = 118,
	TEXTEMOTE_MOCK                = 119,
	TEXTEMOTE_PONDER            = 120,
	TEXTEMOTE_POUNCE            = 121,
	TEXTEMOTE_PRAISE            = 122,
	TEXTEMOTE_PURR                = 123,
	TEXTEMOTE_PUZZLE            = 124,
	TEXTEMOTE_RAISE                = 125,
	TEXTEMOTE_READY                = 126,
	TEXTEMOTE_SHIMMY            = 127,
	TEXTEMOTE_SHIVER            = 128,
	TEXTEMOTE_SHOO                = 129,
	TEXTEMOTE_SLAP                = 130,
	TEXTEMOTE_SMIRK                = 131,
	TEXTEMOTE_SNIFF                = 132,
	TEXTEMOTE_SNUB                = 133,
	TEXTEMOTE_SOOTHE            = 134,
	TEXTEMOTE_STINK                = 135,
	TEXTEMOTE_TAUNT                = 136,
	TEXTEMOTE_TEASE                = 137,
	TEXTEMOTE_THIRSTY            = 138,
	TEXTEMOTE_VETO                = 139,
	TEXTEMOTE_SNICKER            = 140,
	TEXTEMOTE_STAND                = 141,
	TEXTEMOTE_TICKLE            = 142,
	TEXTEMOTE_VIOLIN            = 143,
	TEXTEMOTE_SMILE                = 163,
	TEXTEMOTE_RASP                = 183,
	TEXTEMOTE_PITY                = 203,
	TEXTEMOTE_GROWL                = 204,
	TEXTEMOTE_BARK                = 205,
	TEXTEMOTE_SCARED            = 223,
	TEXTEMOTE_FLOP                = 224,
	TEXTEMOTE_LOVE                = 225,
	TEXTEMOTE_MOO                = 226,
	TEXTEMOTE_COMMEND            = 243,
	TEXTEMOTE_TRAIN                = 264,
	TEXTEMOTE_HELPME            = 303,
	TEXTEMOTE_INCOMING            = 304,
	TEXTEMOTE_CHARGE            = 305,
	TEXTEMOTE_FLEE                = 306,
	TEXTEMOTE_ATTACKMYTARGET    = 307,
	TEXTEMOTE_OOM                = 323,
	TEXTEMOTE_FOLLOW            = 324,
	TEXTEMOTE_WAIT                = 325,
	TEXTEMOTE_HEALME            = 326,
	TEXTEMOTE_OPENFIRE            = 327,
	TEXTEMOTE_FLIRT                = 328,
	TEXTEMOTE_JOKE                = 329,
	TEXTEMOTE_GOLFCLAP            = 343,
	TEXTEMOTE_WINK                = 363,
	TEXTEMOTE_PAT                = 364,
	TEXTEMOTE_SERIOUS            = 365,
	TEXTEMOTE_MOUNTSPECIAL        = 366,
	TEXTEMOTE_GOODLUCK            = 367,
	TEXTEMOTE_BLAME                = 368,
	TEXTEMOTE_BLANK                = 369,
	TEXTEMOTE_BRANDISH            = 370,
	TEXTEMOTE_BREATH            = 371,
	TEXTEMOTE_DISAGREE            = 372,
	TEXTEMOTE_DOUBT                = 373,
	TEXTEMOTE_EMBARRASS            = 374,
	TEXTEMOTE_ENCOURAGE            = 375,
	TEXTEMOTE_ENEMY                = 376,
	TEXTEMOTE_EYEBROW            = 377,
	TEXTEMOTE_TOAST                = 378,
	TEXTEMOTE_FAIL                = 379,
	TEXTEMOTE_HIGHFIVE            = 380,
	TEXTEMOTE_ABSENT            = 381,
	TEXTEMOTE_ARM                = 382,
	TEXTEMOTE_AWE                = 383,
	TEXTEMOTE_BACKPACK            = 384,
	TEXTEMOTE_BADFEELING        = 385,
	TEXTEMOTE_CHALLENGE            = 386,
	TEXTEMOTE_CHUG                = 387,
	TEXTEMOTE_DING                = 389,
	TEXTEMOTE_FACEPALM            = 390,
	TEXTEMOTE_FAINT                = 391,
	TEXTEMOTE_GO                = 392,
	TEXTEMOTE_GOING                = 393,
	TEXTEMOTE_GLOWER            = 394,
	TEXTEMOTE_HEADACHE            = 395,
	TEXTEMOTE_HICCUP            = 396,
	TEXTEMOTE_HISS                = 398,
	TEXTEMOTE_HOLDHAND            = 399,
	TEXTEMOTE_HURRY                = 401,
	TEXTEMOTE_IDEA                = 402,
	TEXTEMOTE_JEALOUS            = 403,
	TEXTEMOTE_LUCK                = 404,
	TEXTEMOTE_MAP                = 405,
	TEXTEMOTE_MERCY                = 406,
	TEXTEMOTE_MUTTER            = 407,
	TEXTEMOTE_NERVOUS            = 408,
	TEXTEMOTE_OFFER                = 409,
	TEXTEMOTE_PET                = 410,
	TEXTEMOTE_PINCH                = 411,
	TEXTEMOTE_PROUD                = 413,
	TEXTEMOTE_PROMISE            = 414,
	TEXTEMOTE_PULSE                = 415,
	TEXTEMOTE_PUNCH                = 416,
	TEXTEMOTE_POUT                = 417,
	TEXTEMOTE_REGRET            = 418,
	TEXTEMOTE_REVENGE            = 420,
	TEXTEMOTE_ROLLEYES            = 421,
	TEXTEMOTE_RUFFLE            = 422,
	TEXTEMOTE_SAD                = 423,
	TEXTEMOTE_SCOFF                = 424,
	TEXTEMOTE_SCOLD                = 425,
	TEXTEMOTE_SCOWL                = 426,
	TEXTEMOTE_SEARCH            = 427,
	TEXTEMOTE_SHAKEFIST            = 428,
	TEXTEMOTE_SHIFTY            = 429,
	TEXTEMOTE_SHUDDER            = 430,
	TEXTEMOTE_SIGNAL            = 431,
	TEXTEMOTE_SILENCE            = 432,
	TEXTEMOTE_SING                = 433,
	TEXTEMOTE_SMACK                = 434,
	TEXTEMOTE_SNEAK                = 435,
	TEXTEMOTE_SNEEZE            = 436,
	TEXTEMOTE_SNORT                = 437,
	TEXTEMOTE_SQUEAL            = 438,
	TEXTEMOTE_STOPATTACK        = 439,
	TEXTEMOTE_SUSPICIOUS        = 440,
	TEXTEMOTE_THINK                = 441,
	TEXTEMOTE_TRUCE                = 442,
	TEXTEMOTE_TWIDDLE            = 443,
	TEXTEMOTE_WARN                = 444,
	TEXTEMOTE_SNAP                = 445,
	TEXTEMOTE_CHARM                = 446,
	TEXTEMOTE_COVEREARS            = 447,
	TEXTEMOTE_CROSSARMS            = 448,
	TEXTEMOTE_LOOK                = 449,
	TEXTEMOTE_OBJECT            = 450,
	TEXTEMOTE_SWEAT                = 451,
    TEXTEMOTE_YW                   = 453,
    TEXTEMOTE_READ                 = 456,
} TextEmoteType;

typedef enum
{
    EMOTE_ONESHOT_NONE                    = 0,
    EMOTE_ONESHOT_TALK                    = 1,   //DNR
    EMOTE_ONESHOT_BOW                    = 2,
    EMOTE_ONESHOT_WAVE                    = 3,   //DNR
    EMOTE_ONESHOT_CHEER                    = 4,   //DNR
    EMOTE_ONESHOT_EXCLAMATION            = 5,   //DNR
    EMOTE_ONESHOT_QUESTION                = 6,
    EMOTE_ONESHOT_EAT                    = 7,
    EMOTE_STATE_DANCE                    = 10,
    EMOTE_ONESHOT_LAUGH                    = 11,
    EMOTE_STATE_SLEEP                    = 12,
    EMOTE_STATE_SIT                        = 13,
    EMOTE_ONESHOT_RUDE                    = 14,   //DNR
    EMOTE_ONESHOT_ROAR                    = 15,   //DNR
    EMOTE_ONESHOT_KNEEL                    = 16,
    EMOTE_ONESHOT_KISS                    = 17,
    EMOTE_ONESHOT_CRY                    = 18,
    EMOTE_ONESHOT_CHICKEN                = 19,
    EMOTE_ONESHOT_BEG                    = 20,
    EMOTE_ONESHOT_APPLAUD                = 21,
    EMOTE_ONESHOT_SHOUT                    = 22,   //DNR
    EMOTE_ONESHOT_FLEX                    = 23,
    EMOTE_ONESHOT_SHY                    = 24,   //DNR
    EMOTE_ONESHOT_POINT                    = 25,   //DNR
    EMOTE_STATE_STAND                    = 26,
    EMOTE_STATE_READYUNARMED            = 27,
    EMOTE_STATE_WORK_SHEATHED            = 28,
    EMOTE_STATE_POINT                    = 29,   //DNR
    EMOTE_STATE_NONE                    = 30,
    EMOTE_ONESHOT_WOUND                    = 33,
    EMOTE_ONESHOT_WOUNDCRITICAL            = 34,
    EMOTE_ONESHOT_ATTACKUNARMED            = 35,
    EMOTE_ONESHOT_ATTACK1H                = 36,
    EMOTE_ONESHOT_ATTACK2HTIGHT            = 37,
    EMOTE_ONESHOT_ATTACK2HLOOSE            = 38,
    EMOTE_ONESHOT_PARRYUNARMED            = 39,
    EMOTE_ONESHOT_PARRYSHIELD            = 43,
    EMOTE_ONESHOT_READYUNARMED            = 44,
    EMOTE_ONESHOT_READY1H                = 45,
    EMOTE_ONESHOT_READYBOW                = 48,
    EMOTE_ONESHOT_SPELLPRECAST            = 50,
    EMOTE_ONESHOT_SPELLCAST                = 51,
    EMOTE_ONESHOT_BATTLEROAR            = 53,
    EMOTE_ONESHOT_SPECIALATTACK1H        = 54,
    EMOTE_ONESHOT_KICK                    = 60,
    EMOTE_ONESHOT_ATTACKTHROWN            = 61,
    EMOTE_STATE_STUN                    = 64,
    EMOTE_STATE_DEAD                    = 65,
    EMOTE_ONESHOT_SALUTE                = 66,
    EMOTE_STATE_KNEEL                    = 68,
    EMOTE_STATE_USESTANDING                = 69,
    EMOTE_ONESHOT_WAVE_NOSHEATHE        = 70,
    EMOTE_ONESHOT_CHEER_NOSHEATHE        = 71,
    EMOTE_ONESHOT_EAT_NOSHEATHE            = 92,
    EMOTE_STATE_STUN_NOSHEATHE            = 93,
    EMOTE_ONESHOT_DANCE                    = 94,
    EMOTE_ONESHOT_SALUTE_NOSHEATH        = 113,
    EMOTE_STATE_USESTANDING_NOSHEATHE    = 133,
    EMOTE_ONESHOT_LAUGH_NOSHEATHE        = 153,
    EMOTE_STATE_WORK                    = 173,
    EMOTE_STATE_SPELLPRECAST            = 193,
    EMOTE_ONESHOT_READYRIFLE            = 213,
    EMOTE_STATE_READYRIFLE                = 214,
    EMOTE_STATE_WORK_MINING                = 233,
    EMOTE_STATE_WORK_CHOPWOOD            = 234,
    EMOTE_STATE_APPLAUD                    = 253,
    EMOTE_ONESHOT_LIFTOFF                = 254,
    EMOTE_ONESHOT_YES                    = 273,   //DNR
    EMOTE_ONESHOT_NO                    = 274,   //DNR
    EMOTE_ONESHOT_TRAIN                    = 275,   //DNR
    EMOTE_ONESHOT_LAND                    = 293,
    EMOTE_STATE_AT_EASE                    = 313,
    EMOTE_STATE_READY1H                    = 333,
    EMOTE_STATE_SPELLKNEELSTART            = 353,
//	EMOTE_STATE_FISHING                    = 362,
//	EMOTE_ONESHOT_FISHING                = 363,
    EMOTE_STATE_SUBMERGED                = 373,
    EMOTE_ONESHOT_SUBMERGE                = 374,
    EMOTE_STATE_READY2H                    = 375,
    EMOTE_STATE_READYBOW                = 376,
    EMOTE_ONESHOT_MOUNTSPECIAL            = 377,
    EMOTE_STATE_TALK                    = 378,
    EMOTE_STATE_FISHING                    = 379,
    EMOTE_ONESHOT_FISHING                = 380,
    EMOTE_ONESHOT_LOOT                    = 381,
    EMOTE_STATE_WHIRLWIND                = 382,
    EMOTE_STATE_DROWNED                    = 383,
    EMOTE_STATE_HOLD_BOW                = 384,
    EMOTE_STATE_HOLD_RIFLE                = 385,
    EMOTE_STATE_HOLD_THROWN                = 386,
    EMOTE_ONESHOT_DROWN                    = 387,
    EMOTE_ONESHOT_STOMP                    = 388,
    EMOTE_ONESHOT_ATTACKOFF                = 389,
    EMOTE_ONESHOT_ATTACKOFFPIERCE        = 390,
    EMOTE_STATE_ROAR                    = 391,
    EMOTE_STATE_LAUGH                    = 392,
    EMOTE_ONESHOT_CREATURE_SPECIAL        = 393,
    EMOTE_ONESHOT_JUMPLANDRUN            = 394,
    EMOTE_ONESHOT_JUMPEND                = 395,
    EMOTE_ONESHOT_TALK_NOSHEATHE        = 396,
    EMOTE_ONESHOT_POINT_NOSHEATHE        = 397,
    EMOTE_STATE_CANNIBALIZE                = 398,
    EMOTE_ONESHOT_JUMPSTART                = 399,
    EMOTE_STATE_DANCESPECIAL            = 400,
    EMOTE_ONESHOT_DANCESPECIAL            = 401,
    EMOTE_ONESHOT_CUSTOMSPELL01            = 402,
    EMOTE_ONESHOT_CUSTOMSPELL02            = 403,
    EMOTE_ONESHOT_CUSTOMSPELL03            = 404,
    EMOTE_ONESHOT_CUSTOMSPELL04            = 405,
    EMOTE_ONESHOT_CUSTOMSPELL05            = 406,
    EMOTE_ONESHOT_CUSTOMSPELL06            = 407,
    EMOTE_ONESHOT_CUSTOMSPELL07            = 408,
    EMOTE_ONESHOT_CUSTOMSPELL08            = 409,
    EMOTE_ONESHOT_CUSTOMSPELL09            = 410,
    EMOTE_ONESHOT_CUSTOMSPELL10            = 411,
    EMOTE_STATE_EXCLAIM                    = 412,
    EMOTE_STATE_DANCE_CUSTOM            = 413,
    EMOTE_STATE_SIT_CHAIR_MED            = 415,
    EMOTE_STATE_CUSTOM_SPELL_01            = 416,
    EMOTE_STATE_CUSTOM_SPELL_02            = 417,
    EMOTE_STATE_EAT                        = 418,
    EMOTE_STATE_CUSTOM_SPELL_04            = 419,
    EMOTE_STATE_CUSTOM_SPELL_03            = 420,
    EMOTE_STATE_CUSTOM_SPELL_05            = 421,
    EMOTE_STATE_SPELLEFFECT_HOLD        = 422,
    EMOTE_STATE_EAT_NO_SHEATHE            = 423,
    EMOTE_STATE_MOUNT                    = 424,
    EMOTE_STATE_READY2HL                = 425,
    EMOTE_STATE_SIT_CHAIR_HIGH            = 426,
    EMOTE_STATE_FALL                    = 427,
    EMOTE_STATE_LOOT                    = 428,
    EMOTE_STATE_SUBMERGED_NEW                = 429,   //NEW
    EMOTE_ONESHOT_COWER                    = 430,   //DNR
    EMOTE_STATE_COWER                    = 431,
    EMOTE_ONESHOT_USESTANDING            = 432,
    EMOTE_STATE_STEALTH_STAND            = 433,
    EMOTE_ONESHOT_OMNICAST_GHOUL        = 434,   //W SOUND
    EMOTE_ONESHOT_ATTACKBOW                = 435,
    EMOTE_ONESHOT_ATTACKRIFLE            = 436,
    EMOTE_STATE_SWIM_IDLE                = 437,
    EMOTE_STATE_ATTACK_UNARMED            = 438,
    EMOTE_ONESHOT_SPELLCAST2                = 439,   //W SOUND
    EMOTE_ONESHOT_DODGE                    = 440,
    EMOTE_ONESHOT_PARRY1H                = 441,
    EMOTE_ONESHOT_PARRY2H                = 442,
    EMOTE_ONESHOT_PARRY2HL                = 443,
    EMOTE_STATE_FLYFALL                    = 444,
    EMOTE_ONESHOT_FLYDEATH                = 445,
    EMOTE_STATE_FLY_FALL                = 446,
    EMOTE_ONESHOT_FLY_SIT_GROUND_DOWN    = 447,
    EMOTE_ONESHOT_FLY_SIT_GROUND_UP        = 448,
    EMOTE_ONESHOT_EMERGE                = 449,
    EMOTE_ONESHOT_DRAGONSPIT            = 450,
    EMOTE_STATE_SPECIALUNARMED            = 451,
    EMOTE_ONESHOT_FLYGRAB                = 452,
    EMOTE_STATE_FLYGRABCLOSED            = 453,
    EMOTE_ONESHOT_FLYGRABTHROWN            = 454,
    EMOTE_STATE_FLY_SIT_GROUND            = 455,
    EMOTE_STATE_WALKBACKWARDS            = 456,
    EMOTE_ONESHOT_FLYTALK                = 457,
    EMOTE_ONESHOT_FLYATTACK1H            = 458,
    EMOTE_STATE_CUSTOMSPELL08            = 459,
    EMOTE_ONESHOT_FLY_DRAGONSPIT        = 460,
    EMOTE_STATE_SIT_CHAIR_LOW            = 461,
    EMOTE_ONE_SHOT_STUN                    = 462,
    EMOTE_ONESHOT_SPELLCAST_OMNI        = 463,
	EMOTE_STATE_READYTHROWN				= 465,
	EMOTE_ONESHOT_WORK_CHOPWOOD			= 466,
	EMOTE_ONESHOT_WORK_MINING			= 467,
	EMOTE_STATE_SPELL_CHANNEL_OMNI		= 468,
	EMOTE_STATE_SPELL_CHANNEL_DIRECTED	= 469,
	EMOTE_ZZOLD_STATE_KNEEL_NO_INTERRUPT= 470,
    EMOTE_STATE_READYJOUST             = 471,
    EMOTE_STATE_STRANGULATE            = 472,
    EMOTE_STATE_STRANGULATE2           = 473,
    EMOTE_STATE_READYSPELLOMNI         = 474,
    EMOTE_STATE_HOLD_JOUST             = 475,
    EMOTE_ONESHOT_CRY_JP               = 476,                // Only Jaina Proudmoore
    EMOTE_ONESHOT_SPECIALUNARMED       = 477,
    EMOTE_STATE_DANCE_NOSHEATHE        = 478,
    EMOTE_ONESHOT_SNIFF                = 479,
    EMOTE_ONESHOT_DRAGONSTOMP          = 480,
    EMOTE_ONESHOT_KNOCKDOWN            = 482,
    EMOTE_STATE_READ                   = 483,
	EMOTE_ONESHOT_FLYEMOTETALK         = 485,
	EMOTE_STATE_READ_ALLOWMOVEMENT	   = 492,
	EMOTE_STATE_READY1H_ALLOW_MOVEMENT = 505,
	EMOTE_STATE_READY2H_ALLOW_MOVEMENT = 506,
	EMOTE_ONESHOT_OPEN				   = 517,
	EMOTE_STATE_READ_CHRISTMAS		   = 518,
} EmoteType;

//used for UNIT_NPC_EMOTESTATE ? or SMSG_EMOTE ?
enum Anim
{
	ANIM_STAND = 0x0,
	ANIM_DEATH = 0x1,
	ANIM_SPELL = 0x2,
	ANIM_STOP = 0x3,
	ANIM_WALK = 0x4,
	ANIM_RUN = 0x5,
	ANIM_DEAD = 0x6,
	ANIM_RISE = 0x7,
	ANIM_STANDWOUND = 0x8,
	ANIM_COMBATWOUND = 0x9,
	ANIM_COMBATCRITICAL = 0xA,
	ANIM_SHUFFLELEFT = 0xB,
	ANIM_SHUFFLERIGHT = 0xC,
	ANIM_WALKBACKWARDS = 0xD,
	ANIM_STUN = 0xE,
	ANIM_HANDSCLOSED = 0xF,
	ANIM_ATTACKUNARMED = 0x10,
	ANIM_ATTACK1H = 0x11,
	ANIM_ATTACK2H = 0x12,
	ANIM_ATTACK2HL = 0x13,
	ANIM_PARRYUNARMED = 0x14,
	ANIM_PARRY1H = 0x15,
	ANIM_PARRY2H = 0x16,
	ANIM_PARRY2HL = 0x17,
	ANIM_SHIELDBLOCK = 0x18,
	ANIM_READYUNARMED = 0x19,
	ANIM_READY1H = 0x1A,
	ANIM_READY2H = 0x1B,
	ANIM_READY2HL = 0x1C,
	ANIM_READYBOW = 0x1D,
	ANIM_DODGE = 0x1E,
	ANIM_SPELLPRECAST = 0x1F,
	ANIM_SPELLCAST = 0x20,
	ANIM_SPELLCASTAREA = 0x21,
	ANIM_NPCWELCOME = 0x22,
	ANIM_NPCGOODBYE = 0x23,
	ANIM_BLOCK = 0x24,
	ANIM_JUMPSTART = 0x25,
	ANIM_JUMP = 0x26,
	ANIM_JUMPEND = 0x27,
	ANIM_FALL = 0x28,
	ANIM_SWIMIDLE = 0x29,
	ANIM_SWIM = 0x2A,
	ANIM_SWIMLEFT = 0x2B,
	ANIM_SWIMRIGHT = 0x2C,
	ANIM_SWIMBACKWARDS = 0x2D,
	ANIM_ATTACKBOW = 0x2E,
	ANIM_FIREBOW = 0x2F,
	ANIM_READYRIFLE = 0x30,
	ANIM_ATTACKRIFLE = 0x31,
	ANIM_LOOT = 0x32,
	ANIM_READYSPELLDIRECTED = 0x33,
	ANIM_READYSPELLOMNI = 0x34,
	ANIM_SPELLCASTDIRECTED = 0x35,
	ANIM_SPELLCASTOMNI = 0x36,
	ANIM_BATTLEROAR = 0x37,
	ANIM_READYABILITY = 0x38,
	ANIM_SPECIAL1H = 0x39,
	ANIM_SPECIAL2H = 0x3A,
	ANIM_SHIELDBASH = 0x3B,
	ANIM_EMOTETALK = 0x3C,
	ANIM_EMOTEEAT = 0x3D,
	ANIM_EMOTEWORK = 0x3E,
	ANIM_EMOTEUSESTANDING = 0x3F,
	ANIM_EMOTETALKEXCLAMATION = 0x40,
	ANIM_EMOTETALKQUESTION = 0x41,
	ANIM_EMOTEBOW = 0x42,
	ANIM_EMOTEWAVE = 0x43,
	ANIM_EMOTECHEER = 0x44,
	ANIM_EMOTEDANCE = 0x45,
	ANIM_EMOTELAUGH = 0x46,
	ANIM_EMOTESLEEP = 0x47,
	ANIM_EMOTESITGROUND = 0x48,
	ANIM_EMOTERUDE = 0x49,
	ANIM_EMOTEROAR = 0x4A,
	ANIM_EMOTEKNEEL = 0x4B,
	ANIM_EMOTEKISS = 0x4C,
	ANIM_EMOTECRY = 0x4D,
	ANIM_EMOTECHICKEN = 0x4E,
	ANIM_EMOTEBEG = 0x4F,
	ANIM_EMOTEAPPLAUD = 0x50,
	ANIM_EMOTESHOUT = 0x51,
	ANIM_EMOTEFLEX = 0x52,
	ANIM_EMOTESHY = 0x53,
	ANIM_EMOTEPOINT = 0x54,
	ANIM_ATTACK1HPIERCE = 0x55,
	ANIM_ATTACK2HLOOSEPIERCE = 0x56,
	ANIM_ATTACKOFF = 0x57,
	ANIM_ATTACKOFFPIERCE = 0x58,
	ANIM_SHEATH = 0x59,
	ANIM_HIPSHEATH = 0x5A,
	ANIM_MOUNT = 0x5B,
	ANIM_RUNRIGHT = 0x5C,
	ANIM_RUNLEFT = 0x5D,
	ANIM_MOUNTSPECIAL = 0x5E,
	ANIM_KICK = 0x5F,
	ANIM_SITGROUNDDOWN = 0x60,
	ANIM_SITGROUND = 0x61,
	ANIM_SITGROUNDUP = 0x62,
	ANIM_SLEEPDOWN = 0x63,
	ANIM_SLEEP = 0x64,
	ANIM_SLEEPUP = 0x65,
	ANIM_SITCHAIRLOW = 0x66,
	ANIM_SITCHAIRMED = 0x67,
	ANIM_SITCHAIRHIGH = 0x68,
	ANIM_LOADBOW = 0x69,
	ANIM_LOADRIFLE = 0x6A,
	ANIM_ATTACKTHROWN = 0x6B,
	ANIM_READYTHROWN = 0x6C,
	ANIM_HOLDBOW = 0x6D,
	ANIM_HOLDRIFLE = 0x6E,
	ANIM_HOLDTHROWN = 0x6F,
	ANIM_LOADTHROWN = 0x70,
	ANIM_EMOTESALUTE = 0x71,
	ANIM_KNEELSTART = 0x72,
	ANIM_KNEELLOOP = 0x73,
	ANIM_KNEELEND = 0x74,
	ANIM_ATTACKUNARMEDOFF = 0x75,
	ANIM_SPECIALUNARMED = 0x76,
	ANIM_STEALTHWALK = 0x77,
	ANIM_STEALTHSTAND = 0x78,
	ANIM_KNOCKDOWN = 0x79,
	ANIM_EATINGLOOP = 0x7A,
	ANIM_USESTANDINGLOOP = 0x7B,
	ANIM_CHANNELCASTDIRECTED = 0x7C,
	ANIM_CHANNELCASTOMNI = 0x7D,
	ANIM_WHIRLWIND = 0x7E,
	ANIM_BIRTH = 0x7F,
	ANIM_USESTANDINGSTART = 0x80,
	ANIM_USESTANDINGEND = 0x81,
	ANIM_CREATURESPECIAL = 0x82,
	ANIM_DROWN = 0x83,
	ANIM_DROWNED = 0x84,
	ANIM_FISHINGCAST = 0x85,
	ANIM_FISHINGLOOP = 0x86,
	ANIM_FLY = 0x87,
	ANIM_EMOTEWORKNOSHEATHE = 0x88,
	ANIM_EMOTESTUNNOSHEATHE = 0x89,
	ANIM_EMOTEUSESTANDINGNOSHEATHE = 0x8A,
	ANIM_SPELLSLEEPDOWN = 0x8B,
	ANIM_SPELLKNEELSTART = 0x8C,
	ANIM_SPELLKNEELLOOP = 0x8D,
	ANIM_SPELLKNEELEND = 0x8E,
	ANIM_SPRINT = 0x8F,
	ANIM_INFLIGHT = 0x90,
	ANIM_SPAWN = 0x91,
	ANIM_CLOSE = 0x92,
	ANIM_CLOSED = 0x93,
	ANIM_OPEN = 0x94,
	ANIM_OPENED = 0x95,
	ANIM_DESTROY = 0x96,
	ANIM_DESTROYED = 0x97,
	ANIM_REBUILD = 0x98,
	ANIM_CUSTOM0 = 0x99,
	ANIM_CUSTOM1 = 0x9A,
	ANIM_CUSTOM2 = 0x9B,
	ANIM_CUSTOM3 = 0x9C,
	ANIM_DESPAWN = 0x9D,
	ANIM_HOLD = 0x9E,
	ANIM_DECAY = 0x9F,
	ANIM_BOWPULL = 0xA0,
	ANIM_BOWRELEASE = 0xA1,
	ANIM_SHIPSTART = 0xA2,
	ANIM_SHIPMOVING = 0xA3,
	ANIM_SHIPSTOP = 0xA4,
	ANIM_GROUPARROW = 0xA5,
	ANIM_ARROW = 0xA6,
	ANIM_CORPSEARROW = 0xA7,
	ANIM_GUIDEARROW = 0xA8,
	ANIM_SWAY = 0xA9,
	ANIM_DRUIDCATPOUNCE = 0xAA,
	ANIM_DRUIDCATRIP = 0xAB,
	ANIM_DRUIDCATRAKE = 0xAC,
	ANIM_DRUIDCATRAVAGE = 0xAD,
	ANIM_DRUIDCATCLAW = 0xAE,
	ANIM_DRUIDCATCOWER = 0xAF,
	ANIM_DRUIDBEARSWIPE = 0xB0,
	ANIM_DRUIDBEARBITE = 0xB1,
	ANIM_DRUIDBEARMAUL = 0xB2,
	ANIM_DRUIDBEARBASH = 0xB3,
	ANIM_DRAGONTAIL = 0xB4,
	ANIM_DRAGONSTOMP = 0xB5,
	ANIM_DRAGONSPIT = 0xB6,
	ANIM_DRAGONSPITHOVER = 0xB7,
	ANIM_DRAGONSPITFLY = 0xB8,
	ANIM_EMOTEYES = 0xB9,
	ANIM_EMOTENO = 0xBA,
	ANIM_JUMPLANDRUN = 0xBB,
	ANIM_LOOTHOLD = 0xBC,
	ANIM_LOOTUP = 0xBD,
	ANIM_STANDHIGH = 0xBE,
	ANIM_IMPACT = 0xBF,
	ANIM_LIFTOFF = 0xC0,
	ANIM_HOVER = 0xC1,
	ANIM_SUCCUBUSENTICE = 0xC2,
	ANIM_EMOTETRAIN = 0xC3,
	ANIM_EMOTEDEAD = 0xC4,
	ANIM_EMOTEDANCEONCE = 0xC5,
	ANIM_DEFLECT = 0xC6,
	ANIM_EMOTEEATNOSHEATHE = 0xC7,
	ANIM_LAND = 0xC8,
	ANIM_SUBMERGE = 0xC9,
	ANIM_SUBMERGED = 0xCA,
	ANIM_CANNIBALIZE = 0xCB,
	ANIM_ARROWBIRTH = 0xCC,
	ANIM_GROUPARROWBIRTH = 0xCD,
	ANIM_CORPSEARROWBIRTH = 0xCE,
	ANIM_GUIDEARROWBIRTH = 0xCF,
	ANIM_EMOTETALKNOSHEATHE = 0xD0,
	ANIM_EMOTEPOINTNOSHEATHE = 0xD1,
	ANIM_EMOTESALUTENOSHEATHE = 0xD2,
	ANIM_EMOTEDANCESPECIAL = 0xD3,
	ANIM_MUTILATE = 0xD4,
	ANIM_CUSTOMSPELL01 = 0xD5,
	ANIM_CUSTOMSPELL02 = 0xD6,
	ANIM_CUSTOMSPELL03 = 0xD7,
	ANIM_CUSTOMSPELL04 = 0xD8,
	ANIM_CUSTOMSPELL05 = 0xD9,
	ANIM_CUSTOMSPELL06 = 0xDA,
	ANIM_CUSTOMSPELL07 = 0xDB,
	ANIM_CUSTOMSPELL08 = 0xDC,
	ANIM_CUSTOMSPELL09 = 0xDD,
	ANIM_CUSTOMSPELL10 = 0xDE,
	ANIM_STEALTHRUN = 0xDF,
	ANIM_EMERGE = 0xE0,
	ANIM_COWER = 0xE1,
	ANIM_GRAB = 0xE2,
	ANIM_GRABCLOSED = 0xE3,
	ANIM_GRABTHROWN = 0xE4,
	ANIM_FLYSTAND = 0xE5,
	ANIM_FLYDEATH = 0xE6,
	ANIM_FLYSPELL = 0xE7,
	ANIM_FLYSTOP = 0xE8,
	ANIM_FLYWALK = 0xE9,
	ANIM_FLYRUN = 0xEA,
	ANIM_FLYDEAD = 0xEB,
	ANIM_FLYRISE = 0xEC,
	ANIM_FLYSTANDWOUND = 0xED,
	ANIM_FLYCOMBATWOUND = 0xEE,
	ANIM_FLYCOMBATCRITICAL = 0xEF,
	ANIM_FLYSHUFFLELEFT = 0xF0,
	ANIM_FLYSHUFFLERIGHT = 0xF1,
	ANIM_FLYWALKBACKWARDS = 0xF2,
	ANIM_FLYSTUN = 0xF3,
	ANIM_FLYHANDSCLOSED = 0xF4,
	ANIM_FLYATTACKUNARMED = 0xF5,
	ANIM_FLYATTACK1H = 0xF6,
	ANIM_FLYATTACK2H = 0xF7,
	ANIM_FLYATTACK2HL = 0xF8,
	ANIM_FLYPARRYUNARMED = 0xF9,
	ANIM_FLYPARRY1H = 0xFA,
	ANIM_FLYPARRY2H = 0xFB,
	ANIM_FLYPARRY2HL = 0xFC,
	ANIM_FLYSHIELDBLOCK = 0xFD,
	ANIM_FLYREADYUNARMED = 0xFE,
	ANIM_FLYREADY1H = 0xFF,
	ANIM_FLYREADY2H = 0x100,
	ANIM_FLYREADY2HL = 0x101,
	ANIM_FLYREADYBOW = 0x102,
	ANIM_FLYDODGE = 0x103,
	ANIM_FLYSPELLPRECAST = 0x104,
	ANIM_FLYSPELLCAST = 0x105,
	ANIM_FLYSPELLCASTAREA = 0x106,
	ANIM_FLYNPCWELCOME = 0x107,
	ANIM_FLYNPCGOODBYE = 0x108,
	ANIM_FLYBLOCK = 0x109,
	ANIM_FLYJUMPSTART = 0x10A,
	ANIM_FLYJUMP = 0x10B,
	ANIM_FLYJUMPEND = 0x10C,
	ANIM_FLYFALL = 0x10D,
	ANIM_FLYSWIMIDLE = 0x10E,
	ANIM_FLYSWIM = 0x10F,
	ANIM_FLYSWIMLEFT = 0x110,
	ANIM_FLYSWIMRIGHT = 0x111,
	ANIM_FLYSWIMBACKWARDS = 0x112,
	ANIM_FLYATTACKBOW = 0x113,
	ANIM_FLYFIREBOW = 0x114,
	ANIM_FLYREADYRIFLE = 0x115,
	ANIM_FLYATTACKRIFLE = 0x116,
	ANIM_FLYLOOT = 0x117,
	ANIM_FLYREADYSPELLDIRECTED = 0x118,
	ANIM_FLYREADYSPELLOMNI = 0x119,
	ANIM_FLYSPELLCASTDIRECTED = 0x11A,
	ANIM_FLYSPELLCASTOMNI = 0x11B,
	ANIM_FLYBATTLEROAR = 0x11C,
	ANIM_FLYREADYABILITY = 0x11D,
	ANIM_FLYSPECIAL1H = 0x11E,
	ANIM_FLYSPECIAL2H = 0x11F,
	ANIM_FLYSHIELDBASH = 0x120,
	ANIM_FLYEMOTETALK = 0x121,
	ANIM_FLYEMOTEEAT = 0x122,
	ANIM_FLYEMOTEWORK = 0x123,
	ANIM_FLYEMOTEUSESTANDING = 0x124,
	ANIM_FLYEMOTETALKEXCLAMATION = 0x125,
	ANIM_FLYEMOTETALKQUESTION = 0x126,
	ANIM_FLYEMOTEBOW = 0x127,
	ANIM_FLYEMOTEWAVE = 0x128,
	ANIM_FLYEMOTECHEER = 0x129,
	ANIM_FLYEMOTEDANCE = 0x12A,
	ANIM_FLYEMOTELAUGH = 0x12B,
	ANIM_FLYEMOTESLEEP = 0x12C,
	ANIM_FLYEMOTESITGROUND = 0x12D,
	ANIM_FLYEMOTERUDE = 0x12E,
	ANIM_FLYEMOTEROAR = 0x12F,
	ANIM_FLYEMOTEKNEEL = 0x130,
	ANIM_FLYEMOTEKISS = 0x131,
	ANIM_FLYEMOTECRY = 0x132,
	ANIM_FLYEMOTECHICKEN = 0x133,
	ANIM_FLYEMOTEBEG = 0x134,
	ANIM_FLYEMOTEAPPLAUD = 0x135,
	ANIM_FLYEMOTESHOUT = 0x136,
	ANIM_FLYEMOTEFLEX = 0x137,
	ANIM_FLYEMOTESHY = 0x138,
	ANIM_FLYEMOTEPOINT = 0x139,
	ANIM_FLYATTACK1HPIERCE = 0x13A,
	ANIM_FLYATTACK2HLOOSEPIERCE = 0x13B,
	ANIM_FLYATTACKOFF = 0x13C,
	ANIM_FLYATTACKOFFPIERCE = 0x13D,
	ANIM_FLYSHEATH = 0x13E,
	ANIM_FLYHIPSHEATH = 0x13F,
	ANIM_FLYMOUNT = 0x140,
	ANIM_FLYRUNRIGHT = 0x141,
	ANIM_FLYRUNLEFT = 0x142,
	ANIM_FLYMOUNTSPECIAL = 0x143,
	ANIM_FLYKICK = 0x144,
	ANIM_FLYSITGROUNDDOWN = 0x145,
	ANIM_FLYSITGROUND = 0x146,
	ANIM_FLYSITGROUNDUP = 0x147,
	ANIM_FLYSLEEPDOWN = 0x148,
	ANIM_FLYSLEEP = 0x149,
	ANIM_FLYSLEEPUP = 0x14A,
	ANIM_FLYSITCHAIRLOW = 0x14B,
	ANIM_FLYSITCHAIRMED = 0x14C,
	ANIM_FLYSITCHAIRHIGH = 0x14D,
	ANIM_FLYLOADBOW = 0x14E,
	ANIM_FLYLOADRIFLE = 0x14F,
	ANIM_FLYATTACKTHROWN = 0x150,
	ANIM_FLYREADYTHROWN = 0x151,
	ANIM_FLYHOLDBOW = 0x152,
	ANIM_FLYHOLDRIFLE = 0x153,
	ANIM_FLYHOLDTHROWN = 0x154,
	ANIM_FLYLOADTHROWN = 0x155,
	ANIM_FLYEMOTESALUTE = 0x156,
	ANIM_FLYKNEELSTART = 0x157,
	ANIM_FLYKNEELLOOP = 0x158,
	ANIM_FLYKNEELEND = 0x159,
	ANIM_FLYATTACKUNARMEDOFF = 0x15A,
	ANIM_FLYSPECIALUNARMED = 0x15B,
	ANIM_FLYSTEALTHWALK = 0x15C,
	ANIM_FLYSTEALTHSTAND = 0x15D,
	ANIM_FLYKNOCKDOWN = 0x15E,
	ANIM_FLYEATINGLOOP = 0x15F,
	ANIM_FLYUSESTANDINGLOOP = 0x160,
	ANIM_FLYCHANNELCASTDIRECTED = 0x161,
	ANIM_FLYCHANNELCASTOMNI = 0x162,
	ANIM_FLYWHIRLWIND = 0x163,
	ANIM_FLYBIRTH = 0x164,
	ANIM_FLYUSESTANDINGSTART = 0x165,
	ANIM_FLYUSESTANDINGEND = 0x166,
	ANIM_FLYCREATURESPECIAL = 0x167,
	ANIM_FLYDROWN = 0x168,
	ANIM_FLYDROWNED = 0x169,
	ANIM_FLYFISHINGCAST = 0x16A,
	ANIM_FLYFISHINGLOOP = 0x16B,
	ANIM_FLYFLY = 0x16C,
	ANIM_FLYEMOTEWORKNOSHEATHE = 0x16D,
	ANIM_FLYEMOTESTUNNOSHEATHE = 0x16E,
	ANIM_FLYEMOTEUSESTANDINGNOSHEATHE = 0x16F,
	ANIM_FLYSPELLSLEEPDOWN = 0x170,
	ANIM_FLYSPELLKNEELSTART = 0x171,
	ANIM_FLYSPELLKNEELLOOP = 0x172,
	ANIM_FLYSPELLKNEELEND = 0x173,
	ANIM_FLYSPRINT = 0x174,
	ANIM_FLYINFLIGHT = 0x175,
	ANIM_FLYSPAWN = 0x176,
	ANIM_FLYCLOSE = 0x177,
	ANIM_FLYCLOSED = 0x178,
	ANIM_FLYOPEN = 0x179,
	ANIM_FLYOPENED = 0x17A,
	ANIM_FLYDESTROY = 0x17B,
	ANIM_FLYDESTROYED = 0x17C,
	ANIM_FLYREBUILD = 0x17D,
	ANIM_FLYCUSTOM0 = 0x17E,
	ANIM_FLYCUSTOM1 = 0x17F,
	ANIM_FLYCUSTOM2 = 0x180,
	ANIM_FLYCUSTOM3 = 0x181,
	ANIM_FLYDESPAWN = 0x182,
	ANIM_FLYHOLD = 0x183,
	ANIM_FLYDECAY = 0x184,
	ANIM_FLYBOWPULL = 0x185,
	ANIM_FLYBOWRELEASE = 0x186,
	ANIM_FLYSHIPSTART = 0x187,
	ANIM_FLYSHIPMOVING = 0x188,
	ANIM_FLYSHIPSTOP = 0x189,
	ANIM_FLYGROUPARROW = 0x18A,
	ANIM_FLYARROW = 0x18B,
	ANIM_FLYCORPSEARROW = 0x18C,
	ANIM_FLYGUIDEARROW = 0x18D,
	ANIM_FLYSWAY = 0x18E,
	ANIM_FLYDRUIDCATPOUNCE = 0x18F,
	ANIM_FLYDRUIDCATRIP = 0x190,
	ANIM_FLYDRUIDCATRAKE = 0x191,
	ANIM_FLYDRUIDCATRAVAGE = 0x192,
	ANIM_FLYDRUIDCATCLAW = 0x193,
	ANIM_FLYDRUIDCATCOWER = 0x194,
	ANIM_FLYDRUIDBEARSWIPE = 0x195,
	ANIM_FLYDRUIDBEARBITE = 0x196,
	ANIM_FLYDRUIDBEARMAUL = 0x197,
	ANIM_FLYDRUIDBEARBASH = 0x198,
	ANIM_FLYDRAGONTAIL = 0x199,
	ANIM_FLYDRAGONSTOMP = 0x19A,
	ANIM_FLYDRAGONSPIT = 0x19B,
	ANIM_FLYDRAGONSPITHOVER = 0x19C,
	ANIM_FLYDRAGONSPITFLY = 0x19D,
	ANIM_FLYEMOTEYES = 0x19E,
	ANIM_FLYEMOTENO = 0x19F,
	ANIM_FLYJUMPLANDRUN = 0x1A0,
	ANIM_FLYLOOTHOLD = 0x1A1,
	ANIM_FLYLOOTUP = 0x1A2,
	ANIM_FLYSTANDHIGH = 0x1A3,
	ANIM_FLYIMPACT = 0x1A4,
	ANIM_FLYLIFTOFF = 0x1A5,
	ANIM_FLYHOVER = 0x1A6,
	ANIM_FLYSUCCUBUSENTICE = 0x1A7,
	ANIM_FLYEMOTETRAIN = 0x1A8,
	ANIM_FLYEMOTEDEAD = 0x1A9,
	ANIM_FLYEMOTEDANCEONCE = 0x1AA,
	ANIM_FLYDEFLECT = 0x1AB,
	ANIM_FLYEMOTEEATNOSHEATHE = 0x1AC,
	ANIM_FLYLAND = 0x1AD,
	ANIM_FLYSUBMERGE = 0x1AE,
	ANIM_FLYSUBMERGED = 0x1AF,
	ANIM_FLYCANNIBALIZE = 0x1B0,
	ANIM_FLYARROWBIRTH = 0x1B1,
	ANIM_FLYGROUPARROWBIRTH = 0x1B2,
	ANIM_FLYCORPSEARROWBIRTH = 0x1B3,
	ANIM_FLYGUIDEARROWBIRTH = 0x1B4,
	ANIM_FLYEMOTETALKNOSHEATHE = 0x1B5,
	ANIM_FLYEMOTEPOINTNOSHEATHE = 0x1B6,
	ANIM_FLYEMOTESALUTENOSHEATHE = 0x1B7,
	ANIM_FLYEMOTEDANCESPECIAL = 0x1B8,
	ANIM_FLYMUTILATE = 0x1B9,
	ANIM_FLYCUSTOMSPELL01 = 0x1BA,
	ANIM_FLYCUSTOMSPELL02 = 0x1BB,
	ANIM_FLYCUSTOMSPELL03 = 0x1BC,
	ANIM_FLYCUSTOMSPELL04 = 0x1BD,
	ANIM_FLYCUSTOMSPELL05 = 0x1BE,
	ANIM_FLYCUSTOMSPELL06 = 0x1BF,
	ANIM_FLYCUSTOMSPELL07 = 0x1C0,
	ANIM_FLYCUSTOMSPELL08 = 0x1C1,
	ANIM_FLYCUSTOMSPELL09 = 0x1C2,
	ANIM_FLYCUSTOMSPELL10 = 0x1C3,
	ANIM_FLYSTEALTHRUN = 0x1C4,
	ANIM_FLYEMERGE = 0x1C5,
	ANIM_FLYCOWER = 0x1C6,
	ANIM_FLYGRAB = 0x1C7,
	ANIM_FLYGRABCLOSED = 0x1C8,
	ANIM_FLYGRABTHROWN = 0x1C9,
	ANIM_TOFLY = 0x1CA,
	ANIM_TOHOVER = 0x1CB,
	ANIM_TOGROUND = 0x1CC,
	ANIM_FLYTOFLY = 0x1CD,
	ANIM_FLYTOHOVER = 0x1CE,
	ANIM_FLYTOGROUND = 0x1CF,
	ANIM_SETTLE = 0x1D0,
	ANIM_FLYSETTLE = 0x1D1,
	ANIM_DEATHSTART = 0x1D2,
	ANIM_DEATHLOOP = 0x1D3,
	ANIM_DEATHEND = 0x1D4,
	ANIM_FLYDEATHSTART = 0x1D5,
	ANIM_FLYDEATHLOOP = 0x1D6,
	ANIM_FLYDEATHEND = 0x1D7,
	ANIM_DEATHENDHOLD = 0x1D8,
	ANIM_FLYDEATHENDHOLD = 0x1D9,
	ANIM_STRANGULATE = 0x1DA,
	ANIM_FLYSTRANGULATE = 0x1DB,
	ANIM_READYJOUST = 0x1DC,
	ANIM_LOADJOUST = 0x1DD,
	ANIM_HOLDJOUST = 0x1DE,
	ANIM_FLYREADYJOUST = 0x1DF,
	ANIM_FLYLOADJOUST = 0x1E0,
	ANIM_FLYHOLDJOUST = 0x1E1,
	ANIM_ATTACKJOUST = 0x1E2,
	ANIM_FLYATTACKJOUST = 0x1E3,
	ANIM_RECLINEDMOUNT = 0x1E4,
	ANIM_FLYRECLINEDMOUNT = 0x1E5,
	ANIM_TOALTERED = 0x1E6,
	ANIM_FROMALTERED = 0x1E7,
	ANIM_FLYTOALTERED = 0x1E8,
	ANIM_FLYFROMALTERED = 0x1E9,
	ANIM_INSTOCKS = 0x1EA,
	ANIM_FLYINSTOCKS = 0x1EB,
	ANIM_VEHICLEGRAB = 0x1EC,
	ANIM_VEHICLETHROW = 0x1ED,
	ANIM_FLYVEHICLEGRAB = 0x1EE,
	ANIM_FLYVEHICLETHROW = 0x1EF,
	ANIM_TOALTEREDPOSTSWAP = 0x1F0,
	ANIM_FROMALTEREDPOSTSWAP = 0x1F1,
	ANIM_FLYTOALTEREDPOSTSWAP = 0x1F2,
	ANIM_FLYFROMALTEREDPOSTSWAP = 0x1F3,
	ANIM_RECLINEDMOUNTPASSENGER = 0x1F4,
	ANIM_FLYRECLINEDMOUNTPASSENGER = 0x1F5,
	ANIM_CARRY2H = 0x1F6,
	ANIM_CARRIED2H = 0x1F7,
	ANIM_FLYCARRY2H = 0x1F8,
	ANIM_FLYCARRIED2H = 0x1F9,
	ANIM_EMOTESNIFF = 0x1FA,
	ANIM_EMOTEFLYSNIFF = 0x1FB,
	ANIM_ATTACKFIST1H = 0x1FC,
	ANIM_FLYATTACKFIST1H = 0x1FD,
	ANIM_ATTACKFIST1HOFF = 0x1FE,
	ANIM_FLYATTACKFIST1HOFF = 0x1FF,
	ANIM_PARRYFIST1H = 0x200,
	ANIM_FLYPARRYFIST1H = 0x201,
	ANIM_READYFIST1H = 0x202,
	ANIM_FLYREADYFIST1H = 0x203,
	ANIM_SPECIALFIST1H = 0x204,
	ANIM_FLYSPECIALFIST1H = 0x205,
	ANIM_EMOTEREADSTART = 0x206,
	ANIM_FLYEMOTEREADSTART = 0x207,
	ANIM_EMOTEREADLOOP = 0x208,
	ANIM_FLYEMOTEREADLOOP = 0x209,
	ANIM_EMOTEREADEND = 0x20A,
	ANIM_FLYEMOTEREADEND = 0x20B,
	ANIM_SWIMRUN = 0x20C,
	ANIM_FLYSWIMRUN = 0x20D,
	ANIM_SWIMWALK = 0x20E,
	ANIM_FLYSWIMWALK = 0x20F,
	ANIM_SWIMWALKBACKWARDS = 0x210,
	ANIM_FLYSWIMWALKBACKWARDS = 0x211,
	ANIM_SWIMSPRINT = 0x212,
	ANIM_FLYSWIMSPRINT = 0x213,
	ANIM_MOUNTSWIMIDLE = 0x214,
	ANIM_FLYMOUNTSWIMIDLE = 0x215,
	ANIM_MOUNTSWIMBACKWARDS = 0x216,
	ANIM_FLYMOUNTSWIMBACKWARDS = 0x217,
	ANIM_MOUNTSWIMLEFT = 0x218,
	ANIM_FLYMOUNTSWIMLEFT = 0x219,
	ANIM_MOUNTSWIMRIGHT = 0x21A,
	ANIM_FLYMOUNTSWIMRIGHT = 0x21B,
	ANIM_MOUNTSWIMRUN = 0x21C,
	ANIM_FLYMOUNTSWIMRUN = 0x21D,
	ANIM_MOUNTSWIMSPRINT = 0x21E,
	ANIM_FLYMOUNTSWIMSPRINT = 0x21F,
	ANIM_MOUNTSWIMWALK = 0x220,
	ANIM_FLYMOUNTSWIMWALK = 0x221,
	ANIM_MOUNTSWIMWALKBACKWARDS = 0x222,
	ANIM_FLYMOUNTSWIMWALKBACKWARDS = 0x223,
	ANIM_MOUNTFLIGHTIDLE = 0x224,
	ANIM_FLYMOUNTFLIGHTIDLE = 0x225,
	ANIM_MOUNTFLIGHTBACKWARDS = 0x226,
	ANIM_FLYMOUNTFLIGHTBACKWARDS = 0x227,
	ANIM_MOUNTFLIGHTLEFT = 0x228,
	ANIM_FLYMOUNTFLIGHTLEFT = 0x229,
	ANIM_MOUNTFLIGHTRIGHT = 0x22A,
	ANIM_FLYMOUNTFLIGHTRIGHT = 0x22B,
	ANIM_MOUNTFLIGHTRUN = 0x22C,
	ANIM_FLYMOUNTFLIGHTRUN = 0x22D,
	ANIM_MOUNTFLIGHTSPRINT = 0x22E,
	ANIM_FLYMOUNTFLIGHTSPRINT = 0x22F,
	ANIM_MOUNTFLIGHTWALK = 0x230,
	ANIM_FLYMOUNTFLIGHTWALK = 0x231,
	ANIM_MOUNTFLIGHTWALKBACKWARDS = 0x232,
	ANIM_FLYMOUNTFLIGHTWALKBACKWARDS = 0x233,
	ANIM_MOUNTFLIGHTSTART = 0x234,
	ANIM_FLYMOUNTFLIGHTSTART = 0x235,
	ANIM_MOUNTSWIMSTART = 0x236,
	ANIM_FLYMOUNTSWIMSTART = 0x237,
	ANIM_MOUNTSWIMLAND = 0x238,
	ANIM_FLYMOUNTSWIMLAND = 0x239,
	ANIM_MOUNTSWIMLANDRUN = 0x23A,
	ANIM_FLYMOUNTSWIMLANDRUN = 0x23B,
	ANIM_MOUNTFLIGHTLAND = 0x23C,
	ANIM_FLYMOUNTFLIGHTLAND = 0x23D,
	ANIM_MOUNTFLIGHTLANDRUN = 0x23E,
	ANIM_FLYMOUNTFLIGHTLANDRUN = 0x23F,
	ANIM_READYBLOWDART = 0x240,
	ANIM_FLYREADYBLOWDART = 0x241,
	ANIM_LOADBLOWDART = 0x242,
	ANIM_FLYLOADBLOWDART = 0x243,
	ANIM_HOLDBLOWDART = 0x244,
	ANIM_FLYHOLDBLOWDART = 0x245,
	ANIM_ATTACKBLOWDART = 0x246,
	ANIM_FLYATTACKBLOWDART = 0x247,
	ANIM_CARRIAGEMOUNT = 0x248,
	ANIM_FLYCARRIAGEMOUNT = 0x249,
	ANIM_CARRIAGEPASSENGERMOUNT = 0x24A,
	ANIM_FLYCARRIAGEPASSENGERMOUNT = 0x24B,
	ANIM_CARRIAGEMOUNTATTACK = 0x24C,
	ANIM_FLYCARRIAGEMOUNTATTACK = 0x24D,
	ANIM_BARTENDERSTAND = 0x24E,
	ANIM_FLYBARTENDERSTAND = 0x24F,
	ANIM_BARTENDERWALK = 0x250,
	ANIM_FLYBARTENDERWALK = 0x251,
	ANIM_BARTENDERRUN = 0x252,
	ANIM_FLYBARTENDERRUN = 0x253,
	ANIM_BARTENDERSHUFFLELEFT = 0x254,
	ANIM_FLYBARTENDERSHUFFLELEFT = 0x255,
	ANIM_BARTENDERSHUFFLERIGHT = 0x256,
	ANIM_FLYBARTENDERSHUFFLERIGHT = 0x257,
	ANIM_BARTENDEREMOTETALK = 0x258,
	ANIM_FLYBARTENDEREMOTETALK = 0x259,
	ANIM_BARTENDEREMOTEPOINT = 0x25A,
	ANIM_FLYBARTENDEREMOTEPOINT = 0x25B,
	ANIM_BARMAIDSTAND = 0x25C,
	ANIM_FLYBARMAIDSTAND = 0x25D,
	ANIM_BARMAIDWALK = 0x25E,
	ANIM_FLYBARMAIDWALK = 0x25F,
	ANIM_BARMAIDRUN = 0x260,
	ANIM_FLYBARMAIDRUN = 0x261,
	ANIM_BARMAIDSHUFFLELEFT = 0x262,
	ANIM_FLYBARMAIDSHUFFLELEFT = 0x263,
	ANIM_BARMAIDSHUFFLERIGHT = 0x264,
	ANIM_FLYBARMAIDSHUFFLERIGHT = 0x265,
	ANIM_BARMAIDEMOTETALK = 0x266,
	ANIM_FLYBARMAIDEMOTETALK = 0x267,
	ANIM_BARMAIDEMOTEPOINT = 0x268,
	ANIM_FLYBARMAIDEMOTEPOINT = 0x269,
	ANIM_MOUNTSELFIDLE = 0x26A,
	ANIM_FLYMOUNTSELFIDLE = 0x26B,
	ANIM_MOUNTSELFWALK = 0x26C,
	ANIM_FLYMOUNTSELFWALK = 0x26D,
	ANIM_MOUNTSELFRUN = 0x26E,
	ANIM_FLYMOUNTSELFRUN = 0x26F,
	ANIM_MOUNTSELFSPRINT = 0x270,
	ANIM_FLYMOUNTSELFSPRINT = 0x271,
	ANIM_MOUNTSELFRUNLEFT = 0x272,
	ANIM_FLYMOUNTSELFRUNLEFT = 0x273,
	ANIM_MOUNTSELFRUNRIGHT = 0x274,
	ANIM_FLYMOUNTSELFRUNRIGHT = 0x275,
	ANIM_MOUNTSELFSHUFFLELEFT = 0x276,
	ANIM_FLYMOUNTSELFSHUFFLELEFT = 0x277,
	ANIM_MOUNTSELFSHUFFLERIGHT = 0x278,
	ANIM_FLYMOUNTSELFSHUFFLERIGHT = 0x279,
	ANIM_MOUNTSELFWALKBACKWARDS = 0x27A,
	ANIM_FLYMOUNTSELFWALKBACKWARDS = 0x27B,
	ANIM_MOUNTSELFSPECIAL = 0x27C,
	ANIM_FLYMOUNTSELFSPECIAL = 0x27D,
	ANIM_MOUNTSELFJUMP = 0x27E,
	ANIM_FLYMOUNTSELFJUMP = 0x27F,
	ANIM_MOUNTSELFJUMPSTART = 0x280,
	ANIM_FLYMOUNTSELFJUMPSTART = 0x281,
	ANIM_MOUNTSELFJUMPEND = 0x282,
	ANIM_FLYMOUNTSELFJUMPEND = 0x283,
	ANIM_MOUNTSELFJUMPLANDRUN = 0x284,
	ANIM_FLYMOUNTSELFJUMPLANDRUN = 0x285,
	ANIM_MOUNTSELFSTART = 0x286,
	ANIM_FLYMOUNTSELFSTART = 0x287,
	ANIM_MOUNTSELFFALL = 0x288,
	ANIM_FLYMOUNTSELFFALL = 0x289,
	ANIM_STORMSTRIKE = 0x28A,
	ANIM_FLYSTORMSTRIKE = 0x28B,
	ANIM_READYJOUSTNOSHEATHE = 0x28C,
	ANIM_FLYREADYJOUSTNOSHEATHE = 0x28D
};

//UNIT_FIELD_BYTES_1
enum StandState
{
	STANDSTATE_STAND			 = 0,
	STANDSTATE_SIT				 = 1,
	STANDSTATE_SIT_CHAIR		 = 2,
	STANDSTATE_SLEEP			 = 3,
	STANDSTATE_SIT_LOW_CHAIR	 = 4,
	STANDSTATE_SIT_MEDIUM_CHAIR  = 5,
	STANDSTATE_SIT_HIGH_CHAIR    = 6,
	STANDSTATE_DEAD				 = 7,
	STANDSTATE_KNEEL			 = 8,
	STANDSTATE_SUBMERGE			 = 9,
    STANDSTATE_FLAG_CREEP2       = 0x00020000,	//confirmed in 14454 client
	STANDSTATE_FORM_ALL          = 0x00FF0000,
    STANDSTATE_FLAG_ALWAYS_STAND = 0x01000000,                  // byte 4
    STANDSTATE_FLAG_CREEP        = 0x02000000,
    STANDSTATE_FLAG_UNTRACKABLE  = 0x04000000,
    STANDSTATE_FLAG_ALL          = 0xFF000000,
};

enum UnitSpecialStates
{
	UNIT_STATE_NORMAL    = 0x0000,
	UNIT_STATE_DISARMED  = 0X0001,
	UNIT_STATE_CHARM     = 0x0002,
	UNIT_STATE_FEAR      = 0x0004,
	UNIT_STATE_ROOT      = 0x0008,
	UNIT_STATE_SLEEP     = 0x0010,  // never set
	UNIT_STATE_SNARE     = 0x0020,  // never set
	UNIT_STATE_STUN      = 0x0040,
	UNIT_STATE_KNOCKOUT  = 0x0080,  // not used
	UNIT_STATE_BLEED     = 0x0100,  // not used
	UNIT_STATE_POLYMORPH = 0x0200,  // not used
	UNIT_STATE_BANISH    = 0x0400,  // not used
	UNIT_STATE_CONFUSE   = 0x0800,
	UNIT_STATE_PACIFY    = 0x1000,
	UNIT_STATE_SILENCE   = 0x2000,
	UNIT_STATE_FROZEN    = 0x4000,
};

enum UnitFieldBytes1_byte0
{
	U_FIELD_BYTES_ANIMATION_FROZEN = 0x01,		//not sure name is right, this is mostly set by all units on blizz
};

//note to self : do not forget to search for something like 0x0100 since it is byte 1
enum UnitFieldBytes2_byte1
{
	UNIT_BYTE2_FLAG_PVP     = 0x01, //byte 1 it is actually 256 = 0x100
	UNIT_BYTE2_FLAG_UNK1    = 0x02,
	UNIT_BYTE2_FLAG_FFA_PVP = 0x04,
	UNIT_BYTE2_FLAG_UNK3    = 0x08, //disables PVP. Players see him with blue circle
	UNIT_BYTE2_FLAG_AURAS   = 0x10,                         // show possitive auras as positive, and allow its dispel
	UNIT_BYTE2_FLAG_UNK5    = 0x20,
	UNIT_BYTE2_FLAG_UNK6    = 0x40,
	UNIT_BYTE2_FLAG_UNK7    = 0x80
};

enum UnitFieldBytes2_byte2
{
	UNIT_BYTE2_FLAG_RENAME			= 0x01, 
	UNIT_BYTE2_FLAG_PET_DETAILS		= 0x02, 
	UNIT_BYTE2_FLAG_unk0x1000000	= 0x1000000,
	UNIT_BYTE2_FLAG_unk0x10000000	= 0x10000000,
};

enum UnitFieldFlags // UNIT_FIELD_FLAGS #46 - these are client flags
{	//                                            Hex    Bit     Decimal  Comments
	UNIT_FLAG_UNKNOWN_1                  = 0x00000001, // 1            1
	UNIT_FLAG_NOT_ATTACKABLE_2           = 0x00000002, // 2            2  client won't let you attack them
	UNIT_FLAG_LOCK_PLAYER                = 0x00000004, // 3            4  ? does nothing to client (probably wrong) - only taxi code checks this
	UNIT_FLAG_PLAYER_CONTROLLED          = 0x00000008, // 4            8  makes players and NPCs attackable / not attackable
	UNIT_FLAG_UNKNOWN_5                  = 0x00000010, // 5           16  ? some NPCs have this
	UNIT_FLAG_PREPARATION                = 0x00000020, // 6           32  ? accroding to aspire : don't take reagents for spells with SPELL_ATTR_EX5_NO_REAGENT_WHILE_PREP
	UNIT_FLAG_PLUS_MOB                   = 0x00000040, // 7           64  ? some NPCs have this (Rare/Elite/Boss?)
	UNIT_FLAG_UNKNOWN_8                  = 0x00000080, // 8          128  ? can change attackable status 
	UNIT_FLAG_NOT_ATTACKABLE_9           = 0x00000100, // 9          256  changes attackable status
	UNIT_FLAG_PASSIVE	                 = 0x00000200, // 10         512  ? unless provoked it will not agro others
	UNIT_FLAG_LOOTING                    = 0x00000400, // 11        1024
	UNIT_FLAG_SELF_RES                   = 0x00000800, // 12        2048  ? some NPCs have this
	UNIT_FLAG_PVP                        = 0x00001000, // 13        4096  sets PvP flag
	UNIT_FLAG_SILENCED                   = 0x00002000, // 14        8192
	UNIT_FLAG_DEAD                       = 0x00004000, // 15       16384  used for special "dead" NPCs like Withered Corpses
	UNIT_FLAG_UNKNOWN_16                 = 0x00008000, // 16       32768  ? some NPCs have this. cannot attack ?
	UNIT_FLAG_ALIVE                      = 0x00010000, // 17       65536  ?
	UNIT_FLAG_PACIFIED                   = 0x00020000, // 18      131072
	UNIT_FLAG_STUNNED                    = 0x00040000, // 19      262144 //lock orientation control
	UNIT_FLAG_COMBAT                     = 0x00080000, // 20      524288  sets combat flag
	UNIT_FLAG_MOUNTED_TAXI               = 0x00100000, // 21     1048576  mounted on a taxi
	UNIT_FLAG_DISARMED                   = 0x00200000, // 22     2097152
	UNIT_FLAG_CONFUSED                   = 0x00400000, // 23     4194304
	UNIT_FLAG_FLEEING                    = 0x00800000, // 24     8388608  fear
	UNIT_FLAG_PLAYER_CONTROLLED_CREATURE = 0x01000000, // 25    16777216
	UNIT_FLAG_NOT_SELECTABLE             = 0x02000000, // 26    33554432  cannot select the unit
	UNIT_FLAG_SKINNABLE                  = 0x04000000, // 27    67108864
	UNIT_FLAG_MOUNTABLE                  = 0x08000000, // 28   134217728  ? was MAKE_CHAR_UNTOUCHABLE (probably wrong), nothing ever set it
	UNIT_FLAG_UNKNOWN_29                 = 0x10000000, // 29   268435456
	UNIT_FLAG_FEIGN_DEATH                = 0x20000000, // 30   536870912
	UNIT_FLAG_UNKNOWN_31                 = 0x40000000, // 31  1073741824  ? was WEAPON_OFF and being used for disarm
	UNIT_FLAG_UNKNOWN_32                 = 0x80000000, // 32  2147483648
};

enum UnitFieldFlags2
{
    UNIT_FLAG2_FEIGN_DEATH          = 0x00000001,
    UNIT_FLAG2_UNK1                 = 0x00000002,               // Hide unit model (show only player equip)
    UNIT_FLAG2_COMPREHEND_LANG      = 0x00000008,
    UNIT_FLAG2_MIRROR_IMAGE         = 0x00000010,
    UNIT_FLAG2_FORCE_MOVE           = 0x00000040,
    UNIT_FLAG2_DISARM_OFFHAND       = 0x00000080,
    UNIT_FLAG2_DISARM_RANGED        = 0x00000400,               //this does not disable ranged weapon display (maybe additional flag needed?)
	UNIT_FLAG2_ENABLE_POWER_REGEN	= 0x00000800,
//	UNIT_FLAG2_WORGEN_TRANSFORM     = 0x00080000,           // transform to worgen
//	UNIT_FLAG2_WORGEN_TRANSFORM2    = 0x00100000,           // transform to worgen, but less animation?
//	UNIT_FLAG2_WORGEN_TRANSFORM3    = 0x00200000            // transform to worgen, but less animation?
};

enum UnitDynamicFlags
{
	U_DYN_FLAG_LOOTABLE				 = 0x01,
	U_DYN_FLAG_UNIT_TRACKABLE		   = 0x02,
	U_DYN_FLAG_TAGGED_BY_OTHER		  = 0x04,
	U_DYN_FLAG_TAPPED_BY_PLAYER		 = 0x08,
	U_DYN_FLAG_PLAYER_INFO			  = 0x10,
	U_DYN_FLAG_DEAD					 = 0x20,
};

#define	GENDER_MALE		0
#define	GENDER_FEMALE	1

enum DamageFlags
{
	DAMAGE_FLAG_MELEE   = 1,
	DAMAGE_FLAG_HOLY	= 2,
	DAMAGE_FLAG_FIRE	= 4,
	DAMAGE_FLAG_NATURE  = 8,
	DAMAGE_FLAG_FROST   = 16,
	DAMAGE_FLAG_SHADOW  = 32,
	DAMAGE_FLAG_ARCANE  = 64
};

enum WeaponDamageType // this is NOT the same as SPELL_ENTRY_Spell_Dmg_Type, or Spell::GetType(), or SPELL_ENTRY_School !!
{
	MELEE   = 0,
	OFFHAND = 1,
	RANGED  = 2,
};

enum VisualState
{
	ATTACK = 1,
	DODGE,
	PARRY,
	INTERRUPT,
	BLOCK,
	EVADE,
	IMMUNE,
	DEFLECT
};
/*
enum HitStatus
{
	HITSTATUS_unk			= 0x01,
	HITSTATUS_HITANIMATION  = 0x02,
	HITSTATUS_DUALWIELD     = 0x04,
	HITSTATUS_MISS          = 0x10,
	HITSTATUS_ABSORBED      = 0x20,
	HITSTATUS_RESIST        = 0x40,
//	HITSTATUS_CRICTICAL     = 0x80,
	HITSTATUS_CRICTICAL     = 0x200,
	HITSTATUS_BLOCK         = 0x800,
//	HITSTATUS_GLANCING      = 0x4000,
	HITSTATUS_CRUSHINGBLOW  = 0x8000,
	HITSTATUS_GLANCING      = 0x10000,
//	HITSTATUS_NOACTION      = 0x10000,
	HITSTATUS_SWINGNOHITSOUND = 0x80000 // as in miss?
};*/

enum HitStatus
{
	HITSTATUS_UNK				= 0x01,
	HITSTATUS_HITANIMATION		= 0x02,
	HITSTATUS_DUALWIELD			= 0x04,
	HITSTATUS_MISS				= 0x10,
	HITSTATUS_ABSORBED			= 0x20 | 0x40,
	HITSTATUS_RESIST			= 0x80 | 0x100,
	HITSTATUS_CRICTICAL			= 0x200,
	HITSTATUS_BLOCK				= 0x2000,
	HITSTATUS_CRUSHINGBLOW		= 0x8000,
	HITSTATUS_GLANCING			= 0x10000,
	HITSTATUS_NOACTION			= 0x10000,
	HITSTATUS_SWINGNOHITSOUND	= 0x80000, // as in miss?
	HITSTATUS_CRITICAL_BLOCK    = HITSTATUS_BLOCK,		//maybe some additional flags should be sent ?
	HITSTATUS_UNK2              = 0x00800000
};

enum INVIS_FLAG
{
	INVIS_FLAG_NORMAL		= (1<<0), // players and units with no special invisibility flags
	INVIS_FLAG_SPIRIT1		= (1<<1), // Elemental Spirit Invisibility
	INVIS_FLAG_SPIRIT2		= (1<<2), // Spirit Spawn-out
	INVIS_FLAG_TRAP			= (1<<3),
	INVIS_FLAG_QUEST		= (1<<4), // Caer Darrow Ghosts
	INVIS_FLAG_GHOST		= (1<<5), // Dungeon Set 2.0 Ghosts
	INVIS_FLAG_UNKNOWN6		= (1<<6), // Drunk Invisibility (Pink)
	INVIS_FLAG_UNKNOWN7		= (1<<7), // Vaelen the Flayed [The Shadow Vault] - Invisibility
	INVIS_FLAG_SHADOWMOON	= (1<<8), // Triangulation Point One Invisibility
	INVIS_FLAG_NETHERSTORM	= (1<<9), // Banshee's Revenge: Balargarde Force's Invis & See Invis
	INVIS_FLAG_BASHIR		= (1<<10), // Shroud of the Scourge
	INVIS_FLAG_JUNGLE		= (1<<11), // BOTM - Jungle Brew - Jungle Invisibility Aura
	INVIS_FLAG_UNKNOWN8		= (1<<12), // Apply Quest Invis Zone 4
	INVIS_FLAG_UNKNOWN9		= (1<<13), // Generic Quest Invisibility 5
	INVIS_FLAG_UNKNOWN10	= (1<<14), // Apply Quest Invis Zone 6
	INVIS_FLAG_UNKNOWN11	= (1<<15), // Fourth and Goal: Cat's Mark Aura & Invis
	INVIS_FLAG_UNKNOWN12	= (1<<16), // Generic Quest Invisibility 8
	INVIS_FLAG_UNKNOWN13	= (1<<17), // Apply Quest Invis Zone 9
	INVIS_FLAG_UNKNOWN14	= (1<<18), // Generic Quest Invisibility 10
	INVIS_FLAG_UNKNOWN15	= (1<<19), // Apply Quest Invis Zone 11
	INVIS_FLAG_UNKNOWN16	= (1<<20), // Apply Quest Invis Zone 12
	INVIS_FLAG_UNKNOWN17	= (1<<21), // Apply Quest Invis Zone 13
	INVIS_FLAG_UNKNOWN18	= (1<<22), // Apply Quest Invis Zone 14
	INVIS_FLAG_UNKNOWN19	= (1<<23), // Apply Quest Invis Zone 15
	INVIS_FLAG_UNKNOWN20	= (1<<24), // Apply Quest Invis Zone 16
	INVIS_FLAG_UNKNOWN21	= (1<<25), // Apply Quest Invis Zone 17
	INVIS_FLAG_UNKNOWN22	= (1<<26), // Apply Quest Invis Zone 18
	INVIS_FLAG_UNKNOWN23	= (1<<27), // Apply Quest Invis Zone 19
//	INVIS_FLAG_UNKNOWN24	= (1<<28), // Showdown Phase Shift
	INVIS_FLAG_CUSTOM_SPECTATE	= (1<<28), // Player Spectator mode. Should not have detection for this invisibility mode
	INVIS_FLAG_CUSTOM_SCRIPTS	= (1<<29), // Generic Quest Invisibility 21
	INVIS_FLAG_CUSTOM_SMOKEBOMB	= (1<<30), // Generic Quest Invisibility 22
	INVIS_FLAG_CUSTOM_GM	= (1<<31), // Generic Quest Invisibility 23
//	INVIS_FLAG_UNKNOWN28	= (((uint64)1)<<32), // Generic Quest Invisibility 24
//	INVIS_FLAG_UNKNOWN29	= (((uint64)1)<<33), // Quest Invisibility 25
//	INVIS_FLAG_UNKNOWN30	= (((uint64)1)<<34), // Generic Quest Invisibility 26
//	INVIS_FLAG_UNKNOWN31	= (((uint64)1)<<35), // Generic Quest Invisibility 27
//	INVIS_FLAG_UNKNOWN32	= (((uint64)1)<<36), // Generic Quest Invisibility 28
//	INVIS_FLAG_UNKNOWN44	= (((uint64)1)<<37), // Anduin Wrynn Quest Invis
	INVIS_FLAG_TOTAL		= 38 //there are 38. We implement only 32
};

struct AuraCheckResponse
{
	uint32 Error;
//	uint32 Misc;
};

enum AURA_CHECK_RESULT
{
	AURA_CHECK_RESULT_NONE				    = 1,
	AURA_CHECK_RESULT_HIGHER_BUFF_PRESENT   = 2,
	AURA_CHECK_RESULT_LOWER_BUFF_PRESENT	= 3,
	AURA_CHECK_RESULT_CANNOT_STACK			= 4,
};

typedef std::list<struct ProcTriggerSpellOnSpell> ProcTriggerSpellOnSpellList;

class SERVER_DECL UnitChain
{
public:
	UnitChain(bool persist = false, float chainrange = 0.0f) : m_persist(persist), m_chainrange(chainrange) {}
	
	float m_chainrange;
	bool m_persist;
	std::set<Unit*> m_units;
	void AddUnit(Unit* u);
	void RemoveUnit(Unit* u);
};

class UnitSMMods
{
public:
	UnitSMMods();
	~UnitSMMods();
	void InheritFrom(UnitSMMods *ParentMods);
	int32 * SM_FCriticalChance;//flat
	int32 * SM_FCriticalChanceTarget;//flat
	int32 * SM_FDur;//flat
	int32 * SM_PDur;//pct
	int32 * SM_PRadius;//pct
	int32 * SM_FRadius;//flat
	int32 * SM_PRange;//pct
	int32 * SM_FRange;//flat
	int32 * SM_PCastTime;//pct
	int32 * SM_FCastTime;//flat
	int32 * SM_PCriticalDamage;
	int32 * SM_PDOT;//pct
	int32 * SM_FDOT;//flat
	int32 * SM_FEffectBonus;//flat
	int32 * SM_FEffectTargetBonus;//flat
	int32 * SM_PEffectBonus;//pct
	int32 * SM_PEffectTargetBonus;//pct
	int32 * SM_FDamageBonus;//flat
	int32 * SM_PDamageBonus;//pct
	int32 * SM_PMiscEffect;//pct
	int32 * SM_FMiscEffect;//flat
	int32 * SM_FHitchance;//flat
	int32 * SM_PAPBonus;//pct
	int32 * SM_PCost;
	int32 * SM_FCost;
	int32 * SM_PNonInterrupt;
	int32 * SM_PJumpReduce;
	int32 * SM_FSpeedMod;
	int32 * SM_FAdditionalTargets;
//	int32 * SM_FPenalty;//flat
	int32 * SM_PPenalty;//Pct
	int32 * SM_PCooldownTime;
	int32 * SM_FCooldownTime;
	int32 * SM_FGlobalCooldownTime;
	int32 * SM_FChanceOfSuccess;
	int32 * SM_FRezist_dispell;
	int32 * SM_PRezist_dispell;
	int32 * SM_FCharges;
	int32 * SM_PCharges;
	int32 * SM_FThreat;
	int32 * SM_PThreat;
	int32 * SM_FTime;		//tick interval reduction
	int32 * SM_FAddEffect1;	//CUSTOM!
	int32 * SM_FAddEffect2;	//CUSTOM!
	int32 * SM_FAddEffect3;	//CUSTOM!
	int32 * SM_PAddEffect1;	//CUSTOM!
	int32 * SM_PAddEffect2;	//CUSTOM!
	int32 * SM_PAddEffect3;	//CUSTOM!
	int32 * SM_FAddEffect_DUMMY;	//CUSTOM! Client side only
	int32 * SM_PAddEffect_DUMMY;	//CUSTOM! Client side only
};
/************************************************************************/
/* "In-Combat" Handler                                                  */
/************************************************************************/

class Unit;
typedef set<uint64> AttackerMap;
//when unit 1 makes a direct hit on unit 2, both will get an out of combat timer
//if unit 1 or unit 2 manages to avoid offensive actions for 5 seconds, he will get out of combat
class SERVER_DECL CombatStatusHandler
{
	Unit* m_Unit;
	bool m_lastStatus;

public:
	CombatStatusHandler()
	{
		m_lastStatus = false;
	}
	void OnDamageDealt(Unit * pTarget, bool IsDOT = false );		// this is what puts the other person in combat.
	void BreakCombatLink(Unit * pTarget, uint8 ChainCall=0);		// this should be called if one of them leaves the map or dies
	bool IsInCombat();												// checks if we are in combat or not.
	ARCEMU_INLINE void SetUnit(Unit * p)							// for pvp timeout
	{ 
		m_Unit = p; 
	}
	void ClearAttackers();											// means we vanished, or died.
	AttackerMap m_CombatTargets;	//attackers or targetets

protected:
	bool InternalIsInCombat();										// called by UpdateFlag, do not call from anything else!
	bool IsAttacking(Unit * pTarget);								// internal function used to determine if we are still attacking target x.
	void AddAttacker(const uint64& guid);							// internal function to add an attacker
	void UpdateFlag();												// detects if we have changed combat state (in/out), and applies the flag.
};

//====================================================================
//  Unit
//  Base object for Players and Creatures
//====================================================================

class SERVER_DECL Unit : public Object
{
public:
	/************************************************************************/
	/* LUA Stuff                                                            */
	/************************************************************************/
/*	typedef struct { const char *name; int(*mfunc)(lua_State*,Unit*); } RegType;
	static const char className[];
	static RegType methods[];
	
	// a lua script cannot create a unit.
	Unit(lua_State * L) { ASSERT(false); }*/

	void CombatStatusHandler_UpdatePvPTimeout();
	void CombatStatusHandler_ResetPvPTimeout();
	uint32 CombatStatusHandler_GetAttackerCount() { return (uint32)CombatStatus.m_CombatTargets.size(); };
	uint32 CombatStatusHandler_GetAttackerIndex(const uint64 &guid) 
	{ 
		AttackerMap::iterator itr;
		uint32 index=1;
		for(itr = CombatStatus.m_CombatTargets.begin(); itr != CombatStatus.m_CombatTargets.end(); itr++)
		{
			if( *itr == guid )
				return index;
			index++;
		}
		return index; 
	};

	virtual ~Unit ( );
	virtual void Virtual_Destructor( );

	friend class AIInterface;
	friend class Aura;

	virtual void Update( uint32 time );
	virtual void RemoveFromWorld(bool free_guid);
	virtual void OnPushToWorld();

    void setAttackTimer(int32 time, bool offhand);
	bool isAttackReady(bool offhand);

	ARCEMU_INLINE void SetDualWield(bool enabled)
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_dualWield = enabled;
	}

	bool __fastcall canReachWithAttack(Unit *pVictim);

  //void StrikeWithAbility( Unit* pVictim, Spell* spell, uint32 addspelldmg, uint32 weapon_damage_type );

	/// State flags are server-only flags to help me know when to do stuff, like die, or attack
	ARCEMU_INLINE void addStateFlag(uint32 f) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_state |= f; 
	}
	ARCEMU_INLINE bool hasStateFlag(uint32 f) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return (m_state & f ? true : false); 
	}
	ARCEMU_INLINE void clearStateFlag(uint32 f) 
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_state &= ~f; 
	}

	/// Stats
	ARCEMU_INLINE uint32 getLevel() { return m_uint32Values[ UNIT_FIELD_LEVEL ]; };
	ARCEMU_INLINE uint8 getRace() { return GetByte(UNIT_FIELD_BYTES_0,0); }
	ARCEMU_INLINE uint8 getClass() { return GetByte(UNIT_FIELD_BYTES_0,1); }
	ARCEMU_INLINE void setRace(uint8 race) { SetByte(UNIT_FIELD_BYTES_0,0,race); }
	ARCEMU_INLINE void setClass(uint8 class_) { SetByte(UNIT_FIELD_BYTES_0,1, class_ ); }
	ARCEMU_INLINE uint32 getClassMask() { return 1 << (getClass() - 1); }
	ARCEMU_INLINE uint32 getRaceMask() { return 1 << (getRace() - 1); }
	ARCEMU_INLINE uint8 getGender() { return GetByte(UNIT_FIELD_BYTES_0,2); }
	ARCEMU_INLINE void setGender(uint8 gender) { SetByte(UNIT_FIELD_BYTES_0,2,gender); }
	ARCEMU_INLINE uint8 getStandState() { return ((uint8)m_uint32Values[UNIT_FIELD_BYTES_1]); }
 
	//// Combat
   // void DealDamage(Unit *pVictim, uint32 damage, uint32 targetEvent, uint32 unitEvent, uint32 spellId = 0);   // to stop from falling, etc
	//void AttackerStateUpdate( Unit* pVictim, uint32 weapon_damage_type ); // weapon_damage_type: 0 = melee, 1 = offhand(dualwield), 2 = ranged
	uint32 GetSpellDidHitResult( Unit* pVictim, uint32 weapon_damage_type, SpellEntry* ability );
	void Strike( Unit* pVictim, uint32 weapon_damage_type, SpellEntry* ability, int32 add_damage, int32 pct_dmg_mod, uint32 exclusive_damage, bool disable_proc, bool skip_hit_check );
//	void PeriodicAuraLog(Unit *pVictim, SpellEntry* spellID, uint32 damage, uint32 damageType);
	//void SpellNonMeleeDamageLog(Unit *pVictim, uint32 spellID, uint32 damage);
	uint32 m_procCounter;
//	uint32 HandleProc(uint32 flag, Unit* victim, SpellEntry* CastingSpell,uint32 dmg=-1,uint32 Abs=0);
	uint32 HandleProc(uint32 flag, Unit* victim, SpellEntry* CastingSpell,int32 *dmg = NULL,int32 *Abs = NULL);
	void HandleProcDmgShield(uint32 flag, Unit* attacker);//almost the same as handleproc :P
//	void HandleProcSpellOnSpell(Unit* Victim,uint32 damage,bool critical);//nasty, some spells proc other spells

	void RemoveExtraStrikeTarget(SpellEntry *spell_info);
	void AddExtraStrikeTarget(SpellEntry *spell_info, uint32 charges);

	int32 GetAP();
	int32 GetRAP();
	float GetSpellHaste() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		float temp_ret = GetFloatValue( UNIT_MOD_CAST_HASTE );
		if( temp_ret < 0.30f )
			return 0.30f;
		return temp_ret;
	}
	float GetSpellHasteDots() 
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return MAX(GetSpellHaste(),0.45f);
	}

	uint8 CastSpell(Unit* Target, uint32 SpellID, bool triggered);
	uint8 CastSpell(Unit* Target, SpellEntry* Sp, bool triggered);
	uint8 CastSpell(uint64 targetGuid, uint32 SpellID, bool triggered);
	uint8 CastSpell(const uint64 &targetGuid, SpellEntry* Sp, bool triggered );
	void CastSpellAoF(Unit *SuggestedTarget, float x,float y,float z,SpellEntry* Sp, bool triggered);
	void EventCastSpell3(SpellCastTargets targets, SpellEntry * Sp);
	void EventCastSpell2(uint64 targetGuid, uint32 SpellID, bool Triggered)
	{
		CastSpell(targetGuid, SpellID, Triggered);
	}
	void EventCastSpell4(uint64 targetGuid, uint32 SpellID, bool Triggered, int32 ValOverride0);
	void CastSpellDelayed(uint64 targetGuid, uint32 SpellID, uint32 Delay, bool Triggered = true);
	void CastSpellDelayed2(uint64 targetGuid, uint32 SpellID, uint32 Delay, bool Triggered, int32 ValOverride0);

	bool isCasting();
	bool IsInInstance();
    int32 CalculateResistanceReduction(Unit *pVictim,dealdamage *dmg,SpellEntry* ability, int32 eff_index = 0xFF) ;
    float CalculateResistanceReductionPCT(Unit *pVictim,dealdamage *dmg,SpellEntry* ability, int32 eff_index = 0xFF) ;
	void RegenerateHealth();
	void RegeneratePower(bool isinterrupted);
	ARCEMU_INLINE void setHRegenTimer(uint32 time) {m_H_regenTimer = time; }
	ARCEMU_INLINE void setPRegenTimer(uint32 time) {m_P_regenTimer = time; }
	ARCEMU_INLINE void DelayPowerRegeneration(uint32 time) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_interruptedRegenStamp = getMSTime() + time;
	}
	void DeMorph();
	int32 ManaShieldAbsorb( int32 dmg );
	void smsg_AttackStart(Unit* pVictim);
	void smsg_AttackStop(Unit* pVictim);
	void smsg_AttackStop(const uint64 &victimGuid);
	
	bool IsDazed();
	//this function is used for creatures to get chance to daze for another unit
	float get_chance_to_daze(Unit *target);

	// Stealth  
	ARCEMU_INLINE int32 GetStealthLevel() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_stealthLevel; 
	}
	ARCEMU_INLINE int32 GetStealthDetectBonus() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_stealthDetectBonus; 
	}
	//!!!! in case of multiple stealth spells this might fail to represent the last valid stealth spell ID. It represents the last casted stealth spell and not the last removed one !
	ARCEMU_INLINE void SetStealth(uint32 id) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_stealth = id; 
	}
	ARCEMU_INLINE bool IsStealth() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return (m_stealth!=0 ? true : false); 
	}
//	float detectRange;

	// Invisibility
/*	ARCEMU_INLINE void SetInvisibility(uint32 id) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_invisibility = id; 
	} */
	ARCEMU_INLINE bool IsInvisible() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return ((m_invisFlag&(~INVIS_FLAG_NORMAL))!=0 ? true : false); 
	}
	void VanishFromSight();	//used when we turn invisible. Will cancel agro and will break spells casted on us

    ARCEMU_INLINE void SetHealthPct(uint32 val) { if (val>0) SetHealth(float2int32(val*0.01f*GetUInt32Value(UNIT_FIELD_MAXHEALTH))); };
    ARCEMU_INLINE void SetHealth( uint32 val ) { SetUInt32Value( UNIT_FIELD_HEALTH,  val ); } 
    ARCEMU_INLINE void SetMaxHealth( uint32 val ) { SetUInt32Value( UNIT_FIELD_MAXHEALTH,  val ); } 
    ARCEMU_INLINE uint32 GetHealth()    const { return GetUInt32Value( UNIT_FIELD_HEALTH ); }
    ARCEMU_INLINE uint32 GetMaxHealth() const { return GetUInt32Value( UNIT_FIELD_MAXHEALTH ); }
	ARCEMU_INLINE void ModHealth( int32 val ) { ModUnsigned32Value( UNIT_FIELD_HEALTH, val ); }
	ARCEMU_INLINE void ModMaxHealth( int32 val ) { ModUnsigned32Value( UNIT_FIELD_MAXHEALTH, val ); }
    ARCEMU_INLINE void SetPower(uint32 type, int32 value);
    ARCEMU_INLINE void ModPower( uint32 type, int32 value )
	{
        int32 power = GetPower( type );
		SetPower( type, power + value ); 
    }
    int32 GetPower( uint32 index );	//eclipse power can get negative
    ARCEMU_INLINE void SetMaxPower( uint32 type, uint32 value )
	{ 
		if( PowerFields[type] == - 1)
			return;
		SetUInt32Value( UNIT_FIELD_MAXPOWER1 + PowerFields[type], value ); 
	}
	ARCEMU_INLINE void ModMaxPower( uint32 type, int32 value )
	{ 
		if( PowerFields[type] == - 1)
			return;
		SetMaxPower( type, GetMaxPower( type ) + value );
	}
    ARCEMU_INLINE uint32 GetMaxPower( uint32 type )
	{ 
		if( PowerFields[type] == - 1)
			return 0;
		return GetUInt32Value( UNIT_FIELD_MAXPOWER1 + PowerFields[type] ); 
	}

	ARCEMU_INLINE uint32 GetHealthPct()
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		//shitty db? pet/guardian bug?
		if (
			//GetUInt32Value(UNIT_FIELD_HEALTH) == 0 || 
			GetUInt32Value(UNIT_FIELD_MAXHEALTH) == 0)
			return 0;

		//sadly this is not a joke. In cataclysm unit healts get so large that by multiplying it by 100 you get an overflow
		uint64 HP = GetUInt32Value(UNIT_FIELD_HEALTH);
		uint64 MAXHP = GetUInt32Value(UNIT_FIELD_MAXHEALTH);
		return (uint32)( HP * 100 / MAXHP );
	};

	ARCEMU_INLINE int GetManaPct()
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		if (GetPower( POWER_TYPE_MANA ) == 0 || GetMaxPower( POWER_TYPE_MANA ) == 0)
			return 0;

		return (int)(GetPower( POWER_TYPE_MANA ) * 100 / GetMaxPower( POWER_TYPE_MANA ));
	};
	ARCEMU_INLINE uint32 GetFaction() { return GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE); }

	ARCEMU_INLINE void SetFaction(uint32 factionId)
	{
		SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, factionId );
		_setFaction();
	}
	ARCEMU_INLINE void setLevel(uint32 level) { SetUInt32Value(UNIT_FIELD_LEVEL, level); };
	ARCEMU_INLINE void modLevel(int32 mod) { ModUnsigned32Value(UNIT_FIELD_LEVEL, mod); };

	//tr1::array< int32, INVIS_FLAG_TOTAL > m_invisFadeStrength;
	//tr1::array< int32, INVIS_FLAG_TOTAL > m_invisDetectStrength;
	uint64 m_invisFlag;
	uint64 m_invisDetect;

	void GiveGroupXP(Unit *pVictim, Player *PlayerInGroup);

	/// Combat / Death Status
	ARCEMU_INLINE bool isAlive() 
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_deathState == ALIVE; 
	}
	ARCEMU_INLINE bool IsDead() 
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return  m_deathState !=ALIVE; 
	}
	virtual void setDeathState(DeathState s) {
		m_deathState = s;
	};
	DeathState getDeathState() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_deathState; 
	}
	void OnDamageTaken();

	//! Add Aura to unit
	bool AddAura(Aura *aur);
	int32 RemoveAura(uint32 spellId, const uint64 &guid=0, uint32 SearchFlags=AURA_SEARCH_ALL, int32 Count=1);
	int32 RemoveAuraByNameHash(uint32 namehash, const uint64 &guid=0, uint32 SearchFlags=AURA_SEARCH_ALL, int32 Count=1);//required to remove weaker instances of a spell
	bool RemoveAuras(uint32 * SpellIds);
	uint32 RemoveAurasByHeal();
	uint32 RemoveAuraByHeal(uint32 Slot);
	void RemoveAurasMovementImpairing();
	//! Remove all auras
	void RemoveAllAuras();
    void RemoveAllAuraType(uint32 auratype);//ex:to remove morph spells
    void RemoveAllAuraFromSelfType2(uint32 auratype, uint32 butskip_hash);//ex:to remove morph spells
	bool RemoveAllAurasByMechanicMulti( uint32 MechanicTypeFlags , uint32 MaxDispel , bool HostileOnly ); // Removes all (de)buffs on unit of a specific mechanic type.
	bool RemoveAllAurasByMechanic( uint32 MechanicType , uint32 MaxDispel , bool HostileOnly ); // Removes all (de)buffs on unit of a specific mechanic type.
//	void RemoveAllMovementImpairing();
	void RemovePositiveAuras();	//visible auras except those that persist through death
	void RemoveNegativeAuras();	//visible auras except those that persist through death
	void RemoveAurasByBuffIndexType(uint32 buff_index_type, const uint64 &guid);
	void RemoveAurasByBuffType(uint32 buff_type, const uint64 &guid,uint32 skip, bool skip_caster_check);
	void RemoveAurasOfSchool(uint32 School, bool Positive, bool Immune);
	void RemoveAurasByInterruptFlag(uint32 flag){ RemoveAurasByInterruptFlagButSkip( flag ); };
	void RemoveAurasByInterruptFlagButSkip(uint32 flag, uint32 skip=0,uint32 skiphash=0, uint32 dmg=0);
	void RemoveAurasByInterruptFlagButSkip_slot(uint32 flag, uint32 skip,uint32 skiphash,uint32 slot, uint32 dmg);
	void RemoveAurasByInterruptItemChange(uint32 Class, uint32 SubClass);
	void RemoveAurasByZoneChange();
	void RemoveDuelAuras();
	void RemoveBGAuras();
	   // Find auras
	Aura *HasAuraWithNameHash(uint32 name_hash, const uint64 &guid = 0, uint32 SearchFlags = AURA_SEARCH_ALL);
	Aura* HasAura(uint32 spellId, const uint64 &guid = 0, uint32 SearchFlags = AURA_SEARCH_ALL );
	Aura* HasAuraWithMechanic( uint32 mechanic, uint32 SearchFlags, uint32 MechanicFlags = 0 );
	Aura* HasAuraWithType( uint32 Type, const uint64 &guid = 0, uint32 SearchFlags = AURA_SEARCH_ALL );
	uint32 CountAura(uint32 spell_id, uint32 SearchFlags); //just to reduce search range in some cases
	uint32 CountAuraNameHash(uint32 namehash, uint32 SearchFlags); //just to reduce search range in some cases
	

//	bool SetAurDuration(uint32 spellId,Unit* caster,uint32 duration);
//	bool SetAurDuration(uint32 spellId,uint32 duration);
	void DropAurasOnDeath();
	   
	void castSpell(Spell * pSpell);
	void InterruptSpell( uint64 OnlyIfTargettingMe = 0, bool ClearCooldown = 0 );

	//caller is the caster
	int32 GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg,int32 spell_effect_index, float *RetSumarryCoeff = NULL);
	int32 GetSpellHealBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_heal,int32 spell_effect_index, float *RetSumarryCoeff = NULL);
   
	Unit* create_guardian(uint32 guardian_entry,uint32 duration,uint32 lvl = 0, GameObject * obj = NULL, LocationVector * Vec = NULL, SpellEntry *CreatedBy = NULL, bool UseHPScale = true);//guardians are temporary spawn that will inherit master faction and will folow them. Apart from that they have their own mind
	Unit* create_summon(uint32 summon_entry,uint32 duration,uint32 lvl = 0, GameObject * obj = NULL, LocationVector * Vec = NULL);//summons are as guardians but there can only be one of them at a time
	void	DismissAllGuardians(); // on death or remove world

	//Creature *m_TotemSlots[4];
	tr1::array< Creature*,4> m_TotemSlots;
	//uint32 m_ObjectSlots[4];
	tr1::array< uint64, 4> m_ObjectSlots;
	
	// Spell Effect Variables
	int32 m_silenced;
	bool m_canMove;
	std::list<struct DamageProc> m_damageShields;
	CommitPointerList<struct ReflectSpellSchool> m_reflectSpellSchool;
	struct DamageSplitTarget *m_damageSplitTarget;
 
//	std::list<struct ProcTriggerSpell> m_procSpells;
//	SimplePointerList<struct ProcTriggerSpell> m_procSpells;
	CommitPointerList<struct ProcTriggerSpell> m_procSpells;
	uint32	m_procSpellsHaveTheseFlags;		//could skip the whole processing with 1 single check for special spells
//	uint8	m_procSpellsHaveTheseFlagsCount[32];
	ARCEMU_INLINE void	MarkHaveProcEvent( uint32 Flag );
	ARCEMU_INLINE void	UnMarkHaveProcEvent( uint32 Flag );
	void RegisterScriptProcStruct( ProcTriggerSpell &pts );	//needed cause memory menager crashes for external allocations :(
	void RegisterProcStruct( ProcTriggerSpell *pts );	
	ARCEMU_INLINE ProcTriggerSpell *HasProcSpell( uint32 SpellId );
	int32 UnRegisterProcStruct( void *Owner, uint32 SpellId = 0, int32 Count = 1, uint8 DisableEnable = 0 );		
//	std::map<uint32,ProcTriggerSpellOnSpellList> m_procSpellonSpell; //index is namehash
	std::map<uint32,struct SpellCharge> m_chargeSpells;
	ARCEMU_INLINE void RegisterNewChargeStruct( SpellCharge &pts );
	ARCEMU_INLINE void SetOnMeleeSpell( uint32 spell, uint8 ecn = 0 )
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_meleespell = spell; m_meleespell_ecn = ecn;  
	}
	ARCEMU_INLINE uint32 GetOnMeleeSpell() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_meleespell; 
	}
	ARCEMU_INLINE uint8 GetOnMeleeSpellEcn() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_meleespell_ecn; 
	}

	int32 DoDamageSplitTarget(int32 res, uint32 school_type, bool melee_dmg);

	// Spell Crit
	float	spellcritperc;
	uint32	EventsSpellsOverall,EventsSpellsCrit;	//this should be personalized for each spell apart
	uint32	EventsMeleeOverall,EventsMeleeCrit;	
	uint32	EventsRangedOverall,EventsRangedCrit;	

	// AIInterface
	AIInterface *GetAIInterface() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_aiInterface; 
	}
	void ReplaceAIInterface(AIInterface *new_interface) ;
	void ClearHateList();
	void WipeHateList();
	void WipeTargetList();
	ARCEMU_INLINE void setAItoUse(bool value){m_useAI = value;}


	int32 GetThreatModifyer() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_threatModifyer; 
	}
	void ModThreatModifyer(int32 mod) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_threatModifyer += mod; 
	}
	int32 GetGeneratedThreatModifyerPCT(uint32 school) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_generatedThreatModifyerPCT[school]; 
	}
	void ModGeneratedThreatModifyerPCT(uint32 school, int32 mod) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_generatedThreatModifyerPCT[school] += mod; 
	}

	void SetHitFromMeleeSpell(float value) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_hitfrommeleespell = value; 
		if( IsPlayer() == true )
			SetFloatValue( PLAYER_FIELD_UI_HIT_MODIFIER, m_hitfrommeleespell );
	}
	ARCEMU_INLINE float GetHitFromMeleeSpell() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_hitfrommeleespell; 
	}
	float m_hitfrommeleespell;

	// DK:Affect
	ARCEMU_INLINE uint32 IsPacified() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_pacified; 
	}
	ARCEMU_INLINE uint32 IsStunned() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_stunned; 
	}
	ARCEMU_INLINE uint32 IsFeared() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_fearmodifiers; 
	}
	ARCEMU_INLINE uint32 GetResistChanceMod() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_resistChance; 
	}
	ARCEMU_INLINE void SetResistChanceMod(uint32 amount) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_resistChance=amount; 
	}
	
	ARCEMU_INLINE uint16 HasNoInterrupt() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_noInterrupt; 
	}
	bool setDetectRangeMod(const uint64 &guid, int32 amount);
	void unsetDetectRangeMod(const uint64 &guid);
	int32 getDetectRangeMod(const uint64 &guid);
	void Heal(Unit* target,uint32 SpellId, uint32 amount);
	void Energize(Unit* target,uint32 SpellId, int32 amount, uint32 type, uint8 is_periodic );

	Loot loot;
	//uint32 SchoolCastPrevent[7];
	tr1::array< uint32, SCHOOL_COUNT > SchoolCastPrevent;
	ARCEMU_INLINE bool CanClassReceiveDMGOrHealBonus();
	ARCEMU_INLINE int32 GetDamageDoneMod(uint32 school, uint32 SchoolMask = 0);
	float GetDamageDonePctMod(uint32 school, uint32 SchoolMask = 0);
	//float DamageDoneModPCT[7];
	//tr1::array< float, 7> DamageDoneModPCT;
	//int32 DamageTakenMod[7];
	tr1::array< int32, SCHOOL_COUNT> DamageTakenMod;
	//float DamageTakenPctMod[7];
	tr1::array< int32, SCHOOL_COUNT> DamageTakenPctMod;	//for stacking auras it would be great to stack aditively and stack multiplicatively in rest ?
	tr1::array< int32, SCHOOL_COUNT> AoeDamageTakenPctMod;
	int32							 AoeDamageTakenPctModFromCreatures; //should be school based. Right now only 1 spell uses this
//	float DamageTakenPctModOnHP35;
	//float CritMeleeDamageTakenPctMod[7];
	tr1::array< float, SCHOOL_COUNT> CritMeleeDamageTakenPctMod;
	//float CritRangedDamageTakenPctMod[7];
	tr1::array< float, SCHOOL_COUNT> CritRangedDamageTakenPctMod;
	int32 RangedDamageTaken;
	void CalcDamage();
	//float BaseDamage[2];
	tr1::array< float, 2> BaseDamage;
	//float BaseOffhandDamage[2];
	tr1::array< float, 2> BaseOffhandDamage;
	//float BaseRangedDamage[2];
	tr1::array< float, 2> BaseRangedDamage;
	//SchoolAbsorb Absorbs[7];
	CommitPointerList<Absorb> Absorbs;
	int32 AbsorbDamage(uint32 School,int32 dmg);//returns amt of absorbed dmg, decreases dmg by absorbed value
	int32 RAPvModifier;
	int32 APvModifier;
	uint64 stalkedby;
	//uint32 dispels[10];
	tr1::array< uint32, DISPEL_COUNT> dispels;
//	bool trackStealth;
	//uint32 MechanicsDispels[MECHANIC_TOTAL];
	tr1::array< uint32, MECHANIC_TOTAL> MechanicsDispels;
	//float MechanicsResistancesPCT[MECHANIC_TOTAL]; 
	tr1::array< float, MECHANIC_TOTAL> MechanicsResistancesPCT;
	//float ModDamageTakenByMechPCT[MECHANIC_TOTAL];
	tr1::array< int32, MECHANIC_TOTAL> ModDamageTakenByMechPCT;
	tr1::array< int32, MECHANIC_TOTAL> ModDamageTakenByMechFlat;
	//int32 MechanicDurationPctMod[MECHANIC_TOTAL];
	tr1::array< int32, MECHANIC_TOTAL> MechanicDurationPctMod;
	tr1::array< int32, DISPEL_COUNT_NON_BENEFICIAL> DispelDurationPctMod;
	int32	OffensiveMagicalDurationModPCT;
	int32	RangedDamageTakenPct; 

	//SM
	UnitSMMods *SM_Mods;

	void InheritSMMods(Unit *inherit_from);

	//Events
	void Emote (EmoteType emote);
	void EventAddEmote(EmoteType emote, uint32 time);
	void EmoteExpire();
	ARCEMU_INLINE void setEmoteState(uint8 emote) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_emoteState = emote; 
	}
	ARCEMU_INLINE uint32 GetOldEmote() { return m_oldEmote; }
	void EventSummonPetExpire();
	void EventAurastateExpire(uint32 aurastateflag)
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		RemoveAuraStateFlag(aurastateflag);
	} //hmm this looks like so not necesary :S
	void EventHealthChangeSinceLastUpdate();

    /************************************************************************/
    /* Stun Immobilize                                                      */
    /************************************************************************/
	uint32	    trigger_on_stun;        //bah, warrior talent but this will not get triggered on triggered spells if used on proc so i'm forced to used a special variable
	uint32	    trigger_on_stun_chance;
	uint32	    trigger_on_stun_victim;
	uint32	    trigger_on_stun_chance_victim;

	void SetTriggerStunOrImmobilize(uint32 newtrigger,uint32 new_chance,bool is_victim=false)
    {
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		if( is_victim == false )
		{
			trigger_on_stun = newtrigger;
			trigger_on_stun_chance = new_chance;
		}
		else
		{
			trigger_on_stun_victim = newtrigger;
			trigger_on_stun_chance_victim = new_chance;
		}
    }
    void EventStunOrImmobilize(Unit *proc_target,bool is_victim=false);

	void SetStandState (uint8 standstate);

	ARCEMU_INLINE StandState GetStandState()
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		uint32 bytes1 = GetUInt32Value (UNIT_FIELD_BYTES_1);
		return StandState (uint8 (bytes1));
	}

	void SendChatMessage(uint8 type, uint32 lang, const char *msg);
	void SendChatMessageToPlayer(uint8 type, uint32 lang, const char *msg, Player *plr);
	void SendChatMessageAlternateEntry(uint32 entry, uint8 type, uint32 lang, const char * msg);
	void RegisterPeriodicChatMessage(uint32 delay, uint32 msgid, std::string message, bool sendnotify);
	//void SendHealLog(Object *from,uint32 spell,uint32 amm,bool self);
	
	uint32 GetResistance(uint32 type);	
	
	//In-Range
//	virtual void AddInRangeObject(Object* pObj);
	virtual void QueueRemoveInRangeObject(Object* pObj);

	ARCEMU_INLINE Spell * GetCurrentSpell(){return m_currentSpell;}
	ARCEMU_INLINE void SetCurrentSpell(Spell* cSpell) { m_currentSpell = cSpell; }

	uint32 m_CombatUpdateTimer;

	ARCEMU_INLINE void setcanperry(bool newstatus){can_parry=newstatus;}
		
//	std::map<uint32,Aura*> tmpAura;
	CommitPointerList<Aura> QueueAuraAdd; //on add aura there is a chance this list get changed and content changed
	ARCEMU_INLINE Aura *FindQueuedAura( uint32 SpellID );

	//uint32 BaseResistance[7]; //there are resistances for silence, fear, mechanics ....
	tr1::array< int32, 7> BaseResistance;
	//uint32 BaseStats[5];
	tr1::array< int32, 5> BaseStats;
	//int32 HealDoneMod[7];
//	tr1::array< int32, 7> HealDoneMod;
	int32 HealDoneMod;
	//int32 HealDonePctMod[7];
	//tr1::array< int32, 7> HealDonePctMod;
	int32 HealDonePctMod;
	int32 HealCritDonePctMod;
	//int32 HealTakenMod[7];
//	tr1::array< int32, 7> HealTakenMod;
	int32 HealTakenMod;
	//float HealTakenPctMod[7];
//	tr1::array< float, 7> HealTakenPctMod;
	int32 HealTakenPctMod;
	//uint32 SchoolImmunityList[7];
	uint8 SchoolImmunityAntiEnemy[SCHOOL_COUNT];		//friendly buffs should be working through these. This is blocking enemy casts
	uint8 SchoolImmunityAntiFriend[SCHOOL_COUNT];		//enemy buffs should be working through this. This is blocking the friendly casts
	tr1::array< uint8, 7> AuraSchoolImmunityList;
	//float SpellCritChanceSchool[7];
	tr1::array< float, 7> SpellCritChanceSchool;
	//int32 PowerCostMod[7];
	tr1::array< int32, 7> PowerCostMod;
	//float TargetResistRedModFlat[7]; // armor penetration & spell penetration
	tr1::array< float, 7> TargetResistRedModFlat;
	//int32 AttackerCritChanceMod[7];
	tr1::array< int32, 7> AttackerCritChanceMod;
	//uint32 SpellDelayResist[7];
	tr1::array< uint32, 7> SpellDelayResist;
	//int32 CreatureAttackPowerMod[12];
	tr1::array< int32, CREATURE_TYPES> CreatureAttackPowerMod;
	//int32 CreatureRangedAttackPowerMod[12];
	tr1::array< int32, CREATURE_TYPES> CreatureRangedAttackPowerMod;
	int32 MeleeDmgPCTMod;	//not an ability. The dmg you do with your weapon without an ability

	int32 RegenModifier;
	int32 PctRegenModifier;
	//float PctPowerRegenModifier[4];
	tr1::array< float, POWER_TYPE_COUNT> PctPowerRegenModifier;
	ARCEMU_INLINE uint32 GetPowerType(){ return (GetUInt32Value(UNIT_FIELD_BYTES_0)>> 24);}
	void UpdatePowerAmm(bool forced=false, int8 type=-1, int32 value=0xFFFF);

	// Auras Modifiers
	int32 m_pacified;
	int32 m_interruptRegen;
	int32 m_resistChance;
	int32 m_powerRegenPCT;
	int32 m_stunned;

	CommitPointerList<ExtraAttack>	m_extra_attacks;
	void AddExtraAttack( ExtraAttack *ea );

	int32 m_extrastriketarget;
	int32 m_extrastriketargetc;
	CommitPointerList<ExtraStrike> m_extraStrikeTargets;
	int32 m_fearmodifiers;
	int64 m_magnetcaster; // Unit who acts as a magnet for this unit
	int32 m_magnetcharges;
	//std::set<SpellEntry*> m_onStrikeSpells;

	uint16 m_noInterrupt;
	int32 m_rooted;
	uint8 disarmed;
	//uint64 m_detectRangeGUID[5];
	tr1::array< uint64, 5> m_detectRangeGUID;
	//int32  m_detectRangeMOD[5];
	tr1::array< int32, 5> m_detectRangeMOD;
	// Affect Speed
	int32 m_speedModifier;	//should be slowdown + speedup
	int32 m_slowdown;
	int32 m_speedup;
	float m_maxSpeed,m_minSpeed;	//only mod it by flat values !

	SimplePointerList< Modifier > speedReductionMap;
	bool GetSpeedDecrease();

	SimplePointerList< Modifier > speedIncreaseMap;
	bool GetSpeedIncrease();

	SimplePointerList< Modifier > ObjectSizeMods;
	void UpdateSizeMod();

	SimplePointerList< Modifier > ResistanceExclusive;
	ARCEMU_INLINE void GetResistanceExclusive( int32 SchoolMask, int32 &pos, int32 &neg );

	int32 m_mountedspeedModifier;
	int32 m_flyspeedModifier;
	void UpdateSpeed();
	void EnableFlight();
	void DisableFlight();
	void SendKnockbackPacket(float pcos,float psin,float radius,float verticalspeed);

	// Escort Quests
	//uint32 m_escortquestid;
	//uint32 m_escortupdatetimer;
	//bool bHasEscortQuest;
	//bool bEscortActive;
	//bool bStopAtEndOfWaypoints;
	//bool bReturnOnDie;
	//Player *q_AttachedPlayer;
	//uint16 m_escortStartWP;
	//uint16 m_escortEndWP;
	/*void InitializeEscortQuest(uint32 questid, bool stopatend, bool returnondie);
	void EscortSetStartWP(uint32 wp);
	void EscortSetEndWP(uint32 wp);
	void StartEscortQuest();
	void PauseEscortQuest();
	void EndEscortQuest();*/
	void MoveToWaypoint(uint32 wp_id);	
	void PlaySpellVisual(const uint64 &target, uint32 spellVisual);

	ARCEMU_INLINE void RemoveStealth()
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		if( m_stealth != 0 )
		{
			RemoveAura( m_stealth, 0, AURA_SEARCH_POSITIVE );
			m_stealth = 0;
		}
	}

	ARCEMU_INLINE void RemoveInvisibility();

	tr1::array< Aura*, MAX_AURAS + MAX_PASSIVE_AURAS> m_auras;   
	uint32 m_auras_pos_size; //right now these will only increase
	uint32 m_auras_neg_size; //right now these will only increase
	uint32 m_auras_pas_size; //right now these will only increase

	int32 m_modlanguage;
	
	Creature *critterPet;
	Creature *summonPet;

	ARCEMU_INLINE uint32 GetCharmTempVal() { return m_charmtemp; }
	ARCEMU_INLINE void SetCharmTempVal(uint32 val) { m_charmtemp = val; }

	ARCEMU_INLINE void DisableAI() { m_useAI = false; }
	ARCEMU_INLINE void EnableAI() { m_useAI = true; }

	ARCEMU_INLINE void SetPowerType(uint8 type)
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		SetByte(UNIT_FIELD_BYTES_0,3,type);
	}

	ARCEMU_INLINE bool IsSpiritHealer()
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		switch(GetEntry())
		{
		case 6491:  // Spirit Healer
		case 13116: // Alliance Spirit Guide
		case 13117: // Horde Spirit Guide
			{
				return true;
			}break;
		}
		return false;
	}

	void Root();
	void Unroot();

	void SetFacing(float newo);//only working if creature is idle

	uint32 GetDKDiseaseCount();
	bool IsPoisoned();

	AuraCheckResponse AuraCheck(Aura *new_aura, Aura *old_aura, uint32 MaxStackNow);
	AuraCheckResponse AuraCheck(uint32 name_hash, uint32 rank, Object *caster=NULL);
//	AuraCheckResponse AuraCheck(uint32 name_hash, uint32 rank, Aura* aur, Object *caster=NULL);

	//uint16 m_diminishCount[DIMINISHCOUNT];
	tr1::array< uint16, DIMINISHCOUNT > m_diminishCount;
	//uint16 m_diminishExpireStamp[DIMINISHCOUNT];
	tr1::array< uint32, DIMINISHCOUNT > m_diminishExpireStamp;

//	DynamicObject * dynObj;

	//! returns: aura stack count
	uint32	ModVisualAuraStackCount(Aura *aur, int32 count);
	uint16	FindVisualSlot(Aura *a,bool IsPos);

	//uint8	m_auraStackCount[ MAX_VISIBLE_AURAS ];
	tr1::array<uint8, MAX_VISIBLE_AURAS> m_auraStackCount;

	void	SendAurasToPlayer(Player *plr); 
	void	SendAllAurasToPlayer(uint32 GUID); //we use this in a delayed way since we need to create the object first client side then send auras

//	SpellEntry * pLastSpell;
	bool bInvincible;
	Player * m_redirectSpellPackets;
	void UpdateVisibility();

	//solo target auras
	uint32 polySpell;
	uint32 m_special_state; //flags for special states (stunned,rooted etc)

//	uint32 fearSpell;
//	uint32 m_cTimer;
	CombatStatusHandler CombatStatus;
	bool m_temp_summon;

//	void CancelSpell(Spell * ptr);
	void EventStrikeWithAbility(uint64 guid, SpellEntry * sp, uint32 damage);
//	bool m_spellsbusy;
	void DispelAll(bool positive);

	void			EventModelChange();			//model size changes when model changes
	inline float	GetModelHalfSize() { return ModelHalfSize*GetFloatValue(OBJECT_FIELD_SCALE_X);	}	//used to calculate combat reach and stuff

	void RemoveFieldSummon();

	ARCEMU_INLINE float GetBlockFromSpell() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_blockfromspell; 
	}
	ARCEMU_INLINE float GetParryFromSpell() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_parryfromspell; 
	}
	ARCEMU_INLINE float GetDodgeFromSpell() 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		return m_dodgefromspell; 
	}
	void SetBlockFromSpell(float value) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_blockfromspell = value; 
	}
	void SetParryFromSpell(float value) 
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_parryfromspell = value; 
	}
	void SetDodgeFromSpell(float value)
	{ 
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		m_dodgefromspell = value; 
	}

	UnitChain* m_chain;

	// Stealth
	uint8	m_stealth_dissalowed;
	uint32 m_stealth;
	uint32 m_stealthLevel;
	uint32 m_stealthDetectBonus;

	void	SetWeaponSheath(uint8 new_sheath); //draw weapon while in combat or restore sheath
	virtual bool IsPvPFlagged();
	virtual void SetPvPFlag();
	virtual void RemovePvPFlag();
	virtual bool IsFFAPvPFlagged();
	virtual void SetFFAPvPFlag();
	virtual void RemoveFFAPvPFlag();
	ARCEMU_INLINE uint32 GetOverkill(uint32 dmg)
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
	   if( GetUInt32Value(UNIT_FIELD_HEALTH) < dmg )
		   return dmg - GetUInt32Value(UNIT_FIELD_HEALTH);
	   return -1;
	}
	ARCEMU_INLINE uint32 GetOverHeal(uint32 dmg)
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
	   uint32 healthdiff = GetUInt32Value(UNIT_FIELD_MAXHEALTH) - GetUInt32Value(UNIT_FIELD_HEALTH);
	   if( healthdiff < dmg )
		   return dmg - healthdiff;
	   return -1;
	}
	ARCEMU_INLINE uint32 GetOverPower(uint32 dmg)
	{
		INSTRUMENT_TYPECAST_CHECK_UNIT_OBJECT_TYPE
		uint32 energydiff = GetMaxPower(  GetPowerType()) - GetPower(  GetPowerType());
	   if( energydiff < dmg )
		   return dmg - energydiff;
	   return 0;
	}
	//if no owner it will return self, in case unit was created by some other unit that was created by player then it will return player (elemental totem)
	Unit *GetTopOwner();
	virtual Group *GetGroup();
		/////////////////////////////////////////////////////// Unit properties ///////////////////////////////////////////////////
    void SetCharmedUnitGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_CHARM, GUID ); }
    void SetSummonedUnitGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_SUMMON, GUID ); }
    void SetSummonedCritterGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_CRITTER, GUID ); }

    void SetCharmedByGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_CHARMEDBY, GUID ); }
    void SetSummonedByGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_SUMMONEDBY, GUID ); }
    void SetCreatedByGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_CREATEDBY, GUID ); }


    uint64 GetCharmedUnitGUID(){ return GetUInt64Value( UNIT_FIELD_CHARM ); }
    uint64 GetSummonedUnitGUID(){ return GetUInt64Value( UNIT_FIELD_SUMMON ); }
    uint64 GetSummonedCritterGUID(){ return GetUInt64Value( UNIT_FIELD_CRITTER ); }

    uint64 GetCharmedByGUID(){ return GetUInt64Value( UNIT_FIELD_CHARMEDBY ); }
    uint64 GetSummonedByGUID(){ return GetUInt64Value( UNIT_FIELD_SUMMONEDBY ); }
    uint64 GetCreatedByGUID(){ return GetUInt64Value( UNIT_FIELD_CREATEDBY ); }

//    void SetTargetGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_TARGET, GUID ); }
    uint64 GetTargetGUID(){ return GetUInt64Value( UNIT_FIELD_TARGET ); }
	void	ClearTargetGUID();

    void SetChannelSpellTargetGUID( uint64 GUID ){ SetUInt64Value( UNIT_FIELD_CHANNEL_OBJECT, GUID ); }
    void SetChannelSpellId( uint32 SpellId ){ SetUInt32Value(UNIT_CHANNEL_SPELL, SpellId); }
    
    uint64 GetChannelSpellTargetGUID(){ return GetUInt64Value( UNIT_FIELD_CHANNEL_OBJECT ); }
    uint32 GetChannelSpellId(){ return GetUInt32Value(UNIT_CHANNEL_SPELL); }

	void SetEquippedItem( uint8 slot, uint32 id ) { SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+slot, id); }
	uint32 GetEquippedItem( uint8 slot ) { return GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+slot); }

	void SetBaseAttackTime( uint8 slot, uint32 time ) { SetUInt32Value(UNIT_FIELD_BASEATTACKTIME+slot, time); }
	uint32 GetBaseAttackTime( uint8 slot ) { return GetUInt32Value(UNIT_FIELD_BASEATTACKTIME+slot); }
	void ModBaseAttackTime( uint8 slot, int32 mod ) { ModUnsigned32Value(UNIT_FIELD_BASEATTACKTIME+slot, mod); }

	void SetBoundingRadius( float rad ) { SetFloatValue(UNIT_FIELD_BOUNDINGRADIUS, rad); }
	float GetBoundingRadius() { return GetFloatValue(UNIT_FIELD_BOUNDINGRADIUS); }

	void SetCombatReach( float len ) { SetFloatValue(UNIT_FIELD_COMBATREACH, len); }
	float GetCombatReach() { return GetFloatValue(UNIT_FIELD_COMBATREACH); }

	void SetDisplayId( uint32 id ) { SetUInt32Value(UNIT_FIELD_DISPLAYID, id); }
	uint32 GetDisplayId() { return GetUInt32Value(UNIT_FIELD_DISPLAYID); }
	void TryRestorePrevDisplayModAura();

	void SetNativeDisplayId( uint32 id ) { SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, id); }
	uint32 GetNativeDisplayId() { return GetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID); }

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	void SetMinDamage( float amt ) { SetFloatValue(UNIT_FIELD_MINDAMAGE, amt); }
	float GetMinDamage() { return GetFloatValue(UNIT_FIELD_MINDAMAGE); }

	void SetMaxDamage( float amt ) { SetFloatValue(UNIT_FIELD_MAXDAMAGE, amt); }
	float GetMaxDamage() { return GetFloatValue(UNIT_FIELD_MAXDAMAGE); }

	void SetMinOffhandDamage( float amt ) { SetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE, amt); }
	float GetMinOffhandDamage() { return GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE); }

	void SetMaxOffhandDamage( float amt ) { SetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE, amt); }
	float GetMaxOffhandDamage() { return GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE); }

	void SetMinRangedDamage( float amt ) { SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE, amt); }
	float GetMinRangedDamage() { return GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE); }

	void SetMaxRangedDamage( float amt ) { SetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE, amt); }
	float GetMaxRangedDamage() { return GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE); }

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	void SetMount( uint32 id ) { SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, id); }
	uint32 GetMount() { return GetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID); }

//	void SetCastSpeedMod( float amt ) { SetFloatValue(UNIT_MOD_CAST_SPEED, amt); }
	float GetCastSpeedMod() { return GetFloatValue(UNIT_MOD_CAST_SPEED); }
//	void ModCastSpeedMod( float mod ) { ModFloatValue(UNIT_MOD_CAST_SPEED, mod); }

	void SetCreatedBySpell( uint32 id ) { SetUInt32Value(UNIT_CREATED_BY_SPELL, id); }
	uint32 GetCreatedBySpell() { return GetUInt32Value(UNIT_CREATED_BY_SPELL); }

	void SetEmoteState( uint32 id ) { SetUInt32Value(UNIT_NPC_EMOTESTATE, id); }
	uint32 GetEmoteState() { return GetUInt32Value(UNIT_NPC_EMOTESTATE); }

	void SetStat( uint32 stat, uint32 amt ) { SetUInt32Value(UNIT_FIELD_STAT0+stat, amt); }
	uint32 GetStat( uint32 stat ) { return GetUInt32Value(UNIT_FIELD_STAT0+stat); }

	void SetResistance( uint32 type, uint32 amt ) { SetUInt32Value(UNIT_FIELD_RESISTANCES+type, amt); }
	
	void SetBaseMana( uint32 amt ) { SetUInt32Value(UNIT_FIELD_BASE_MANA, amt); }
	uint32 GetBaseMana() { return GetUInt32Value(UNIT_FIELD_BASE_MANA); }

	void SetBaseHealth( uint32 amt ) { SetUInt32Value(UNIT_FIELD_BASE_HEALTH, amt); }
	uint32 GetBaseHealth() { return GetUInt32Value(UNIT_FIELD_BASE_HEALTH); }

	void SetPowerCostMultiplier( uint32 school, float amt ) { SetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+school, amt); }
	void ModPowerCostMultiplier( uint32 school, float amt ) { ModFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+school, amt); }
	float GetPowerCostMultiplier( uint32 school ) { return GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+school); }

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*	void SetAttackPower( uint32 amt ) { SetUInt32Value(UNIT_FIELD_ATTACK_POWER, amt); }
	uint32 GetAttackPower() { return GetUInt32Value(UNIT_FIELD_ATTACK_POWER); }

	void SetAttackPowerMods( uint32 amt ) { SetUInt32Value(UNIT_FIELD_ATTACK_POWER_MODS, amt); }
	uint32 GetAttackPowerMods() { return GetUInt32Value(UNIT_FIELD_ATTACK_POWER_MODS); }
	void ModAttackPowerMods( uint32 amt ) { ModUnsigned32Value(UNIT_FIELD_ATTACK_POWER_MODS, amt); }

	void SetAttackPowerMultiplier( float amt ) { SetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, amt); }
	float GetAttackPowerMultiplier() { return GetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER); }
	void ModAttackPowerMultiplier( float amt ) { ModFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, amt); }

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	void SetRangedAttackPower( uint32 amt ) { SetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER, amt); }
	uint32 GetRangedAttackPower() { return GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER); }

	void SetRangedAttackPowerMods( uint32 amt ) { SetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER_MODS, amt); }
	uint32 GetRangedAttackPowerMods() { return GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER_MODS); }
	void ModRangedAttackPowerMods( uint32 amt ) { ModUnsigned32Value(UNIT_FIELD_RANGED_ATTACK_POWER_MODS, amt); }

	void SetRangedAttackPowerMultiplier( float amt ) { SetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER, amt); }
	float GetRangedAttackPowerMultiplier() { return GetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER); }
	void ModRangedAttackPowerMultiplier( float amt ) { ModFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER, amt); }*/
    
    //////////////////////////////////////////////////// bytes 0 //////////////////////////////////////////////////////
    
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
protected:
	Unit ();

	uint32 m_meleespell;
	uint8 m_meleespell_ecn; // SpellCastQueueIndex
//	uint8 m_aura_packet_serialization;	//at each aura send this number is increased so client can identify in which order to use packets
	void _UpdateSpells(uint32 time);

	uint32 m_H_regenTimer;
	uint32 m_P_regenTimer;
	uint32 m_interruptedRegenStamp; //PowerInterruptedegenTimer.
	uint32 m_state;		 // flags for keeping track of some states
	uint32 m_attackTimer;   // timer for attack
	uint32 m_attackTimer_1;
	bool m_dualWield;

	/// Combat
	DeathState m_deathState;
	
	// DK:pet
	//uint32 m_pet_state;
	//uint32 m_pet_action;

	// Spell currently casting
	Spell * m_currentSpell;

	// AI
	AIInterface *m_aiInterface;
	bool m_useAI;
	bool can_parry;//will be enabled by block spell
	int32 m_threatModifyer;
	//int32 m_generatedThreatModifyerPCT[7];
	tr1::array< int32, 7> m_generatedThreatModifyerPCT;

	//	float getDistance( float Position1X, float Position1Y, float Position2X, float Position2Y );	
	// Quest emote
	uint8 m_emoteState;
	uint32 m_oldEmote;

	uint32 m_charmtemp;

	float ModelHalfSize; // used to calculate if something is in range of this unit

	float m_blockfromspell;
	float m_dodgefromspell;
	float m_parryfromspell;

	virtual void GetAttackerPosAdjust(float &x,float &y){};
	virtual void GetSummonPosAdjust(float &x,float &y){};
	virtual float GetSummonAngle(const uint64 &guid){ return 0;};

public:
	virtual bool CanSee(Object* obj) { return true; }

	//for aura magnet caster
	Unit *CheckSpellTargetRedirect( Spell *spell );
	//on remove from world we remove summons also. not neceserally active summons
	std::list<uint64> m_guardians;		

	//vehicles -> note that vehicles have multiple components
	//note that this is shared data between multiple objects. Best practice is to have this mutexed to avoid concurent access to it. ! Do not delete it unless link is broken 2 ways !
	Vehicle *m_vehicle_data;						//store seats, proto for spells, this is not null if we are converted into a vehicle
	int8	m_CurrentVehicleSeat;					//this is valid only when we mounted our own or other vehicle
	void	ConvertToVehicle(CreatureProto *cp, bool skip_non_vehicle=true,bool is_mount=false);	//we become a vehicle
	void	DestoryVehicle();						//OMG SELF SUICIDE !
	void	ExitVehicle();
	bool	IsVehicleSeatHealthShielded();
	uint32	GetCurrentSeatEntry();
	// Retrieves the seat the passenger is located on
	ARCEMU_INLINE int8 GetSeatID() { return m_CurrentVehicleSeat; }
	ARCEMU_INLINE Vehicle *GetVehicle() { return m_vehicle_data; }
	uint32	GetCurrentVehicleID();
	bool	CanCastVehicleSpell( uint32 spellID );
	void	SetVehicle(Vehicle *v, int8 seat);
	bool	EnterVehicle(Vehicle * vehicle, int8 preferedseat);
	tr1::array< uint8, AURASTATE_MAX_INDEX> m_AuraStates;
	ARCEMU_INLINE void	SetAuraStateFlag(uint8 index,bool maxvalone = false)
	{
		if( index >= AURASTATE_MAX_INDEX || index == 0 )
			return;
		if( maxvalone && m_AuraStates[ index ] > 0 )
			return;
		m_AuraStates[ index ]++;	//maybe check overflow ? Naaah, you must be kidding me to overflow this :P
#ifdef _DEBUG
		if( m_AuraStates[ index ] > 10 )
			sLog.outDebug("Aurastate overflow iminent. Someone is setting the state and not removing it");
#endif
		SetFlag( UNIT_FIELD_AURASTATE, 1 << (index-1) );
	}
	ARCEMU_INLINE void	RemoveAuraStateFlag(uint8 index,bool maxvalone = false)
	{
		if( index >= AURASTATE_MAX_INDEX || index == 0 )
			return;
		if( maxvalone == true || m_AuraStates[ index ] == 1 )
		{
			m_AuraStates[ index ] = 0;	
			RemoveFlag( UNIT_FIELD_AURASTATE, 1 << (index-1) );
		}
		else if( m_AuraStates[ index ] > 1 )
			m_AuraStates[ index ]--;	
	}
	ARCEMU_INLINE bool	HasAuraStateFlag(uint8 index)
	{
		if( index >= AURASTATE_MAX_INDEX )
			return false;
		return (m_AuraStates[ index ] != 0);	
	}
	void smsg_TalentsInfo();
	int32 ResilianceAbsorb(int32 dmg, SpellEntry *sp,Object *attacker);
	float ResilianceAbsorbPCT(Object *attacker);
	void RageEventDamageTaken(int32 full_dmg, Unit *attacker );
	uint8 ImmuneToRanged;
	void AuraOfForebodingDelayedCheck(float x, float y, float radius, uint32 castspell, uint64 caster);	//after N seconds if we did not leave this area we will get another spell
	int32 HealAbsorb;		//amount of healing that will be absorbed in case healed. This value should never get negative
	int8	PowerFields[POWER_TYPE_COUNT];	//since 410 client power fields are class specific
	//moved from object. These are not used for items anymore in 420 client
	float m_walkSpeed;
	float m_runSpeed;
	float m_backWalkSpeed;
	float m_swimSpeed;
	float m_backSwimSpeed;
	float m_turnRate;
	float m_flySpeed;
	float m_backFlySpeed;
	float m_pitchRate;
	float m_base_runSpeed;
	float m_base_walkSpeed;

	void SMSG_HoverChange( bool enable_hover );
	uint32 m_PositionUpdateCounter;

	int32 m_manashieldamt;
	uint32 m_manaShieldId;
	void ModSpellReflectList( uint32 OwnerSpell, uint32 chance, int32 school, uint32 charges, bool apply );
	ARCEMU_INLINE bool IsCrowdControlledNoAttack() { return ( m_special_state & (UNIT_STATE_CONFUSE|UNIT_STATE_STUN|UNIT_STATE_SLEEP|UNIT_STATE_FEAR|UNIT_STATE_POLYMORPH) ) != 0; }

	SimplePointerList<SpellEffectOverrideScript>	mSpellOverrideMap;				//special spell effect handlers
};

#endif
